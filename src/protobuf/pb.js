/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.ClientHello = (function() {

    /**
     * Namespace ClientHello.
     * @exports ClientHello
     * @namespace
     */
    var ClientHello = {};

    /**
     * UserAgentPlatform enum.
     * @name ClientHello.UserAgentPlatform
     * @enum {number}
     * @property {number} ANDROID=0 ANDROID value
     * @property {number} IOS=1 IOS value
     * @property {number} WINDOWS_PHONE=2 WINDOWS_PHONE value
     * @property {number} BLACKBERRY=3 BLACKBERRY value
     * @property {number} BLACKBERRYX=4 BLACKBERRYX value
     * @property {number} S40=5 S40 value
     * @property {number} S60=6 S60 value
     * @property {number} PYTHON_CLIENT=7 PYTHON_CLIENT value
     * @property {number} TIZEN=8 TIZEN value
     * @property {number} ENTERPRISE=9 ENTERPRISE value
     * @property {number} SMB_ANDROID=10 SMB_ANDROID value
     * @property {number} KAIOS=11 KAIOS value
     * @property {number} SMB_IOS=12 SMB_IOS value
     * @property {number} WINDOWS=13 WINDOWS value
     * @property {number} WEB=14 WEB value
     */
    ClientHello.UserAgentPlatform = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ANDROID"] = 0;
        values[valuesById[1] = "IOS"] = 1;
        values[valuesById[2] = "WINDOWS_PHONE"] = 2;
        values[valuesById[3] = "BLACKBERRY"] = 3;
        values[valuesById[4] = "BLACKBERRYX"] = 4;
        values[valuesById[5] = "S40"] = 5;
        values[valuesById[6] = "S60"] = 6;
        values[valuesById[7] = "PYTHON_CLIENT"] = 7;
        values[valuesById[8] = "TIZEN"] = 8;
        values[valuesById[9] = "ENTERPRISE"] = 9;
        values[valuesById[10] = "SMB_ANDROID"] = 10;
        values[valuesById[11] = "KAIOS"] = 11;
        values[valuesById[12] = "SMB_IOS"] = 12;
        values[valuesById[13] = "WINDOWS"] = 13;
        values[valuesById[14] = "WEB"] = 14;
        return values;
    })();

    /**
     * ConnectType enum.
     * @name ClientHello.ConnectType
     * @enum {number}
     * @property {number} CELLULAR_UNKNOWN=0 CELLULAR_UNKNOWN value
     * @property {number} WIFI_UNKNOWN=1 WIFI_UNKNOWN value
     * @property {number} CELLULAR_EDGE=100 CELLULAR_EDGE value
     * @property {number} CELLULAR_IDEN=101 CELLULAR_IDEN value
     * @property {number} CELLULAR_UMTS=102 CELLULAR_UMTS value
     * @property {number} CELLULAR_EVDO=103 CELLULAR_EVDO value
     * @property {number} CELLULAR_GPRS=104 CELLULAR_GPRS value
     * @property {number} CELLULAR_HSDPA=105 CELLULAR_HSDPA value
     * @property {number} CELLULAR_HSUPA=106 CELLULAR_HSUPA value
     * @property {number} CELLULAR_HSPA=107 CELLULAR_HSPA value
     * @property {number} CELLULAR_CDMA=108 CELLULAR_CDMA value
     * @property {number} CELLULAR_1XRTT=109 CELLULAR_1XRTT value
     * @property {number} CELLULAR_EHRPD=110 CELLULAR_EHRPD value
     * @property {number} CELLULAR_LTE=111 CELLULAR_LTE value
     * @property {number} CELLULAR_HSPAP=112 CELLULAR_HSPAP value
     */
    ClientHello.ConnectType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "CELLULAR_UNKNOWN"] = 0;
        values[valuesById[1] = "WIFI_UNKNOWN"] = 1;
        values[valuesById[100] = "CELLULAR_EDGE"] = 100;
        values[valuesById[101] = "CELLULAR_IDEN"] = 101;
        values[valuesById[102] = "CELLULAR_UMTS"] = 102;
        values[valuesById[103] = "CELLULAR_EVDO"] = 103;
        values[valuesById[104] = "CELLULAR_GPRS"] = 104;
        values[valuesById[105] = "CELLULAR_HSDPA"] = 105;
        values[valuesById[106] = "CELLULAR_HSUPA"] = 106;
        values[valuesById[107] = "CELLULAR_HSPA"] = 107;
        values[valuesById[108] = "CELLULAR_CDMA"] = 108;
        values[valuesById[109] = "CELLULAR_1XRTT"] = 109;
        values[valuesById[110] = "CELLULAR_EHRPD"] = 110;
        values[valuesById[111] = "CELLULAR_LTE"] = 111;
        values[valuesById[112] = "CELLULAR_HSPAP"] = 112;
        return values;
    })();

    /**
     * ReleaseChannel enum.
     * @name ClientHello.ReleaseChannel
     * @enum {number}
     * @property {number} RELEASE=0 RELEASE value
     * @property {number} BETA=1 BETA value
     * @property {number} ALPHA=2 ALPHA value
     * @property {number} DEBUG=3 DEBUG value
     */
    ClientHello.ReleaseChannel = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RELEASE"] = 0;
        values[valuesById[1] = "BETA"] = 1;
        values[valuesById[2] = "ALPHA"] = 2;
        values[valuesById[3] = "DEBUG"] = 3;
        return values;
    })();

    ClientHello.AppVersion = (function() {

        /**
         * Properties of an AppVersion.
         * @memberof ClientHello
         * @interface IAppVersion
         * @property {number} primary AppVersion primary
         * @property {number} secondary AppVersion secondary
         * @property {number} tertiary AppVersion tertiary
         * @property {number|null} [quaternary] AppVersion quaternary
         */

        /**
         * Constructs a new AppVersion.
         * @memberof ClientHello
         * @classdesc Represents an AppVersion.
         * @implements IAppVersion
         * @constructor
         * @param {ClientHello.IAppVersion=} [properties] Properties to set
         */
        function AppVersion(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AppVersion primary.
         * @member {number} primary
         * @memberof ClientHello.AppVersion
         * @instance
         */
        AppVersion.prototype.primary = 0;

        /**
         * AppVersion secondary.
         * @member {number} secondary
         * @memberof ClientHello.AppVersion
         * @instance
         */
        AppVersion.prototype.secondary = 0;

        /**
         * AppVersion tertiary.
         * @member {number} tertiary
         * @memberof ClientHello.AppVersion
         * @instance
         */
        AppVersion.prototype.tertiary = 0;

        /**
         * AppVersion quaternary.
         * @member {number} quaternary
         * @memberof ClientHello.AppVersion
         * @instance
         */
        AppVersion.prototype.quaternary = 0;

        /**
         * Creates a new AppVersion instance using the specified properties.
         * @function create
         * @memberof ClientHello.AppVersion
         * @static
         * @param {ClientHello.IAppVersion=} [properties] Properties to set
         * @returns {ClientHello.AppVersion} AppVersion instance
         */
        AppVersion.create = function create(properties) {
            return new AppVersion(properties);
        };

        /**
         * Encodes the specified AppVersion message. Does not implicitly {@link ClientHello.AppVersion.verify|verify} messages.
         * @function encode
         * @memberof ClientHello.AppVersion
         * @static
         * @param {ClientHello.IAppVersion} message AppVersion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AppVersion.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.primary);
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.secondary);
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.tertiary);
            if (message.quaternary != null && Object.hasOwnProperty.call(message, "quaternary"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.quaternary);
            return writer;
        };

        /**
         * Encodes the specified AppVersion message, length delimited. Does not implicitly {@link ClientHello.AppVersion.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ClientHello.AppVersion
         * @static
         * @param {ClientHello.IAppVersion} message AppVersion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AppVersion.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AppVersion message from the specified reader or buffer.
         * @function decode
         * @memberof ClientHello.AppVersion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ClientHello.AppVersion} AppVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AppVersion.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClientHello.AppVersion();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.primary = reader.uint32();
                    break;
                case 2:
                    message.secondary = reader.uint32();
                    break;
                case 3:
                    message.tertiary = reader.uint32();
                    break;
                case 4:
                    message.quaternary = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("primary"))
                throw $util.ProtocolError("missing required 'primary'", { instance: message });
            if (!message.hasOwnProperty("secondary"))
                throw $util.ProtocolError("missing required 'secondary'", { instance: message });
            if (!message.hasOwnProperty("tertiary"))
                throw $util.ProtocolError("missing required 'tertiary'", { instance: message });
            return message;
        };

        /**
         * Decodes an AppVersion message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ClientHello.AppVersion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ClientHello.AppVersion} AppVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AppVersion.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AppVersion message.
         * @function verify
         * @memberof ClientHello.AppVersion
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AppVersion.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.primary))
                return "primary: integer expected";
            if (!$util.isInteger(message.secondary))
                return "secondary: integer expected";
            if (!$util.isInteger(message.tertiary))
                return "tertiary: integer expected";
            if (message.quaternary != null && message.hasOwnProperty("quaternary"))
                if (!$util.isInteger(message.quaternary))
                    return "quaternary: integer expected";
            return null;
        };

        /**
         * Creates an AppVersion message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ClientHello.AppVersion
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ClientHello.AppVersion} AppVersion
         */
        AppVersion.fromObject = function fromObject(object) {
            if (object instanceof $root.ClientHello.AppVersion)
                return object;
            var message = new $root.ClientHello.AppVersion();
            if (object.primary != null)
                message.primary = object.primary >>> 0;
            if (object.secondary != null)
                message.secondary = object.secondary >>> 0;
            if (object.tertiary != null)
                message.tertiary = object.tertiary >>> 0;
            if (object.quaternary != null)
                message.quaternary = object.quaternary >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an AppVersion message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ClientHello.AppVersion
         * @static
         * @param {ClientHello.AppVersion} message AppVersion
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AppVersion.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.primary = 0;
                object.secondary = 0;
                object.tertiary = 0;
                object.quaternary = 0;
            }
            if (message.primary != null && message.hasOwnProperty("primary"))
                object.primary = message.primary;
            if (message.secondary != null && message.hasOwnProperty("secondary"))
                object.secondary = message.secondary;
            if (message.tertiary != null && message.hasOwnProperty("tertiary"))
                object.tertiary = message.tertiary;
            if (message.quaternary != null && message.hasOwnProperty("quaternary"))
                object.quaternary = message.quaternary;
            return object;
        };

        /**
         * Converts this AppVersion to JSON.
         * @function toJSON
         * @memberof ClientHello.AppVersion
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AppVersion.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AppVersion;
    })();

    ClientHello.UserAgent = (function() {

        /**
         * Properties of a UserAgent.
         * @memberof ClientHello
         * @interface IUserAgent
         * @property {ClientHello.UserAgentPlatform|null} [platform] UserAgent platform
         * @property {ClientHello.IAppVersion|null} [appVersion] UserAgent appVersion
         * @property {string|null} [mcc] UserAgent mcc
         * @property {string|null} [mnc] UserAgent mnc
         * @property {string|null} [osVersion] UserAgent osVersion
         * @property {string|null} [manufacturer] UserAgent manufacturer
         * @property {string|null} [device] UserAgent device
         * @property {string|null} [osBuildNumber] UserAgent osBuildNumber
         * @property {string|null} [phoneId] UserAgent phoneId
         * @property {ClientHello.ReleaseChannel|null} [releaseChannel] UserAgent releaseChannel
         * @property {string|null} [localeLanguageIso_639_1] UserAgent localeLanguageIso_639_1
         * @property {string|null} [localeCountryIso_3166_1Alpha_2] UserAgent localeCountryIso_3166_1Alpha_2
         * @property {string|null} [device2] UserAgent device2
         */

        /**
         * Constructs a new UserAgent.
         * @memberof ClientHello
         * @classdesc Represents a UserAgent.
         * @implements IUserAgent
         * @constructor
         * @param {ClientHello.IUserAgent=} [properties] Properties to set
         */
        function UserAgent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserAgent platform.
         * @member {ClientHello.UserAgentPlatform} platform
         * @memberof ClientHello.UserAgent
         * @instance
         */
        UserAgent.prototype.platform = 0;

        /**
         * UserAgent appVersion.
         * @member {ClientHello.IAppVersion|null|undefined} appVersion
         * @memberof ClientHello.UserAgent
         * @instance
         */
        UserAgent.prototype.appVersion = null;

        /**
         * UserAgent mcc.
         * @member {string} mcc
         * @memberof ClientHello.UserAgent
         * @instance
         */
        UserAgent.prototype.mcc = "";

        /**
         * UserAgent mnc.
         * @member {string} mnc
         * @memberof ClientHello.UserAgent
         * @instance
         */
        UserAgent.prototype.mnc = "";

        /**
         * UserAgent osVersion.
         * @member {string} osVersion
         * @memberof ClientHello.UserAgent
         * @instance
         */
        UserAgent.prototype.osVersion = "";

        /**
         * UserAgent manufacturer.
         * @member {string} manufacturer
         * @memberof ClientHello.UserAgent
         * @instance
         */
        UserAgent.prototype.manufacturer = "";

        /**
         * UserAgent device.
         * @member {string} device
         * @memberof ClientHello.UserAgent
         * @instance
         */
        UserAgent.prototype.device = "";

        /**
         * UserAgent osBuildNumber.
         * @member {string} osBuildNumber
         * @memberof ClientHello.UserAgent
         * @instance
         */
        UserAgent.prototype.osBuildNumber = "";

        /**
         * UserAgent phoneId.
         * @member {string} phoneId
         * @memberof ClientHello.UserAgent
         * @instance
         */
        UserAgent.prototype.phoneId = "";

        /**
         * UserAgent releaseChannel.
         * @member {ClientHello.ReleaseChannel} releaseChannel
         * @memberof ClientHello.UserAgent
         * @instance
         */
        UserAgent.prototype.releaseChannel = 0;

        /**
         * UserAgent localeLanguageIso_639_1.
         * @member {string} localeLanguageIso_639_1
         * @memberof ClientHello.UserAgent
         * @instance
         */
        UserAgent.prototype.localeLanguageIso_639_1 = "";

        /**
         * UserAgent localeCountryIso_3166_1Alpha_2.
         * @member {string} localeCountryIso_3166_1Alpha_2
         * @memberof ClientHello.UserAgent
         * @instance
         */
        UserAgent.prototype.localeCountryIso_3166_1Alpha_2 = "";

        /**
         * UserAgent device2.
         * @member {string} device2
         * @memberof ClientHello.UserAgent
         * @instance
         */
        UserAgent.prototype.device2 = "";

        /**
         * Creates a new UserAgent instance using the specified properties.
         * @function create
         * @memberof ClientHello.UserAgent
         * @static
         * @param {ClientHello.IUserAgent=} [properties] Properties to set
         * @returns {ClientHello.UserAgent} UserAgent instance
         */
        UserAgent.create = function create(properties) {
            return new UserAgent(properties);
        };

        /**
         * Encodes the specified UserAgent message. Does not implicitly {@link ClientHello.UserAgent.verify|verify} messages.
         * @function encode
         * @memberof ClientHello.UserAgent
         * @static
         * @param {ClientHello.IUserAgent} message UserAgent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserAgent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.platform);
            if (message.appVersion != null && Object.hasOwnProperty.call(message, "appVersion"))
                $root.ClientHello.AppVersion.encode(message.appVersion, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.mcc != null && Object.hasOwnProperty.call(message, "mcc"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.mcc);
            if (message.mnc != null && Object.hasOwnProperty.call(message, "mnc"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.mnc);
            if (message.osVersion != null && Object.hasOwnProperty.call(message, "osVersion"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.osVersion);
            if (message.manufacturer != null && Object.hasOwnProperty.call(message, "manufacturer"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.manufacturer);
            if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.device);
            if (message.osBuildNumber != null && Object.hasOwnProperty.call(message, "osBuildNumber"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.osBuildNumber);
            if (message.phoneId != null && Object.hasOwnProperty.call(message, "phoneId"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.phoneId);
            if (message.releaseChannel != null && Object.hasOwnProperty.call(message, "releaseChannel"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.releaseChannel);
            if (message.localeLanguageIso_639_1 != null && Object.hasOwnProperty.call(message, "localeLanguageIso_639_1"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.localeLanguageIso_639_1);
            if (message.localeCountryIso_3166_1Alpha_2 != null && Object.hasOwnProperty.call(message, "localeCountryIso_3166_1Alpha_2"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.localeCountryIso_3166_1Alpha_2);
            if (message.device2 != null && Object.hasOwnProperty.call(message, "device2"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.device2);
            return writer;
        };

        /**
         * Encodes the specified UserAgent message, length delimited. Does not implicitly {@link ClientHello.UserAgent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ClientHello.UserAgent
         * @static
         * @param {ClientHello.IUserAgent} message UserAgent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserAgent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserAgent message from the specified reader or buffer.
         * @function decode
         * @memberof ClientHello.UserAgent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ClientHello.UserAgent} UserAgent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserAgent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClientHello.UserAgent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.platform = reader.int32();
                    break;
                case 2:
                    message.appVersion = $root.ClientHello.AppVersion.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.mcc = reader.string();
                    break;
                case 4:
                    message.mnc = reader.string();
                    break;
                case 5:
                    message.osVersion = reader.string();
                    break;
                case 6:
                    message.manufacturer = reader.string();
                    break;
                case 7:
                    message.device = reader.string();
                    break;
                case 8:
                    message.osBuildNumber = reader.string();
                    break;
                case 9:
                    message.phoneId = reader.string();
                    break;
                case 10:
                    message.releaseChannel = reader.int32();
                    break;
                case 11:
                    message.localeLanguageIso_639_1 = reader.string();
                    break;
                case 12:
                    message.localeCountryIso_3166_1Alpha_2 = reader.string();
                    break;
                case 13:
                    message.device2 = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserAgent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ClientHello.UserAgent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ClientHello.UserAgent} UserAgent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserAgent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserAgent message.
         * @function verify
         * @memberof ClientHello.UserAgent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserAgent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.platform != null && message.hasOwnProperty("platform"))
                switch (message.platform) {
                default:
                    return "platform: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                    break;
                }
            if (message.appVersion != null && message.hasOwnProperty("appVersion")) {
                var error = $root.ClientHello.AppVersion.verify(message.appVersion);
                if (error)
                    return "appVersion." + error;
            }
            if (message.mcc != null && message.hasOwnProperty("mcc"))
                if (!$util.isString(message.mcc))
                    return "mcc: string expected";
            if (message.mnc != null && message.hasOwnProperty("mnc"))
                if (!$util.isString(message.mnc))
                    return "mnc: string expected";
            if (message.osVersion != null && message.hasOwnProperty("osVersion"))
                if (!$util.isString(message.osVersion))
                    return "osVersion: string expected";
            if (message.manufacturer != null && message.hasOwnProperty("manufacturer"))
                if (!$util.isString(message.manufacturer))
                    return "manufacturer: string expected";
            if (message.device != null && message.hasOwnProperty("device"))
                if (!$util.isString(message.device))
                    return "device: string expected";
            if (message.osBuildNumber != null && message.hasOwnProperty("osBuildNumber"))
                if (!$util.isString(message.osBuildNumber))
                    return "osBuildNumber: string expected";
            if (message.phoneId != null && message.hasOwnProperty("phoneId"))
                if (!$util.isString(message.phoneId))
                    return "phoneId: string expected";
            if (message.releaseChannel != null && message.hasOwnProperty("releaseChannel"))
                switch (message.releaseChannel) {
                default:
                    return "releaseChannel: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.localeLanguageIso_639_1 != null && message.hasOwnProperty("localeLanguageIso_639_1"))
                if (!$util.isString(message.localeLanguageIso_639_1))
                    return "localeLanguageIso_639_1: string expected";
            if (message.localeCountryIso_3166_1Alpha_2 != null && message.hasOwnProperty("localeCountryIso_3166_1Alpha_2"))
                if (!$util.isString(message.localeCountryIso_3166_1Alpha_2))
                    return "localeCountryIso_3166_1Alpha_2: string expected";
            if (message.device2 != null && message.hasOwnProperty("device2"))
                if (!$util.isString(message.device2))
                    return "device2: string expected";
            return null;
        };

        /**
         * Creates a UserAgent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ClientHello.UserAgent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ClientHello.UserAgent} UserAgent
         */
        UserAgent.fromObject = function fromObject(object) {
            if (object instanceof $root.ClientHello.UserAgent)
                return object;
            var message = new $root.ClientHello.UserAgent();
            switch (object.platform) {
            case "ANDROID":
            case 0:
                message.platform = 0;
                break;
            case "IOS":
            case 1:
                message.platform = 1;
                break;
            case "WINDOWS_PHONE":
            case 2:
                message.platform = 2;
                break;
            case "BLACKBERRY":
            case 3:
                message.platform = 3;
                break;
            case "BLACKBERRYX":
            case 4:
                message.platform = 4;
                break;
            case "S40":
            case 5:
                message.platform = 5;
                break;
            case "S60":
            case 6:
                message.platform = 6;
                break;
            case "PYTHON_CLIENT":
            case 7:
                message.platform = 7;
                break;
            case "TIZEN":
            case 8:
                message.platform = 8;
                break;
            case "ENTERPRISE":
            case 9:
                message.platform = 9;
                break;
            case "SMB_ANDROID":
            case 10:
                message.platform = 10;
                break;
            case "KAIOS":
            case 11:
                message.platform = 11;
                break;
            case "SMB_IOS":
            case 12:
                message.platform = 12;
                break;
            case "WINDOWS":
            case 13:
                message.platform = 13;
                break;
            case "WEB":
            case 14:
                message.platform = 14;
                break;
            }
            if (object.appVersion != null) {
                if (typeof object.appVersion !== "object")
                    throw TypeError(".ClientHello.UserAgent.appVersion: object expected");
                message.appVersion = $root.ClientHello.AppVersion.fromObject(object.appVersion);
            }
            if (object.mcc != null)
                message.mcc = String(object.mcc);
            if (object.mnc != null)
                message.mnc = String(object.mnc);
            if (object.osVersion != null)
                message.osVersion = String(object.osVersion);
            if (object.manufacturer != null)
                message.manufacturer = String(object.manufacturer);
            if (object.device != null)
                message.device = String(object.device);
            if (object.osBuildNumber != null)
                message.osBuildNumber = String(object.osBuildNumber);
            if (object.phoneId != null)
                message.phoneId = String(object.phoneId);
            switch (object.releaseChannel) {
            case "RELEASE":
            case 0:
                message.releaseChannel = 0;
                break;
            case "BETA":
            case 1:
                message.releaseChannel = 1;
                break;
            case "ALPHA":
            case 2:
                message.releaseChannel = 2;
                break;
            case "DEBUG":
            case 3:
                message.releaseChannel = 3;
                break;
            }
            if (object.localeLanguageIso_639_1 != null)
                message.localeLanguageIso_639_1 = String(object.localeLanguageIso_639_1);
            if (object.localeCountryIso_3166_1Alpha_2 != null)
                message.localeCountryIso_3166_1Alpha_2 = String(object.localeCountryIso_3166_1Alpha_2);
            if (object.device2 != null)
                message.device2 = String(object.device2);
            return message;
        };

        /**
         * Creates a plain object from a UserAgent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ClientHello.UserAgent
         * @static
         * @param {ClientHello.UserAgent} message UserAgent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserAgent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.platform = options.enums === String ? "ANDROID" : 0;
                object.appVersion = null;
                object.mcc = "";
                object.mnc = "";
                object.osVersion = "";
                object.manufacturer = "";
                object.device = "";
                object.osBuildNumber = "";
                object.phoneId = "";
                object.releaseChannel = options.enums === String ? "RELEASE" : 0;
                object.localeLanguageIso_639_1 = "";
                object.localeCountryIso_3166_1Alpha_2 = "";
                object.device2 = "";
            }
            if (message.platform != null && message.hasOwnProperty("platform"))
                object.platform = options.enums === String ? $root.ClientHello.UserAgentPlatform[message.platform] : message.platform;
            if (message.appVersion != null && message.hasOwnProperty("appVersion"))
                object.appVersion = $root.ClientHello.AppVersion.toObject(message.appVersion, options);
            if (message.mcc != null && message.hasOwnProperty("mcc"))
                object.mcc = message.mcc;
            if (message.mnc != null && message.hasOwnProperty("mnc"))
                object.mnc = message.mnc;
            if (message.osVersion != null && message.hasOwnProperty("osVersion"))
                object.osVersion = message.osVersion;
            if (message.manufacturer != null && message.hasOwnProperty("manufacturer"))
                object.manufacturer = message.manufacturer;
            if (message.device != null && message.hasOwnProperty("device"))
                object.device = message.device;
            if (message.osBuildNumber != null && message.hasOwnProperty("osBuildNumber"))
                object.osBuildNumber = message.osBuildNumber;
            if (message.phoneId != null && message.hasOwnProperty("phoneId"))
                object.phoneId = message.phoneId;
            if (message.releaseChannel != null && message.hasOwnProperty("releaseChannel"))
                object.releaseChannel = options.enums === String ? $root.ClientHello.ReleaseChannel[message.releaseChannel] : message.releaseChannel;
            if (message.localeLanguageIso_639_1 != null && message.hasOwnProperty("localeLanguageIso_639_1"))
                object.localeLanguageIso_639_1 = message.localeLanguageIso_639_1;
            if (message.localeCountryIso_3166_1Alpha_2 != null && message.hasOwnProperty("localeCountryIso_3166_1Alpha_2"))
                object.localeCountryIso_3166_1Alpha_2 = message.localeCountryIso_3166_1Alpha_2;
            if (message.device2 != null && message.hasOwnProperty("device2"))
                object.device2 = message.device2;
            return object;
        };

        /**
         * Converts this UserAgent to JSON.
         * @function toJSON
         * @memberof ClientHello.UserAgent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserAgent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserAgent;
    })();

    ClientHello.C2S = (function() {

        /**
         * Properties of a C2S.
         * @memberof ClientHello
         * @interface IC2S
         * @property {number|Long|null} [username] C2S username
         * @property {boolean|null} [passive] C2S passive
         * @property {Array.<ClientHello.C2S.ClientFeature>|null} [clientFeatures] C2S clientFeatures
         * @property {ClientHello.IUserAgent|null} [useragent] C2S useragent
         * @property {ClientHello.C2S.IWebInfo|null} [webInfo] C2S webInfo
         * @property {string|null} [pushName] C2S pushName
         * @property {number|null} [sessionId] C2S sessionId
         * @property {boolean|null} [shortConnect] C2S shortConnect
         * @property {ClientHello.C2S.ConnectType|null} [connectType] C2S connectType
         * @property {ClientHello.C2S.ConnectReason|null} [connectReason] C2S connectReason
         * @property {Array.<number>|null} [shards] C2S shards
         * @property {ClientHello.C2S.IDnsSource|null} [dnsSource] C2S dnsSource
         * @property {number|null} [connectAttemptCount] C2S connectAttemptCount
         * @property {ClientHello.C2S.ICompanionRegData|null} [regData] C2S regData
         * @property {number|null} [tag23] C2S tag23
         * @property {number|null} [tag24] C2S tag24
         * @property {ClientHello.C2S.IosAppExtension|null} [iosAppExtension] C2S iosAppExtension
         */

        /**
         * Constructs a new C2S.
         * @memberof ClientHello
         * @classdesc Represents a C2S.
         * @implements IC2S
         * @constructor
         * @param {ClientHello.IC2S=} [properties] Properties to set
         */
        function C2S(properties) {
            this.clientFeatures = [];
            this.shards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2S username.
         * @member {number|Long} username
         * @memberof ClientHello.C2S
         * @instance
         */
        C2S.prototype.username = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * C2S passive.
         * @member {boolean} passive
         * @memberof ClientHello.C2S
         * @instance
         */
        C2S.prototype.passive = false;

        /**
         * C2S clientFeatures.
         * @member {Array.<ClientHello.C2S.ClientFeature>} clientFeatures
         * @memberof ClientHello.C2S
         * @instance
         */
        C2S.prototype.clientFeatures = $util.emptyArray;

        /**
         * C2S useragent.
         * @member {ClientHello.IUserAgent|null|undefined} useragent
         * @memberof ClientHello.C2S
         * @instance
         */
        C2S.prototype.useragent = null;

        /**
         * C2S webInfo.
         * @member {ClientHello.C2S.IWebInfo|null|undefined} webInfo
         * @memberof ClientHello.C2S
         * @instance
         */
        C2S.prototype.webInfo = null;

        /**
         * C2S pushName.
         * @member {string} pushName
         * @memberof ClientHello.C2S
         * @instance
         */
        C2S.prototype.pushName = "";

        /**
         * C2S sessionId.
         * @member {number} sessionId
         * @memberof ClientHello.C2S
         * @instance
         */
        C2S.prototype.sessionId = 0;

        /**
         * C2S shortConnect.
         * @member {boolean} shortConnect
         * @memberof ClientHello.C2S
         * @instance
         */
        C2S.prototype.shortConnect = false;

        /**
         * C2S connectType.
         * @member {ClientHello.C2S.ConnectType} connectType
         * @memberof ClientHello.C2S
         * @instance
         */
        C2S.prototype.connectType = 0;

        /**
         * C2S connectReason.
         * @member {ClientHello.C2S.ConnectReason} connectReason
         * @memberof ClientHello.C2S
         * @instance
         */
        C2S.prototype.connectReason = 0;

        /**
         * C2S shards.
         * @member {Array.<number>} shards
         * @memberof ClientHello.C2S
         * @instance
         */
        C2S.prototype.shards = $util.emptyArray;

        /**
         * C2S dnsSource.
         * @member {ClientHello.C2S.IDnsSource|null|undefined} dnsSource
         * @memberof ClientHello.C2S
         * @instance
         */
        C2S.prototype.dnsSource = null;

        /**
         * C2S connectAttemptCount.
         * @member {number} connectAttemptCount
         * @memberof ClientHello.C2S
         * @instance
         */
        C2S.prototype.connectAttemptCount = 0;

        /**
         * C2S regData.
         * @member {ClientHello.C2S.ICompanionRegData|null|undefined} regData
         * @memberof ClientHello.C2S
         * @instance
         */
        C2S.prototype.regData = null;

        /**
         * C2S tag23.
         * @member {number} tag23
         * @memberof ClientHello.C2S
         * @instance
         */
        C2S.prototype.tag23 = 0;

        /**
         * C2S tag24.
         * @member {number} tag24
         * @memberof ClientHello.C2S
         * @instance
         */
        C2S.prototype.tag24 = 0;

        /**
         * C2S iosAppExtension.
         * @member {ClientHello.C2S.IosAppExtension} iosAppExtension
         * @memberof ClientHello.C2S
         * @instance
         */
        C2S.prototype.iosAppExtension = 0;

        /**
         * Creates a new C2S instance using the specified properties.
         * @function create
         * @memberof ClientHello.C2S
         * @static
         * @param {ClientHello.IC2S=} [properties] Properties to set
         * @returns {ClientHello.C2S} C2S instance
         */
        C2S.create = function create(properties) {
            return new C2S(properties);
        };

        /**
         * Encodes the specified C2S message. Does not implicitly {@link ClientHello.C2S.verify|verify} messages.
         * @function encode
         * @memberof ClientHello.C2S
         * @static
         * @param {ClientHello.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.username);
            if (message.passive != null && Object.hasOwnProperty.call(message, "passive"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.passive);
            if (message.clientFeatures != null && message.clientFeatures.length)
                for (var i = 0; i < message.clientFeatures.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.clientFeatures[i]);
            if (message.useragent != null && Object.hasOwnProperty.call(message, "useragent"))
                $root.ClientHello.UserAgent.encode(message.useragent, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.webInfo != null && Object.hasOwnProperty.call(message, "webInfo"))
                $root.ClientHello.C2S.WebInfo.encode(message.webInfo, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.pushName != null && Object.hasOwnProperty.call(message, "pushName"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.pushName);
            if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                writer.uint32(/* id 9, wireType 5 =*/77).sfixed32(message.sessionId);
            if (message.shortConnect != null && Object.hasOwnProperty.call(message, "shortConnect"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.shortConnect);
            if (message.connectType != null && Object.hasOwnProperty.call(message, "connectType"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.connectType);
            if (message.connectReason != null && Object.hasOwnProperty.call(message, "connectReason"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.connectReason);
            if (message.shards != null && message.shards.length)
                for (var i = 0; i < message.shards.length; ++i)
                    writer.uint32(/* id 14, wireType 5 =*/117).sfixed32(message.shards[i]);
            if (message.dnsSource != null && Object.hasOwnProperty.call(message, "dnsSource"))
                $root.ClientHello.C2S.DnsSource.encode(message.dnsSource, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.connectAttemptCount != null && Object.hasOwnProperty.call(message, "connectAttemptCount"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.connectAttemptCount);
            if (message.regData != null && Object.hasOwnProperty.call(message, "regData"))
                $root.ClientHello.C2S.CompanionRegData.encode(message.regData, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.tag23 != null && Object.hasOwnProperty.call(message, "tag23"))
                writer.uint32(/* id 23, wireType 0 =*/184).uint32(message.tag23);
            if (message.tag24 != null && Object.hasOwnProperty.call(message, "tag24"))
                writer.uint32(/* id 24, wireType 0 =*/192).uint32(message.tag24);
            if (message.iosAppExtension != null && Object.hasOwnProperty.call(message, "iosAppExtension"))
                writer.uint32(/* id 30, wireType 0 =*/240).int32(message.iosAppExtension);
            return writer;
        };

        /**
         * Encodes the specified C2S message, length delimited. Does not implicitly {@link ClientHello.C2S.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ClientHello.C2S
         * @static
         * @param {ClientHello.IC2S} message C2S message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2S.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2S message from the specified reader or buffer.
         * @function decode
         * @memberof ClientHello.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ClientHello.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClientHello.C2S();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.username = reader.uint64();
                    break;
                case 3:
                    message.passive = reader.bool();
                    break;
                case 4:
                    if (!(message.clientFeatures && message.clientFeatures.length))
                        message.clientFeatures = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.clientFeatures.push(reader.int32());
                    } else
                        message.clientFeatures.push(reader.int32());
                    break;
                case 5:
                    message.useragent = $root.ClientHello.UserAgent.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.webInfo = $root.ClientHello.C2S.WebInfo.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.pushName = reader.string();
                    break;
                case 9:
                    message.sessionId = reader.sfixed32();
                    break;
                case 10:
                    message.shortConnect = reader.bool();
                    break;
                case 12:
                    message.connectType = reader.int32();
                    break;
                case 13:
                    message.connectReason = reader.int32();
                    break;
                case 14:
                    if (!(message.shards && message.shards.length))
                        message.shards = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.shards.push(reader.sfixed32());
                    } else
                        message.shards.push(reader.sfixed32());
                    break;
                case 15:
                    message.dnsSource = $root.ClientHello.C2S.DnsSource.decode(reader, reader.uint32());
                    break;
                case 16:
                    message.connectAttemptCount = reader.uint32();
                    break;
                case 19:
                    message.regData = $root.ClientHello.C2S.CompanionRegData.decode(reader, reader.uint32());
                    break;
                case 23:
                    message.tag23 = reader.uint32();
                    break;
                case 24:
                    message.tag24 = reader.uint32();
                    break;
                case 30:
                    message.iosAppExtension = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2S message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ClientHello.C2S
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ClientHello.C2S} C2S
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2S.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2S message.
         * @function verify
         * @memberof ClientHello.C2S
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2S.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isInteger(message.username) && !(message.username && $util.isInteger(message.username.low) && $util.isInteger(message.username.high)))
                    return "username: integer|Long expected";
            if (message.passive != null && message.hasOwnProperty("passive"))
                if (typeof message.passive !== "boolean")
                    return "passive: boolean expected";
            if (message.clientFeatures != null && message.hasOwnProperty("clientFeatures")) {
                if (!Array.isArray(message.clientFeatures))
                    return "clientFeatures: array expected";
                for (var i = 0; i < message.clientFeatures.length; ++i)
                    switch (message.clientFeatures[i]) {
                    default:
                        return "clientFeatures: enum value[] expected";
                    case 0:
                        break;
                    }
            }
            if (message.useragent != null && message.hasOwnProperty("useragent")) {
                var error = $root.ClientHello.UserAgent.verify(message.useragent);
                if (error)
                    return "useragent." + error;
            }
            if (message.webInfo != null && message.hasOwnProperty("webInfo")) {
                var error = $root.ClientHello.C2S.WebInfo.verify(message.webInfo);
                if (error)
                    return "webInfo." + error;
            }
            if (message.pushName != null && message.hasOwnProperty("pushName"))
                if (!$util.isString(message.pushName))
                    return "pushName: string expected";
            if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                if (!$util.isInteger(message.sessionId))
                    return "sessionId: integer expected";
            if (message.shortConnect != null && message.hasOwnProperty("shortConnect"))
                if (typeof message.shortConnect !== "boolean")
                    return "shortConnect: boolean expected";
            if (message.connectType != null && message.hasOwnProperty("connectType"))
                switch (message.connectType) {
                default:
                    return "connectType: enum value expected";
                case 0:
                case 1:
                case 100:
                case 101:
                case 102:
                case 103:
                case 104:
                case 105:
                case 106:
                case 107:
                case 108:
                case 109:
                case 110:
                case 111:
                case 112:
                    break;
                }
            if (message.connectReason != null && message.hasOwnProperty("connectReason"))
                switch (message.connectReason) {
                default:
                    return "connectReason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.shards != null && message.hasOwnProperty("shards")) {
                if (!Array.isArray(message.shards))
                    return "shards: array expected";
                for (var i = 0; i < message.shards.length; ++i)
                    if (!$util.isInteger(message.shards[i]))
                        return "shards: integer[] expected";
            }
            if (message.dnsSource != null && message.hasOwnProperty("dnsSource")) {
                var error = $root.ClientHello.C2S.DnsSource.verify(message.dnsSource);
                if (error)
                    return "dnsSource." + error;
            }
            if (message.connectAttemptCount != null && message.hasOwnProperty("connectAttemptCount"))
                if (!$util.isInteger(message.connectAttemptCount))
                    return "connectAttemptCount: integer expected";
            if (message.regData != null && message.hasOwnProperty("regData")) {
                var error = $root.ClientHello.C2S.CompanionRegData.verify(message.regData);
                if (error)
                    return "regData." + error;
            }
            if (message.tag23 != null && message.hasOwnProperty("tag23"))
                if (!$util.isInteger(message.tag23))
                    return "tag23: integer expected";
            if (message.tag24 != null && message.hasOwnProperty("tag24"))
                if (!$util.isInteger(message.tag24))
                    return "tag24: integer expected";
            if (message.iosAppExtension != null && message.hasOwnProperty("iosAppExtension"))
                switch (message.iosAppExtension) {
                default:
                    return "iosAppExtension: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a C2S message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ClientHello.C2S
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ClientHello.C2S} C2S
         */
        C2S.fromObject = function fromObject(object) {
            if (object instanceof $root.ClientHello.C2S)
                return object;
            var message = new $root.ClientHello.C2S();
            if (object.username != null)
                if ($util.Long)
                    (message.username = $util.Long.fromValue(object.username)).unsigned = true;
                else if (typeof object.username === "string")
                    message.username = parseInt(object.username, 10);
                else if (typeof object.username === "number")
                    message.username = object.username;
                else if (typeof object.username === "object")
                    message.username = new $util.LongBits(object.username.low >>> 0, object.username.high >>> 0).toNumber(true);
            if (object.passive != null)
                message.passive = Boolean(object.passive);
            if (object.clientFeatures) {
                if (!Array.isArray(object.clientFeatures))
                    throw TypeError(".ClientHello.C2S.clientFeatures: array expected");
                message.clientFeatures = [];
                for (var i = 0; i < object.clientFeatures.length; ++i)
                    switch (object.clientFeatures[i]) {
                    default:
                    case "NONE":
                    case 0:
                        message.clientFeatures[i] = 0;
                        break;
                    }
            }
            if (object.useragent != null) {
                if (typeof object.useragent !== "object")
                    throw TypeError(".ClientHello.C2S.useragent: object expected");
                message.useragent = $root.ClientHello.UserAgent.fromObject(object.useragent);
            }
            if (object.webInfo != null) {
                if (typeof object.webInfo !== "object")
                    throw TypeError(".ClientHello.C2S.webInfo: object expected");
                message.webInfo = $root.ClientHello.C2S.WebInfo.fromObject(object.webInfo);
            }
            if (object.pushName != null)
                message.pushName = String(object.pushName);
            if (object.sessionId != null)
                message.sessionId = object.sessionId | 0;
            if (object.shortConnect != null)
                message.shortConnect = Boolean(object.shortConnect);
            switch (object.connectType) {
            case "UNKNOWN":
            case 0:
                message.connectType = 0;
                break;
            case "WIFI":
            case 1:
                message.connectType = 1;
                break;
            case "EDGE":
            case 100:
                message.connectType = 100;
                break;
            case "IDEN":
            case 101:
                message.connectType = 101;
                break;
            case "UMTS":
            case 102:
                message.connectType = 102;
                break;
            case "EVDO":
            case 103:
                message.connectType = 103;
                break;
            case "GPRS":
            case 104:
                message.connectType = 104;
                break;
            case "HSDPA":
            case 105:
                message.connectType = 105;
                break;
            case "HSUPA":
            case 106:
                message.connectType = 106;
                break;
            case "HSPA":
            case 107:
                message.connectType = 107;
                break;
            case "CDMA":
            case 108:
                message.connectType = 108;
                break;
            case "ONExRTT":
            case 109:
                message.connectType = 109;
                break;
            case "EHRPD":
            case 110:
                message.connectType = 110;
                break;
            case "LTE":
            case 111:
                message.connectType = 111;
                break;
            case "HSPAP":
            case 112:
                message.connectType = 112;
                break;
            }
            switch (object.connectReason) {
            case "PUSH":
            case 0:
                message.connectReason = 0;
                break;
            case "USER_ACTIVATED":
            case 1:
                message.connectReason = 1;
                break;
            case "SCHEDULED":
            case 2:
                message.connectReason = 2;
                break;
            case "ERROR_RECONNECT":
            case 3:
                message.connectReason = 3;
                break;
            case "NETWORK_SWITCH":
            case 4:
                message.connectReason = 4;
                break;
            case "PING_RECONNECT":
            case 5:
                message.connectReason = 5;
                break;
            }
            if (object.shards) {
                if (!Array.isArray(object.shards))
                    throw TypeError(".ClientHello.C2S.shards: array expected");
                message.shards = [];
                for (var i = 0; i < object.shards.length; ++i)
                    message.shards[i] = object.shards[i] | 0;
            }
            if (object.dnsSource != null) {
                if (typeof object.dnsSource !== "object")
                    throw TypeError(".ClientHello.C2S.dnsSource: object expected");
                message.dnsSource = $root.ClientHello.C2S.DnsSource.fromObject(object.dnsSource);
            }
            if (object.connectAttemptCount != null)
                message.connectAttemptCount = object.connectAttemptCount >>> 0;
            if (object.regData != null) {
                if (typeof object.regData !== "object")
                    throw TypeError(".ClientHello.C2S.regData: object expected");
                message.regData = $root.ClientHello.C2S.CompanionRegData.fromObject(object.regData);
            }
            if (object.tag23 != null)
                message.tag23 = object.tag23 >>> 0;
            if (object.tag24 != null)
                message.tag24 = object.tag24 >>> 0;
            switch (object.iosAppExtension) {
            case "EXT_0":
            case 0:
                message.iosAppExtension = 0;
                break;
            case "EXT_1":
            case 1:
                message.iosAppExtension = 1;
                break;
            case "EXT_2":
            case 2:
                message.iosAppExtension = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a C2S message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ClientHello.C2S
         * @static
         * @param {ClientHello.C2S} message C2S
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2S.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.clientFeatures = [];
                object.shards = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.username = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.username = options.longs === String ? "0" : 0;
                object.passive = false;
                object.useragent = null;
                object.webInfo = null;
                object.pushName = "";
                object.sessionId = 0;
                object.shortConnect = false;
                object.connectType = options.enums === String ? "UNKNOWN" : 0;
                object.connectReason = options.enums === String ? "PUSH" : 0;
                object.dnsSource = null;
                object.connectAttemptCount = 0;
                object.regData = null;
                object.tag23 = 0;
                object.tag24 = 0;
                object.iosAppExtension = options.enums === String ? "EXT_0" : 0;
            }
            if (message.username != null && message.hasOwnProperty("username"))
                if (typeof message.username === "number")
                    object.username = options.longs === String ? String(message.username) : message.username;
                else
                    object.username = options.longs === String ? $util.Long.prototype.toString.call(message.username) : options.longs === Number ? new $util.LongBits(message.username.low >>> 0, message.username.high >>> 0).toNumber(true) : message.username;
            if (message.passive != null && message.hasOwnProperty("passive"))
                object.passive = message.passive;
            if (message.clientFeatures && message.clientFeatures.length) {
                object.clientFeatures = [];
                for (var j = 0; j < message.clientFeatures.length; ++j)
                    object.clientFeatures[j] = options.enums === String ? $root.ClientHello.C2S.ClientFeature[message.clientFeatures[j]] : message.clientFeatures[j];
            }
            if (message.useragent != null && message.hasOwnProperty("useragent"))
                object.useragent = $root.ClientHello.UserAgent.toObject(message.useragent, options);
            if (message.webInfo != null && message.hasOwnProperty("webInfo"))
                object.webInfo = $root.ClientHello.C2S.WebInfo.toObject(message.webInfo, options);
            if (message.pushName != null && message.hasOwnProperty("pushName"))
                object.pushName = message.pushName;
            if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                object.sessionId = message.sessionId;
            if (message.shortConnect != null && message.hasOwnProperty("shortConnect"))
                object.shortConnect = message.shortConnect;
            if (message.connectType != null && message.hasOwnProperty("connectType"))
                object.connectType = options.enums === String ? $root.ClientHello.C2S.ConnectType[message.connectType] : message.connectType;
            if (message.connectReason != null && message.hasOwnProperty("connectReason"))
                object.connectReason = options.enums === String ? $root.ClientHello.C2S.ConnectReason[message.connectReason] : message.connectReason;
            if (message.shards && message.shards.length) {
                object.shards = [];
                for (var j = 0; j < message.shards.length; ++j)
                    object.shards[j] = message.shards[j];
            }
            if (message.dnsSource != null && message.hasOwnProperty("dnsSource"))
                object.dnsSource = $root.ClientHello.C2S.DnsSource.toObject(message.dnsSource, options);
            if (message.connectAttemptCount != null && message.hasOwnProperty("connectAttemptCount"))
                object.connectAttemptCount = message.connectAttemptCount;
            if (message.regData != null && message.hasOwnProperty("regData"))
                object.regData = $root.ClientHello.C2S.CompanionRegData.toObject(message.regData, options);
            if (message.tag23 != null && message.hasOwnProperty("tag23"))
                object.tag23 = message.tag23;
            if (message.tag24 != null && message.hasOwnProperty("tag24"))
                object.tag24 = message.tag24;
            if (message.iosAppExtension != null && message.hasOwnProperty("iosAppExtension"))
                object.iosAppExtension = options.enums === String ? $root.ClientHello.C2S.IosAppExtension[message.iosAppExtension] : message.iosAppExtension;
            return object;
        };

        /**
         * Converts this C2S to JSON.
         * @function toJSON
         * @memberof ClientHello.C2S
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2S.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ClientFeature enum.
         * @name ClientHello.C2S.ClientFeature
         * @enum {number}
         * @property {number} NONE=0 NONE value
         */
        C2S.ClientFeature = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NONE"] = 0;
            return values;
        })();

        /**
         * ConnectType enum.
         * @name ClientHello.C2S.ConnectType
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} WIFI=1 WIFI value
         * @property {number} EDGE=100 EDGE value
         * @property {number} IDEN=101 IDEN value
         * @property {number} UMTS=102 UMTS value
         * @property {number} EVDO=103 EVDO value
         * @property {number} GPRS=104 GPRS value
         * @property {number} HSDPA=105 HSDPA value
         * @property {number} HSUPA=106 HSUPA value
         * @property {number} HSPA=107 HSPA value
         * @property {number} CDMA=108 CDMA value
         * @property {number} ONExRTT=109 ONExRTT value
         * @property {number} EHRPD=110 EHRPD value
         * @property {number} LTE=111 LTE value
         * @property {number} HSPAP=112 HSPAP value
         */
        C2S.ConnectType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "WIFI"] = 1;
            values[valuesById[100] = "EDGE"] = 100;
            values[valuesById[101] = "IDEN"] = 101;
            values[valuesById[102] = "UMTS"] = 102;
            values[valuesById[103] = "EVDO"] = 103;
            values[valuesById[104] = "GPRS"] = 104;
            values[valuesById[105] = "HSDPA"] = 105;
            values[valuesById[106] = "HSUPA"] = 106;
            values[valuesById[107] = "HSPA"] = 107;
            values[valuesById[108] = "CDMA"] = 108;
            values[valuesById[109] = "ONExRTT"] = 109;
            values[valuesById[110] = "EHRPD"] = 110;
            values[valuesById[111] = "LTE"] = 111;
            values[valuesById[112] = "HSPAP"] = 112;
            return values;
        })();

        /**
         * ConnectReason enum.
         * @name ClientHello.C2S.ConnectReason
         * @enum {number}
         * @property {number} PUSH=0 PUSH value
         * @property {number} USER_ACTIVATED=1 USER_ACTIVATED value
         * @property {number} SCHEDULED=2 SCHEDULED value
         * @property {number} ERROR_RECONNECT=3 ERROR_RECONNECT value
         * @property {number} NETWORK_SWITCH=4 NETWORK_SWITCH value
         * @property {number} PING_RECONNECT=5 PING_RECONNECT value
         */
        C2S.ConnectReason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PUSH"] = 0;
            values[valuesById[1] = "USER_ACTIVATED"] = 1;
            values[valuesById[2] = "SCHEDULED"] = 2;
            values[valuesById[3] = "ERROR_RECONNECT"] = 3;
            values[valuesById[4] = "NETWORK_SWITCH"] = 4;
            values[valuesById[5] = "PING_RECONNECT"] = 5;
            return values;
        })();

        C2S.DnsSource = (function() {

            /**
             * Properties of a DnsSource.
             * @memberof ClientHello.C2S
             * @interface IDnsSource
             * @property {ClientHello.C2S.DnsSource.DnsMethod|null} [dnsMethod] DnsSource dnsMethod
             * @property {boolean|null} [appCached] DnsSource appCached
             */

            /**
             * Constructs a new DnsSource.
             * @memberof ClientHello.C2S
             * @classdesc Represents a DnsSource.
             * @implements IDnsSource
             * @constructor
             * @param {ClientHello.C2S.IDnsSource=} [properties] Properties to set
             */
            function DnsSource(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DnsSource dnsMethod.
             * @member {ClientHello.C2S.DnsSource.DnsMethod} dnsMethod
             * @memberof ClientHello.C2S.DnsSource
             * @instance
             */
            DnsSource.prototype.dnsMethod = 0;

            /**
             * DnsSource appCached.
             * @member {boolean} appCached
             * @memberof ClientHello.C2S.DnsSource
             * @instance
             */
            DnsSource.prototype.appCached = false;

            /**
             * Creates a new DnsSource instance using the specified properties.
             * @function create
             * @memberof ClientHello.C2S.DnsSource
             * @static
             * @param {ClientHello.C2S.IDnsSource=} [properties] Properties to set
             * @returns {ClientHello.C2S.DnsSource} DnsSource instance
             */
            DnsSource.create = function create(properties) {
                return new DnsSource(properties);
            };

            /**
             * Encodes the specified DnsSource message. Does not implicitly {@link ClientHello.C2S.DnsSource.verify|verify} messages.
             * @function encode
             * @memberof ClientHello.C2S.DnsSource
             * @static
             * @param {ClientHello.C2S.IDnsSource} message DnsSource message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DnsSource.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dnsMethod != null && Object.hasOwnProperty.call(message, "dnsMethod"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.dnsMethod);
                if (message.appCached != null && Object.hasOwnProperty.call(message, "appCached"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.appCached);
                return writer;
            };

            /**
             * Encodes the specified DnsSource message, length delimited. Does not implicitly {@link ClientHello.C2S.DnsSource.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ClientHello.C2S.DnsSource
             * @static
             * @param {ClientHello.C2S.IDnsSource} message DnsSource message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DnsSource.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DnsSource message from the specified reader or buffer.
             * @function decode
             * @memberof ClientHello.C2S.DnsSource
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ClientHello.C2S.DnsSource} DnsSource
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DnsSource.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClientHello.C2S.DnsSource();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 15:
                        message.dnsMethod = reader.int32();
                        break;
                    case 16:
                        message.appCached = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DnsSource message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ClientHello.C2S.DnsSource
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ClientHello.C2S.DnsSource} DnsSource
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DnsSource.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DnsSource message.
             * @function verify
             * @memberof ClientHello.C2S.DnsSource
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DnsSource.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dnsMethod != null && message.hasOwnProperty("dnsMethod"))
                    switch (message.dnsMethod) {
                    default:
                        return "dnsMethod: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.appCached != null && message.hasOwnProperty("appCached"))
                    if (typeof message.appCached !== "boolean")
                        return "appCached: boolean expected";
                return null;
            };

            /**
             * Creates a DnsSource message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ClientHello.C2S.DnsSource
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ClientHello.C2S.DnsSource} DnsSource
             */
            DnsSource.fromObject = function fromObject(object) {
                if (object instanceof $root.ClientHello.C2S.DnsSource)
                    return object;
                var message = new $root.ClientHello.C2S.DnsSource();
                switch (object.dnsMethod) {
                case "METHOD_0":
                case 0:
                    message.dnsMethod = 0;
                    break;
                case "METHOD_1":
                case 1:
                    message.dnsMethod = 1;
                    break;
                case "METHOD_2":
                case 2:
                    message.dnsMethod = 2;
                    break;
                case "METHOD_3":
                case 3:
                    message.dnsMethod = 3;
                    break;
                }
                if (object.appCached != null)
                    message.appCached = Boolean(object.appCached);
                return message;
            };

            /**
             * Creates a plain object from a DnsSource message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ClientHello.C2S.DnsSource
             * @static
             * @param {ClientHello.C2S.DnsSource} message DnsSource
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DnsSource.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.dnsMethod = options.enums === String ? "METHOD_0" : 0;
                    object.appCached = false;
                }
                if (message.dnsMethod != null && message.hasOwnProperty("dnsMethod"))
                    object.dnsMethod = options.enums === String ? $root.ClientHello.C2S.DnsSource.DnsMethod[message.dnsMethod] : message.dnsMethod;
                if (message.appCached != null && message.hasOwnProperty("appCached"))
                    object.appCached = message.appCached;
                return object;
            };

            /**
             * Converts this DnsSource to JSON.
             * @function toJSON
             * @memberof ClientHello.C2S.DnsSource
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DnsSource.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * DnsMethod enum.
             * @name ClientHello.C2S.DnsSource.DnsMethod
             * @enum {number}
             * @property {number} METHOD_0=0 METHOD_0 value
             * @property {number} METHOD_1=1 METHOD_1 value
             * @property {number} METHOD_2=2 METHOD_2 value
             * @property {number} METHOD_3=3 METHOD_3 value
             */
            DnsSource.DnsMethod = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "METHOD_0"] = 0;
                values[valuesById[1] = "METHOD_1"] = 1;
                values[valuesById[2] = "METHOD_2"] = 2;
                values[valuesById[3] = "METHOD_3"] = 3;
                return values;
            })();

            return DnsSource;
        })();

        /**
         * IosAppExtension enum.
         * @name ClientHello.C2S.IosAppExtension
         * @enum {number}
         * @property {number} EXT_0=0 EXT_0 value
         * @property {number} EXT_1=1 EXT_1 value
         * @property {number} EXT_2=2 EXT_2 value
         */
        C2S.IosAppExtension = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "EXT_0"] = 0;
            values[valuesById[1] = "EXT_1"] = 1;
            values[valuesById[2] = "EXT_2"] = 2;
            return values;
        })();

        C2S.WebInfo = (function() {

            /**
             * Properties of a WebInfo.
             * @memberof ClientHello.C2S
             * @interface IWebInfo
             * @property {string|null} [refToken] WebInfo refToken
             * @property {string|null} [version] WebInfo version
             * @property {ClientHello.C2S.WebInfo.IWebdPayload|null} [webdPayload] WebInfo webdPayload
             */

            /**
             * Constructs a new WebInfo.
             * @memberof ClientHello.C2S
             * @classdesc Represents a WebInfo.
             * @implements IWebInfo
             * @constructor
             * @param {ClientHello.C2S.IWebInfo=} [properties] Properties to set
             */
            function WebInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WebInfo refToken.
             * @member {string} refToken
             * @memberof ClientHello.C2S.WebInfo
             * @instance
             */
            WebInfo.prototype.refToken = "";

            /**
             * WebInfo version.
             * @member {string} version
             * @memberof ClientHello.C2S.WebInfo
             * @instance
             */
            WebInfo.prototype.version = "";

            /**
             * WebInfo webdPayload.
             * @member {ClientHello.C2S.WebInfo.IWebdPayload|null|undefined} webdPayload
             * @memberof ClientHello.C2S.WebInfo
             * @instance
             */
            WebInfo.prototype.webdPayload = null;

            /**
             * Creates a new WebInfo instance using the specified properties.
             * @function create
             * @memberof ClientHello.C2S.WebInfo
             * @static
             * @param {ClientHello.C2S.IWebInfo=} [properties] Properties to set
             * @returns {ClientHello.C2S.WebInfo} WebInfo instance
             */
            WebInfo.create = function create(properties) {
                return new WebInfo(properties);
            };

            /**
             * Encodes the specified WebInfo message. Does not implicitly {@link ClientHello.C2S.WebInfo.verify|verify} messages.
             * @function encode
             * @memberof ClientHello.C2S.WebInfo
             * @static
             * @param {ClientHello.C2S.IWebInfo} message WebInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WebInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.refToken != null && Object.hasOwnProperty.call(message, "refToken"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.refToken);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                if (message.webdPayload != null && Object.hasOwnProperty.call(message, "webdPayload"))
                    $root.ClientHello.C2S.WebInfo.WebdPayload.encode(message.webdPayload, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WebInfo message, length delimited. Does not implicitly {@link ClientHello.C2S.WebInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ClientHello.C2S.WebInfo
             * @static
             * @param {ClientHello.C2S.IWebInfo} message WebInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WebInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WebInfo message from the specified reader or buffer.
             * @function decode
             * @memberof ClientHello.C2S.WebInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ClientHello.C2S.WebInfo} WebInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WebInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClientHello.C2S.WebInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.refToken = reader.string();
                        break;
                    case 2:
                        message.version = reader.string();
                        break;
                    case 3:
                        message.webdPayload = $root.ClientHello.C2S.WebInfo.WebdPayload.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WebInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ClientHello.C2S.WebInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ClientHello.C2S.WebInfo} WebInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WebInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WebInfo message.
             * @function verify
             * @memberof ClientHello.C2S.WebInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WebInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.refToken != null && message.hasOwnProperty("refToken"))
                    if (!$util.isString(message.refToken))
                        return "refToken: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.webdPayload != null && message.hasOwnProperty("webdPayload")) {
                    var error = $root.ClientHello.C2S.WebInfo.WebdPayload.verify(message.webdPayload);
                    if (error)
                        return "webdPayload." + error;
                }
                return null;
            };

            /**
             * Creates a WebInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ClientHello.C2S.WebInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ClientHello.C2S.WebInfo} WebInfo
             */
            WebInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.ClientHello.C2S.WebInfo)
                    return object;
                var message = new $root.ClientHello.C2S.WebInfo();
                if (object.refToken != null)
                    message.refToken = String(object.refToken);
                if (object.version != null)
                    message.version = String(object.version);
                if (object.webdPayload != null) {
                    if (typeof object.webdPayload !== "object")
                        throw TypeError(".ClientHello.C2S.WebInfo.webdPayload: object expected");
                    message.webdPayload = $root.ClientHello.C2S.WebInfo.WebdPayload.fromObject(object.webdPayload);
                }
                return message;
            };

            /**
             * Creates a plain object from a WebInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ClientHello.C2S.WebInfo
             * @static
             * @param {ClientHello.C2S.WebInfo} message WebInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WebInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.refToken = "";
                    object.version = "";
                    object.webdPayload = null;
                }
                if (message.refToken != null && message.hasOwnProperty("refToken"))
                    object.refToken = message.refToken;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.webdPayload != null && message.hasOwnProperty("webdPayload"))
                    object.webdPayload = $root.ClientHello.C2S.WebInfo.WebdPayload.toObject(message.webdPayload, options);
                return object;
            };

            /**
             * Converts this WebInfo to JSON.
             * @function toJSON
             * @memberof ClientHello.C2S.WebInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WebInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            WebInfo.WebdPayload = (function() {

                /**
                 * Properties of a WebdPayload.
                 * @memberof ClientHello.C2S.WebInfo
                 * @interface IWebdPayload
                 * @property {boolean|null} [usesParticipantInKey] WebdPayload usesParticipantInKey
                 * @property {boolean|null} [supportsStarredMessages] WebdPayload supportsStarredMessages
                 * @property {boolean|null} [supportsDocumentMessages] WebdPayload supportsDocumentMessages
                 * @property {boolean|null} [supportsUrlMessages] WebdPayload supportsUrlMessages
                 * @property {boolean|null} [supportsMediaRetry] WebdPayload supportsMediaRetry
                 * @property {boolean|null} [supportsE2eImage] WebdPayload supportsE2eImage
                 * @property {boolean|null} [supportsE2eVideo] WebdPayload supportsE2eVideo
                 * @property {boolean|null} [supportsE2eAudio] WebdPayload supportsE2eAudio
                 * @property {boolean|null} [supportsE2eDocument] WebdPayload supportsE2eDocument
                 * @property {string|null} [documentTypes] WebdPayload documentTypes
                 */

                /**
                 * Constructs a new WebdPayload.
                 * @memberof ClientHello.C2S.WebInfo
                 * @classdesc Represents a WebdPayload.
                 * @implements IWebdPayload
                 * @constructor
                 * @param {ClientHello.C2S.WebInfo.IWebdPayload=} [properties] Properties to set
                 */
                function WebdPayload(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * WebdPayload usesParticipantInKey.
                 * @member {boolean} usesParticipantInKey
                 * @memberof ClientHello.C2S.WebInfo.WebdPayload
                 * @instance
                 */
                WebdPayload.prototype.usesParticipantInKey = false;

                /**
                 * WebdPayload supportsStarredMessages.
                 * @member {boolean} supportsStarredMessages
                 * @memberof ClientHello.C2S.WebInfo.WebdPayload
                 * @instance
                 */
                WebdPayload.prototype.supportsStarredMessages = false;

                /**
                 * WebdPayload supportsDocumentMessages.
                 * @member {boolean} supportsDocumentMessages
                 * @memberof ClientHello.C2S.WebInfo.WebdPayload
                 * @instance
                 */
                WebdPayload.prototype.supportsDocumentMessages = false;

                /**
                 * WebdPayload supportsUrlMessages.
                 * @member {boolean} supportsUrlMessages
                 * @memberof ClientHello.C2S.WebInfo.WebdPayload
                 * @instance
                 */
                WebdPayload.prototype.supportsUrlMessages = false;

                /**
                 * WebdPayload supportsMediaRetry.
                 * @member {boolean} supportsMediaRetry
                 * @memberof ClientHello.C2S.WebInfo.WebdPayload
                 * @instance
                 */
                WebdPayload.prototype.supportsMediaRetry = false;

                /**
                 * WebdPayload supportsE2eImage.
                 * @member {boolean} supportsE2eImage
                 * @memberof ClientHello.C2S.WebInfo.WebdPayload
                 * @instance
                 */
                WebdPayload.prototype.supportsE2eImage = false;

                /**
                 * WebdPayload supportsE2eVideo.
                 * @member {boolean} supportsE2eVideo
                 * @memberof ClientHello.C2S.WebInfo.WebdPayload
                 * @instance
                 */
                WebdPayload.prototype.supportsE2eVideo = false;

                /**
                 * WebdPayload supportsE2eAudio.
                 * @member {boolean} supportsE2eAudio
                 * @memberof ClientHello.C2S.WebInfo.WebdPayload
                 * @instance
                 */
                WebdPayload.prototype.supportsE2eAudio = false;

                /**
                 * WebdPayload supportsE2eDocument.
                 * @member {boolean} supportsE2eDocument
                 * @memberof ClientHello.C2S.WebInfo.WebdPayload
                 * @instance
                 */
                WebdPayload.prototype.supportsE2eDocument = false;

                /**
                 * WebdPayload documentTypes.
                 * @member {string} documentTypes
                 * @memberof ClientHello.C2S.WebInfo.WebdPayload
                 * @instance
                 */
                WebdPayload.prototype.documentTypes = "";

                /**
                 * Creates a new WebdPayload instance using the specified properties.
                 * @function create
                 * @memberof ClientHello.C2S.WebInfo.WebdPayload
                 * @static
                 * @param {ClientHello.C2S.WebInfo.IWebdPayload=} [properties] Properties to set
                 * @returns {ClientHello.C2S.WebInfo.WebdPayload} WebdPayload instance
                 */
                WebdPayload.create = function create(properties) {
                    return new WebdPayload(properties);
                };

                /**
                 * Encodes the specified WebdPayload message. Does not implicitly {@link ClientHello.C2S.WebInfo.WebdPayload.verify|verify} messages.
                 * @function encode
                 * @memberof ClientHello.C2S.WebInfo.WebdPayload
                 * @static
                 * @param {ClientHello.C2S.WebInfo.IWebdPayload} message WebdPayload message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WebdPayload.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.usesParticipantInKey != null && Object.hasOwnProperty.call(message, "usesParticipantInKey"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.usesParticipantInKey);
                    if (message.supportsStarredMessages != null && Object.hasOwnProperty.call(message, "supportsStarredMessages"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.supportsStarredMessages);
                    if (message.supportsDocumentMessages != null && Object.hasOwnProperty.call(message, "supportsDocumentMessages"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.supportsDocumentMessages);
                    if (message.supportsUrlMessages != null && Object.hasOwnProperty.call(message, "supportsUrlMessages"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.supportsUrlMessages);
                    if (message.supportsMediaRetry != null && Object.hasOwnProperty.call(message, "supportsMediaRetry"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.supportsMediaRetry);
                    if (message.supportsE2eImage != null && Object.hasOwnProperty.call(message, "supportsE2eImage"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.supportsE2eImage);
                    if (message.supportsE2eVideo != null && Object.hasOwnProperty.call(message, "supportsE2eVideo"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.supportsE2eVideo);
                    if (message.supportsE2eAudio != null && Object.hasOwnProperty.call(message, "supportsE2eAudio"))
                        writer.uint32(/* id 8, wireType 0 =*/64).bool(message.supportsE2eAudio);
                    if (message.supportsE2eDocument != null && Object.hasOwnProperty.call(message, "supportsE2eDocument"))
                        writer.uint32(/* id 9, wireType 0 =*/72).bool(message.supportsE2eDocument);
                    if (message.documentTypes != null && Object.hasOwnProperty.call(message, "documentTypes"))
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.documentTypes);
                    return writer;
                };

                /**
                 * Encodes the specified WebdPayload message, length delimited. Does not implicitly {@link ClientHello.C2S.WebInfo.WebdPayload.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof ClientHello.C2S.WebInfo.WebdPayload
                 * @static
                 * @param {ClientHello.C2S.WebInfo.IWebdPayload} message WebdPayload message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WebdPayload.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a WebdPayload message from the specified reader or buffer.
                 * @function decode
                 * @memberof ClientHello.C2S.WebInfo.WebdPayload
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {ClientHello.C2S.WebInfo.WebdPayload} WebdPayload
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WebdPayload.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClientHello.C2S.WebInfo.WebdPayload();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.usesParticipantInKey = reader.bool();
                            break;
                        case 2:
                            message.supportsStarredMessages = reader.bool();
                            break;
                        case 3:
                            message.supportsDocumentMessages = reader.bool();
                            break;
                        case 4:
                            message.supportsUrlMessages = reader.bool();
                            break;
                        case 5:
                            message.supportsMediaRetry = reader.bool();
                            break;
                        case 6:
                            message.supportsE2eImage = reader.bool();
                            break;
                        case 7:
                            message.supportsE2eVideo = reader.bool();
                            break;
                        case 8:
                            message.supportsE2eAudio = reader.bool();
                            break;
                        case 9:
                            message.supportsE2eDocument = reader.bool();
                            break;
                        case 10:
                            message.documentTypes = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a WebdPayload message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof ClientHello.C2S.WebInfo.WebdPayload
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {ClientHello.C2S.WebInfo.WebdPayload} WebdPayload
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WebdPayload.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a WebdPayload message.
                 * @function verify
                 * @memberof ClientHello.C2S.WebInfo.WebdPayload
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WebdPayload.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.usesParticipantInKey != null && message.hasOwnProperty("usesParticipantInKey"))
                        if (typeof message.usesParticipantInKey !== "boolean")
                            return "usesParticipantInKey: boolean expected";
                    if (message.supportsStarredMessages != null && message.hasOwnProperty("supportsStarredMessages"))
                        if (typeof message.supportsStarredMessages !== "boolean")
                            return "supportsStarredMessages: boolean expected";
                    if (message.supportsDocumentMessages != null && message.hasOwnProperty("supportsDocumentMessages"))
                        if (typeof message.supportsDocumentMessages !== "boolean")
                            return "supportsDocumentMessages: boolean expected";
                    if (message.supportsUrlMessages != null && message.hasOwnProperty("supportsUrlMessages"))
                        if (typeof message.supportsUrlMessages !== "boolean")
                            return "supportsUrlMessages: boolean expected";
                    if (message.supportsMediaRetry != null && message.hasOwnProperty("supportsMediaRetry"))
                        if (typeof message.supportsMediaRetry !== "boolean")
                            return "supportsMediaRetry: boolean expected";
                    if (message.supportsE2eImage != null && message.hasOwnProperty("supportsE2eImage"))
                        if (typeof message.supportsE2eImage !== "boolean")
                            return "supportsE2eImage: boolean expected";
                    if (message.supportsE2eVideo != null && message.hasOwnProperty("supportsE2eVideo"))
                        if (typeof message.supportsE2eVideo !== "boolean")
                            return "supportsE2eVideo: boolean expected";
                    if (message.supportsE2eAudio != null && message.hasOwnProperty("supportsE2eAudio"))
                        if (typeof message.supportsE2eAudio !== "boolean")
                            return "supportsE2eAudio: boolean expected";
                    if (message.supportsE2eDocument != null && message.hasOwnProperty("supportsE2eDocument"))
                        if (typeof message.supportsE2eDocument !== "boolean")
                            return "supportsE2eDocument: boolean expected";
                    if (message.documentTypes != null && message.hasOwnProperty("documentTypes"))
                        if (!$util.isString(message.documentTypes))
                            return "documentTypes: string expected";
                    return null;
                };

                /**
                 * Creates a WebdPayload message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof ClientHello.C2S.WebInfo.WebdPayload
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {ClientHello.C2S.WebInfo.WebdPayload} WebdPayload
                 */
                WebdPayload.fromObject = function fromObject(object) {
                    if (object instanceof $root.ClientHello.C2S.WebInfo.WebdPayload)
                        return object;
                    var message = new $root.ClientHello.C2S.WebInfo.WebdPayload();
                    if (object.usesParticipantInKey != null)
                        message.usesParticipantInKey = Boolean(object.usesParticipantInKey);
                    if (object.supportsStarredMessages != null)
                        message.supportsStarredMessages = Boolean(object.supportsStarredMessages);
                    if (object.supportsDocumentMessages != null)
                        message.supportsDocumentMessages = Boolean(object.supportsDocumentMessages);
                    if (object.supportsUrlMessages != null)
                        message.supportsUrlMessages = Boolean(object.supportsUrlMessages);
                    if (object.supportsMediaRetry != null)
                        message.supportsMediaRetry = Boolean(object.supportsMediaRetry);
                    if (object.supportsE2eImage != null)
                        message.supportsE2eImage = Boolean(object.supportsE2eImage);
                    if (object.supportsE2eVideo != null)
                        message.supportsE2eVideo = Boolean(object.supportsE2eVideo);
                    if (object.supportsE2eAudio != null)
                        message.supportsE2eAudio = Boolean(object.supportsE2eAudio);
                    if (object.supportsE2eDocument != null)
                        message.supportsE2eDocument = Boolean(object.supportsE2eDocument);
                    if (object.documentTypes != null)
                        message.documentTypes = String(object.documentTypes);
                    return message;
                };

                /**
                 * Creates a plain object from a WebdPayload message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof ClientHello.C2S.WebInfo.WebdPayload
                 * @static
                 * @param {ClientHello.C2S.WebInfo.WebdPayload} message WebdPayload
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                WebdPayload.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.usesParticipantInKey = false;
                        object.supportsStarredMessages = false;
                        object.supportsDocumentMessages = false;
                        object.supportsUrlMessages = false;
                        object.supportsMediaRetry = false;
                        object.supportsE2eImage = false;
                        object.supportsE2eVideo = false;
                        object.supportsE2eAudio = false;
                        object.supportsE2eDocument = false;
                        object.documentTypes = "";
                    }
                    if (message.usesParticipantInKey != null && message.hasOwnProperty("usesParticipantInKey"))
                        object.usesParticipantInKey = message.usesParticipantInKey;
                    if (message.supportsStarredMessages != null && message.hasOwnProperty("supportsStarredMessages"))
                        object.supportsStarredMessages = message.supportsStarredMessages;
                    if (message.supportsDocumentMessages != null && message.hasOwnProperty("supportsDocumentMessages"))
                        object.supportsDocumentMessages = message.supportsDocumentMessages;
                    if (message.supportsUrlMessages != null && message.hasOwnProperty("supportsUrlMessages"))
                        object.supportsUrlMessages = message.supportsUrlMessages;
                    if (message.supportsMediaRetry != null && message.hasOwnProperty("supportsMediaRetry"))
                        object.supportsMediaRetry = message.supportsMediaRetry;
                    if (message.supportsE2eImage != null && message.hasOwnProperty("supportsE2eImage"))
                        object.supportsE2eImage = message.supportsE2eImage;
                    if (message.supportsE2eVideo != null && message.hasOwnProperty("supportsE2eVideo"))
                        object.supportsE2eVideo = message.supportsE2eVideo;
                    if (message.supportsE2eAudio != null && message.hasOwnProperty("supportsE2eAudio"))
                        object.supportsE2eAudio = message.supportsE2eAudio;
                    if (message.supportsE2eDocument != null && message.hasOwnProperty("supportsE2eDocument"))
                        object.supportsE2eDocument = message.supportsE2eDocument;
                    if (message.documentTypes != null && message.hasOwnProperty("documentTypes"))
                        object.documentTypes = message.documentTypes;
                    return object;
                };

                /**
                 * Converts this WebdPayload to JSON.
                 * @function toJSON
                 * @memberof ClientHello.C2S.WebInfo.WebdPayload
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                WebdPayload.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return WebdPayload;
            })();

            return WebInfo;
        })();

        C2S.CompanionRegData = (function() {

            /**
             * Properties of a CompanionRegData.
             * @memberof ClientHello.C2S
             * @interface ICompanionRegData
             * @property {Uint8Array|null} [eRegid] CompanionRegData eRegid
             * @property {Uint8Array|null} [eKeytype] CompanionRegData eKeytype
             * @property {Uint8Array|null} [eIdent] CompanionRegData eIdent
             * @property {Uint8Array|null} [eSkeyId] CompanionRegData eSkeyId
             * @property {Uint8Array|null} [eSkeyVal] CompanionRegData eSkeyVal
             * @property {Uint8Array|null} [eSkeySig] CompanionRegData eSkeySig
             * @property {Uint8Array|null} [buildHash] CompanionRegData buildHash
             * @property {Uint8Array|null} [companionProps] CompanionRegData companionProps
             */

            /**
             * Constructs a new CompanionRegData.
             * @memberof ClientHello.C2S
             * @classdesc Represents a CompanionRegData.
             * @implements ICompanionRegData
             * @constructor
             * @param {ClientHello.C2S.ICompanionRegData=} [properties] Properties to set
             */
            function CompanionRegData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CompanionRegData eRegid.
             * @member {Uint8Array} eRegid
             * @memberof ClientHello.C2S.CompanionRegData
             * @instance
             */
            CompanionRegData.prototype.eRegid = $util.newBuffer([]);

            /**
             * CompanionRegData eKeytype.
             * @member {Uint8Array} eKeytype
             * @memberof ClientHello.C2S.CompanionRegData
             * @instance
             */
            CompanionRegData.prototype.eKeytype = $util.newBuffer([]);

            /**
             * CompanionRegData eIdent.
             * @member {Uint8Array} eIdent
             * @memberof ClientHello.C2S.CompanionRegData
             * @instance
             */
            CompanionRegData.prototype.eIdent = $util.newBuffer([]);

            /**
             * CompanionRegData eSkeyId.
             * @member {Uint8Array} eSkeyId
             * @memberof ClientHello.C2S.CompanionRegData
             * @instance
             */
            CompanionRegData.prototype.eSkeyId = $util.newBuffer([]);

            /**
             * CompanionRegData eSkeyVal.
             * @member {Uint8Array} eSkeyVal
             * @memberof ClientHello.C2S.CompanionRegData
             * @instance
             */
            CompanionRegData.prototype.eSkeyVal = $util.newBuffer([]);

            /**
             * CompanionRegData eSkeySig.
             * @member {Uint8Array} eSkeySig
             * @memberof ClientHello.C2S.CompanionRegData
             * @instance
             */
            CompanionRegData.prototype.eSkeySig = $util.newBuffer([]);

            /**
             * CompanionRegData buildHash.
             * @member {Uint8Array} buildHash
             * @memberof ClientHello.C2S.CompanionRegData
             * @instance
             */
            CompanionRegData.prototype.buildHash = $util.newBuffer([]);

            /**
             * CompanionRegData companionProps.
             * @member {Uint8Array} companionProps
             * @memberof ClientHello.C2S.CompanionRegData
             * @instance
             */
            CompanionRegData.prototype.companionProps = $util.newBuffer([]);

            /**
             * Creates a new CompanionRegData instance using the specified properties.
             * @function create
             * @memberof ClientHello.C2S.CompanionRegData
             * @static
             * @param {ClientHello.C2S.ICompanionRegData=} [properties] Properties to set
             * @returns {ClientHello.C2S.CompanionRegData} CompanionRegData instance
             */
            CompanionRegData.create = function create(properties) {
                return new CompanionRegData(properties);
            };

            /**
             * Encodes the specified CompanionRegData message. Does not implicitly {@link ClientHello.C2S.CompanionRegData.verify|verify} messages.
             * @function encode
             * @memberof ClientHello.C2S.CompanionRegData
             * @static
             * @param {ClientHello.C2S.ICompanionRegData} message CompanionRegData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompanionRegData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.eRegid != null && Object.hasOwnProperty.call(message, "eRegid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.eRegid);
                if (message.eKeytype != null && Object.hasOwnProperty.call(message, "eKeytype"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.eKeytype);
                if (message.eIdent != null && Object.hasOwnProperty.call(message, "eIdent"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.eIdent);
                if (message.eSkeyId != null && Object.hasOwnProperty.call(message, "eSkeyId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.eSkeyId);
                if (message.eSkeyVal != null && Object.hasOwnProperty.call(message, "eSkeyVal"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.eSkeyVal);
                if (message.eSkeySig != null && Object.hasOwnProperty.call(message, "eSkeySig"))
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.eSkeySig);
                if (message.buildHash != null && Object.hasOwnProperty.call(message, "buildHash"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.buildHash);
                if (message.companionProps != null && Object.hasOwnProperty.call(message, "companionProps"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.companionProps);
                return writer;
            };

            /**
             * Encodes the specified CompanionRegData message, length delimited. Does not implicitly {@link ClientHello.C2S.CompanionRegData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof ClientHello.C2S.CompanionRegData
             * @static
             * @param {ClientHello.C2S.ICompanionRegData} message CompanionRegData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompanionRegData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CompanionRegData message from the specified reader or buffer.
             * @function decode
             * @memberof ClientHello.C2S.CompanionRegData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {ClientHello.C2S.CompanionRegData} CompanionRegData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompanionRegData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClientHello.C2S.CompanionRegData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.eRegid = reader.bytes();
                        break;
                    case 2:
                        message.eKeytype = reader.bytes();
                        break;
                    case 3:
                        message.eIdent = reader.bytes();
                        break;
                    case 4:
                        message.eSkeyId = reader.bytes();
                        break;
                    case 5:
                        message.eSkeyVal = reader.bytes();
                        break;
                    case 6:
                        message.eSkeySig = reader.bytes();
                        break;
                    case 7:
                        message.buildHash = reader.bytes();
                        break;
                    case 8:
                        message.companionProps = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CompanionRegData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof ClientHello.C2S.CompanionRegData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {ClientHello.C2S.CompanionRegData} CompanionRegData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompanionRegData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CompanionRegData message.
             * @function verify
             * @memberof ClientHello.C2S.CompanionRegData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CompanionRegData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.eRegid != null && message.hasOwnProperty("eRegid"))
                    if (!(message.eRegid && typeof message.eRegid.length === "number" || $util.isString(message.eRegid)))
                        return "eRegid: buffer expected";
                if (message.eKeytype != null && message.hasOwnProperty("eKeytype"))
                    if (!(message.eKeytype && typeof message.eKeytype.length === "number" || $util.isString(message.eKeytype)))
                        return "eKeytype: buffer expected";
                if (message.eIdent != null && message.hasOwnProperty("eIdent"))
                    if (!(message.eIdent && typeof message.eIdent.length === "number" || $util.isString(message.eIdent)))
                        return "eIdent: buffer expected";
                if (message.eSkeyId != null && message.hasOwnProperty("eSkeyId"))
                    if (!(message.eSkeyId && typeof message.eSkeyId.length === "number" || $util.isString(message.eSkeyId)))
                        return "eSkeyId: buffer expected";
                if (message.eSkeyVal != null && message.hasOwnProperty("eSkeyVal"))
                    if (!(message.eSkeyVal && typeof message.eSkeyVal.length === "number" || $util.isString(message.eSkeyVal)))
                        return "eSkeyVal: buffer expected";
                if (message.eSkeySig != null && message.hasOwnProperty("eSkeySig"))
                    if (!(message.eSkeySig && typeof message.eSkeySig.length === "number" || $util.isString(message.eSkeySig)))
                        return "eSkeySig: buffer expected";
                if (message.buildHash != null && message.hasOwnProperty("buildHash"))
                    if (!(message.buildHash && typeof message.buildHash.length === "number" || $util.isString(message.buildHash)))
                        return "buildHash: buffer expected";
                if (message.companionProps != null && message.hasOwnProperty("companionProps"))
                    if (!(message.companionProps && typeof message.companionProps.length === "number" || $util.isString(message.companionProps)))
                        return "companionProps: buffer expected";
                return null;
            };

            /**
             * Creates a CompanionRegData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof ClientHello.C2S.CompanionRegData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {ClientHello.C2S.CompanionRegData} CompanionRegData
             */
            CompanionRegData.fromObject = function fromObject(object) {
                if (object instanceof $root.ClientHello.C2S.CompanionRegData)
                    return object;
                var message = new $root.ClientHello.C2S.CompanionRegData();
                if (object.eRegid != null)
                    if (typeof object.eRegid === "string")
                        $util.base64.decode(object.eRegid, message.eRegid = $util.newBuffer($util.base64.length(object.eRegid)), 0);
                    else if (object.eRegid.length)
                        message.eRegid = object.eRegid;
                if (object.eKeytype != null)
                    if (typeof object.eKeytype === "string")
                        $util.base64.decode(object.eKeytype, message.eKeytype = $util.newBuffer($util.base64.length(object.eKeytype)), 0);
                    else if (object.eKeytype.length)
                        message.eKeytype = object.eKeytype;
                if (object.eIdent != null)
                    if (typeof object.eIdent === "string")
                        $util.base64.decode(object.eIdent, message.eIdent = $util.newBuffer($util.base64.length(object.eIdent)), 0);
                    else if (object.eIdent.length)
                        message.eIdent = object.eIdent;
                if (object.eSkeyId != null)
                    if (typeof object.eSkeyId === "string")
                        $util.base64.decode(object.eSkeyId, message.eSkeyId = $util.newBuffer($util.base64.length(object.eSkeyId)), 0);
                    else if (object.eSkeyId.length)
                        message.eSkeyId = object.eSkeyId;
                if (object.eSkeyVal != null)
                    if (typeof object.eSkeyVal === "string")
                        $util.base64.decode(object.eSkeyVal, message.eSkeyVal = $util.newBuffer($util.base64.length(object.eSkeyVal)), 0);
                    else if (object.eSkeyVal.length)
                        message.eSkeyVal = object.eSkeyVal;
                if (object.eSkeySig != null)
                    if (typeof object.eSkeySig === "string")
                        $util.base64.decode(object.eSkeySig, message.eSkeySig = $util.newBuffer($util.base64.length(object.eSkeySig)), 0);
                    else if (object.eSkeySig.length)
                        message.eSkeySig = object.eSkeySig;
                if (object.buildHash != null)
                    if (typeof object.buildHash === "string")
                        $util.base64.decode(object.buildHash, message.buildHash = $util.newBuffer($util.base64.length(object.buildHash)), 0);
                    else if (object.buildHash.length)
                        message.buildHash = object.buildHash;
                if (object.companionProps != null)
                    if (typeof object.companionProps === "string")
                        $util.base64.decode(object.companionProps, message.companionProps = $util.newBuffer($util.base64.length(object.companionProps)), 0);
                    else if (object.companionProps.length)
                        message.companionProps = object.companionProps;
                return message;
            };

            /**
             * Creates a plain object from a CompanionRegData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof ClientHello.C2S.CompanionRegData
             * @static
             * @param {ClientHello.C2S.CompanionRegData} message CompanionRegData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CompanionRegData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.eRegid = "";
                    else {
                        object.eRegid = [];
                        if (options.bytes !== Array)
                            object.eRegid = $util.newBuffer(object.eRegid);
                    }
                    if (options.bytes === String)
                        object.eKeytype = "";
                    else {
                        object.eKeytype = [];
                        if (options.bytes !== Array)
                            object.eKeytype = $util.newBuffer(object.eKeytype);
                    }
                    if (options.bytes === String)
                        object.eIdent = "";
                    else {
                        object.eIdent = [];
                        if (options.bytes !== Array)
                            object.eIdent = $util.newBuffer(object.eIdent);
                    }
                    if (options.bytes === String)
                        object.eSkeyId = "";
                    else {
                        object.eSkeyId = [];
                        if (options.bytes !== Array)
                            object.eSkeyId = $util.newBuffer(object.eSkeyId);
                    }
                    if (options.bytes === String)
                        object.eSkeyVal = "";
                    else {
                        object.eSkeyVal = [];
                        if (options.bytes !== Array)
                            object.eSkeyVal = $util.newBuffer(object.eSkeyVal);
                    }
                    if (options.bytes === String)
                        object.eSkeySig = "";
                    else {
                        object.eSkeySig = [];
                        if (options.bytes !== Array)
                            object.eSkeySig = $util.newBuffer(object.eSkeySig);
                    }
                    if (options.bytes === String)
                        object.buildHash = "";
                    else {
                        object.buildHash = [];
                        if (options.bytes !== Array)
                            object.buildHash = $util.newBuffer(object.buildHash);
                    }
                    if (options.bytes === String)
                        object.companionProps = "";
                    else {
                        object.companionProps = [];
                        if (options.bytes !== Array)
                            object.companionProps = $util.newBuffer(object.companionProps);
                    }
                }
                if (message.eRegid != null && message.hasOwnProperty("eRegid"))
                    object.eRegid = options.bytes === String ? $util.base64.encode(message.eRegid, 0, message.eRegid.length) : options.bytes === Array ? Array.prototype.slice.call(message.eRegid) : message.eRegid;
                if (message.eKeytype != null && message.hasOwnProperty("eKeytype"))
                    object.eKeytype = options.bytes === String ? $util.base64.encode(message.eKeytype, 0, message.eKeytype.length) : options.bytes === Array ? Array.prototype.slice.call(message.eKeytype) : message.eKeytype;
                if (message.eIdent != null && message.hasOwnProperty("eIdent"))
                    object.eIdent = options.bytes === String ? $util.base64.encode(message.eIdent, 0, message.eIdent.length) : options.bytes === Array ? Array.prototype.slice.call(message.eIdent) : message.eIdent;
                if (message.eSkeyId != null && message.hasOwnProperty("eSkeyId"))
                    object.eSkeyId = options.bytes === String ? $util.base64.encode(message.eSkeyId, 0, message.eSkeyId.length) : options.bytes === Array ? Array.prototype.slice.call(message.eSkeyId) : message.eSkeyId;
                if (message.eSkeyVal != null && message.hasOwnProperty("eSkeyVal"))
                    object.eSkeyVal = options.bytes === String ? $util.base64.encode(message.eSkeyVal, 0, message.eSkeyVal.length) : options.bytes === Array ? Array.prototype.slice.call(message.eSkeyVal) : message.eSkeyVal;
                if (message.eSkeySig != null && message.hasOwnProperty("eSkeySig"))
                    object.eSkeySig = options.bytes === String ? $util.base64.encode(message.eSkeySig, 0, message.eSkeySig.length) : options.bytes === Array ? Array.prototype.slice.call(message.eSkeySig) : message.eSkeySig;
                if (message.buildHash != null && message.hasOwnProperty("buildHash"))
                    object.buildHash = options.bytes === String ? $util.base64.encode(message.buildHash, 0, message.buildHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.buildHash) : message.buildHash;
                if (message.companionProps != null && message.hasOwnProperty("companionProps"))
                    object.companionProps = options.bytes === String ? $util.base64.encode(message.companionProps, 0, message.companionProps.length) : options.bytes === Array ? Array.prototype.slice.call(message.companionProps) : message.companionProps;
                return object;
            };

            /**
             * Converts this CompanionRegData to JSON.
             * @function toJSON
             * @memberof ClientHello.C2S.CompanionRegData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CompanionRegData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CompanionRegData;
        })();

        return C2S;
    })();

    return ClientHello;
})();

$root.HandshakeMessage = (function() {

    /**
     * Namespace HandshakeMessage.
     * @exports HandshakeMessage
     * @namespace
     */
    var HandshakeMessage = {};

    HandshakeMessage.ClientHello = (function() {

        /**
         * Properties of a ClientHello.
         * @memberof HandshakeMessage
         * @interface IClientHello
         * @property {Uint8Array|null} [ephemeral] ClientHello ephemeral
         * @property {Uint8Array|null} ["static"] ClientHello static
         * @property {Uint8Array|null} [payload] ClientHello payload
         */

        /**
         * Constructs a new ClientHello.
         * @memberof HandshakeMessage
         * @classdesc Represents a ClientHello.
         * @implements IClientHello
         * @constructor
         * @param {HandshakeMessage.IClientHello=} [properties] Properties to set
         */
        function ClientHello(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientHello ephemeral.
         * @member {Uint8Array} ephemeral
         * @memberof HandshakeMessage.ClientHello
         * @instance
         */
        ClientHello.prototype.ephemeral = $util.newBuffer([]);

        /**
         * ClientHello static.
         * @member {Uint8Array} static
         * @memberof HandshakeMessage.ClientHello
         * @instance
         */
        ClientHello.prototype["static"] = $util.newBuffer([]);

        /**
         * ClientHello payload.
         * @member {Uint8Array} payload
         * @memberof HandshakeMessage.ClientHello
         * @instance
         */
        ClientHello.prototype.payload = $util.newBuffer([]);

        /**
         * Creates a new ClientHello instance using the specified properties.
         * @function create
         * @memberof HandshakeMessage.ClientHello
         * @static
         * @param {HandshakeMessage.IClientHello=} [properties] Properties to set
         * @returns {HandshakeMessage.ClientHello} ClientHello instance
         */
        ClientHello.create = function create(properties) {
            return new ClientHello(properties);
        };

        /**
         * Encodes the specified ClientHello message. Does not implicitly {@link HandshakeMessage.ClientHello.verify|verify} messages.
         * @function encode
         * @memberof HandshakeMessage.ClientHello
         * @static
         * @param {HandshakeMessage.IClientHello} message ClientHello message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientHello.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ephemeral != null && Object.hasOwnProperty.call(message, "ephemeral"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ephemeral);
            if (message["static"] != null && Object.hasOwnProperty.call(message, "static"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message["static"]);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.payload);
            return writer;
        };

        /**
         * Encodes the specified ClientHello message, length delimited. Does not implicitly {@link HandshakeMessage.ClientHello.verify|verify} messages.
         * @function encodeDelimited
         * @memberof HandshakeMessage.ClientHello
         * @static
         * @param {HandshakeMessage.IClientHello} message ClientHello message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientHello.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientHello message from the specified reader or buffer.
         * @function decode
         * @memberof HandshakeMessage.ClientHello
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {HandshakeMessage.ClientHello} ClientHello
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientHello.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.HandshakeMessage.ClientHello();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ephemeral = reader.bytes();
                    break;
                case 2:
                    message["static"] = reader.bytes();
                    break;
                case 3:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientHello message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof HandshakeMessage.ClientHello
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {HandshakeMessage.ClientHello} ClientHello
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientHello.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientHello message.
         * @function verify
         * @memberof HandshakeMessage.ClientHello
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientHello.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ephemeral != null && message.hasOwnProperty("ephemeral"))
                if (!(message.ephemeral && typeof message.ephemeral.length === "number" || $util.isString(message.ephemeral)))
                    return "ephemeral: buffer expected";
            if (message["static"] != null && message.hasOwnProperty("static"))
                if (!(message["static"] && typeof message["static"].length === "number" || $util.isString(message["static"])))
                    return "static: buffer expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            return null;
        };

        /**
         * Creates a ClientHello message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof HandshakeMessage.ClientHello
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {HandshakeMessage.ClientHello} ClientHello
         */
        ClientHello.fromObject = function fromObject(object) {
            if (object instanceof $root.HandshakeMessage.ClientHello)
                return object;
            var message = new $root.HandshakeMessage.ClientHello();
            if (object.ephemeral != null)
                if (typeof object.ephemeral === "string")
                    $util.base64.decode(object.ephemeral, message.ephemeral = $util.newBuffer($util.base64.length(object.ephemeral)), 0);
                else if (object.ephemeral.length)
                    message.ephemeral = object.ephemeral;
            if (object["static"] != null)
                if (typeof object["static"] === "string")
                    $util.base64.decode(object["static"], message["static"] = $util.newBuffer($util.base64.length(object["static"])), 0);
                else if (object["static"].length)
                    message["static"] = object["static"];
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            return message;
        };

        /**
         * Creates a plain object from a ClientHello message. Also converts values to other types if specified.
         * @function toObject
         * @memberof HandshakeMessage.ClientHello
         * @static
         * @param {HandshakeMessage.ClientHello} message ClientHello
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientHello.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ephemeral = "";
                else {
                    object.ephemeral = [];
                    if (options.bytes !== Array)
                        object.ephemeral = $util.newBuffer(object.ephemeral);
                }
                if (options.bytes === String)
                    object["static"] = "";
                else {
                    object["static"] = [];
                    if (options.bytes !== Array)
                        object["static"] = $util.newBuffer(object["static"]);
                }
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
            }
            if (message.ephemeral != null && message.hasOwnProperty("ephemeral"))
                object.ephemeral = options.bytes === String ? $util.base64.encode(message.ephemeral, 0, message.ephemeral.length) : options.bytes === Array ? Array.prototype.slice.call(message.ephemeral) : message.ephemeral;
            if (message["static"] != null && message.hasOwnProperty("static"))
                object["static"] = options.bytes === String ? $util.base64.encode(message["static"], 0, message["static"].length) : options.bytes === Array ? Array.prototype.slice.call(message["static"]) : message["static"];
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            return object;
        };

        /**
         * Converts this ClientHello to JSON.
         * @function toJSON
         * @memberof HandshakeMessage.ClientHello
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientHello.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClientHello;
    })();

    HandshakeMessage.ServerHello = (function() {

        /**
         * Properties of a ServerHello.
         * @memberof HandshakeMessage
         * @interface IServerHello
         * @property {Uint8Array|null} [ephemeral] ServerHello ephemeral
         * @property {Uint8Array|null} ["static"] ServerHello static
         * @property {Uint8Array|null} [payload] ServerHello payload
         */

        /**
         * Constructs a new ServerHello.
         * @memberof HandshakeMessage
         * @classdesc Represents a ServerHello.
         * @implements IServerHello
         * @constructor
         * @param {HandshakeMessage.IServerHello=} [properties] Properties to set
         */
        function ServerHello(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerHello ephemeral.
         * @member {Uint8Array} ephemeral
         * @memberof HandshakeMessage.ServerHello
         * @instance
         */
        ServerHello.prototype.ephemeral = $util.newBuffer([]);

        /**
         * ServerHello static.
         * @member {Uint8Array} static
         * @memberof HandshakeMessage.ServerHello
         * @instance
         */
        ServerHello.prototype["static"] = $util.newBuffer([]);

        /**
         * ServerHello payload.
         * @member {Uint8Array} payload
         * @memberof HandshakeMessage.ServerHello
         * @instance
         */
        ServerHello.prototype.payload = $util.newBuffer([]);

        /**
         * Creates a new ServerHello instance using the specified properties.
         * @function create
         * @memberof HandshakeMessage.ServerHello
         * @static
         * @param {HandshakeMessage.IServerHello=} [properties] Properties to set
         * @returns {HandshakeMessage.ServerHello} ServerHello instance
         */
        ServerHello.create = function create(properties) {
            return new ServerHello(properties);
        };

        /**
         * Encodes the specified ServerHello message. Does not implicitly {@link HandshakeMessage.ServerHello.verify|verify} messages.
         * @function encode
         * @memberof HandshakeMessage.ServerHello
         * @static
         * @param {HandshakeMessage.IServerHello} message ServerHello message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerHello.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ephemeral != null && Object.hasOwnProperty.call(message, "ephemeral"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ephemeral);
            if (message["static"] != null && Object.hasOwnProperty.call(message, "static"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message["static"]);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.payload);
            return writer;
        };

        /**
         * Encodes the specified ServerHello message, length delimited. Does not implicitly {@link HandshakeMessage.ServerHello.verify|verify} messages.
         * @function encodeDelimited
         * @memberof HandshakeMessage.ServerHello
         * @static
         * @param {HandshakeMessage.IServerHello} message ServerHello message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerHello.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerHello message from the specified reader or buffer.
         * @function decode
         * @memberof HandshakeMessage.ServerHello
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {HandshakeMessage.ServerHello} ServerHello
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerHello.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.HandshakeMessage.ServerHello();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ephemeral = reader.bytes();
                    break;
                case 2:
                    message["static"] = reader.bytes();
                    break;
                case 3:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerHello message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof HandshakeMessage.ServerHello
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {HandshakeMessage.ServerHello} ServerHello
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerHello.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerHello message.
         * @function verify
         * @memberof HandshakeMessage.ServerHello
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerHello.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ephemeral != null && message.hasOwnProperty("ephemeral"))
                if (!(message.ephemeral && typeof message.ephemeral.length === "number" || $util.isString(message.ephemeral)))
                    return "ephemeral: buffer expected";
            if (message["static"] != null && message.hasOwnProperty("static"))
                if (!(message["static"] && typeof message["static"].length === "number" || $util.isString(message["static"])))
                    return "static: buffer expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            return null;
        };

        /**
         * Creates a ServerHello message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof HandshakeMessage.ServerHello
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {HandshakeMessage.ServerHello} ServerHello
         */
        ServerHello.fromObject = function fromObject(object) {
            if (object instanceof $root.HandshakeMessage.ServerHello)
                return object;
            var message = new $root.HandshakeMessage.ServerHello();
            if (object.ephemeral != null)
                if (typeof object.ephemeral === "string")
                    $util.base64.decode(object.ephemeral, message.ephemeral = $util.newBuffer($util.base64.length(object.ephemeral)), 0);
                else if (object.ephemeral.length)
                    message.ephemeral = object.ephemeral;
            if (object["static"] != null)
                if (typeof object["static"] === "string")
                    $util.base64.decode(object["static"], message["static"] = $util.newBuffer($util.base64.length(object["static"])), 0);
                else if (object["static"].length)
                    message["static"] = object["static"];
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            return message;
        };

        /**
         * Creates a plain object from a ServerHello message. Also converts values to other types if specified.
         * @function toObject
         * @memberof HandshakeMessage.ServerHello
         * @static
         * @param {HandshakeMessage.ServerHello} message ServerHello
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerHello.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ephemeral = "";
                else {
                    object.ephemeral = [];
                    if (options.bytes !== Array)
                        object.ephemeral = $util.newBuffer(object.ephemeral);
                }
                if (options.bytes === String)
                    object["static"] = "";
                else {
                    object["static"] = [];
                    if (options.bytes !== Array)
                        object["static"] = $util.newBuffer(object["static"]);
                }
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
            }
            if (message.ephemeral != null && message.hasOwnProperty("ephemeral"))
                object.ephemeral = options.bytes === String ? $util.base64.encode(message.ephemeral, 0, message.ephemeral.length) : options.bytes === Array ? Array.prototype.slice.call(message.ephemeral) : message.ephemeral;
            if (message["static"] != null && message.hasOwnProperty("static"))
                object["static"] = options.bytes === String ? $util.base64.encode(message["static"], 0, message["static"].length) : options.bytes === Array ? Array.prototype.slice.call(message["static"]) : message["static"];
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            return object;
        };

        /**
         * Converts this ServerHello to JSON.
         * @function toJSON
         * @memberof HandshakeMessage.ServerHello
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerHello.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServerHello;
    })();

    HandshakeMessage.ClientFinish = (function() {

        /**
         * Properties of a ClientFinish.
         * @memberof HandshakeMessage
         * @interface IClientFinish
         * @property {Uint8Array|null} ["static"] ClientFinish static
         * @property {Uint8Array|null} [payload] ClientFinish payload
         */

        /**
         * Constructs a new ClientFinish.
         * @memberof HandshakeMessage
         * @classdesc Represents a ClientFinish.
         * @implements IClientFinish
         * @constructor
         * @param {HandshakeMessage.IClientFinish=} [properties] Properties to set
         */
        function ClientFinish(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientFinish static.
         * @member {Uint8Array} static
         * @memberof HandshakeMessage.ClientFinish
         * @instance
         */
        ClientFinish.prototype["static"] = $util.newBuffer([]);

        /**
         * ClientFinish payload.
         * @member {Uint8Array} payload
         * @memberof HandshakeMessage.ClientFinish
         * @instance
         */
        ClientFinish.prototype.payload = $util.newBuffer([]);

        /**
         * Creates a new ClientFinish instance using the specified properties.
         * @function create
         * @memberof HandshakeMessage.ClientFinish
         * @static
         * @param {HandshakeMessage.IClientFinish=} [properties] Properties to set
         * @returns {HandshakeMessage.ClientFinish} ClientFinish instance
         */
        ClientFinish.create = function create(properties) {
            return new ClientFinish(properties);
        };

        /**
         * Encodes the specified ClientFinish message. Does not implicitly {@link HandshakeMessage.ClientFinish.verify|verify} messages.
         * @function encode
         * @memberof HandshakeMessage.ClientFinish
         * @static
         * @param {HandshakeMessage.IClientFinish} message ClientFinish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientFinish.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message["static"] != null && Object.hasOwnProperty.call(message, "static"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message["static"]);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
            return writer;
        };

        /**
         * Encodes the specified ClientFinish message, length delimited. Does not implicitly {@link HandshakeMessage.ClientFinish.verify|verify} messages.
         * @function encodeDelimited
         * @memberof HandshakeMessage.ClientFinish
         * @static
         * @param {HandshakeMessage.IClientFinish} message ClientFinish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientFinish.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientFinish message from the specified reader or buffer.
         * @function decode
         * @memberof HandshakeMessage.ClientFinish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {HandshakeMessage.ClientFinish} ClientFinish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientFinish.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.HandshakeMessage.ClientFinish();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message["static"] = reader.bytes();
                    break;
                case 2:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientFinish message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof HandshakeMessage.ClientFinish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {HandshakeMessage.ClientFinish} ClientFinish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientFinish.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientFinish message.
         * @function verify
         * @memberof HandshakeMessage.ClientFinish
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientFinish.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["static"] != null && message.hasOwnProperty("static"))
                if (!(message["static"] && typeof message["static"].length === "number" || $util.isString(message["static"])))
                    return "static: buffer expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            return null;
        };

        /**
         * Creates a ClientFinish message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof HandshakeMessage.ClientFinish
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {HandshakeMessage.ClientFinish} ClientFinish
         */
        ClientFinish.fromObject = function fromObject(object) {
            if (object instanceof $root.HandshakeMessage.ClientFinish)
                return object;
            var message = new $root.HandshakeMessage.ClientFinish();
            if (object["static"] != null)
                if (typeof object["static"] === "string")
                    $util.base64.decode(object["static"], message["static"] = $util.newBuffer($util.base64.length(object["static"])), 0);
                else if (object["static"].length)
                    message["static"] = object["static"];
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            return message;
        };

        /**
         * Creates a plain object from a ClientFinish message. Also converts values to other types if specified.
         * @function toObject
         * @memberof HandshakeMessage.ClientFinish
         * @static
         * @param {HandshakeMessage.ClientFinish} message ClientFinish
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientFinish.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object["static"] = "";
                else {
                    object["static"] = [];
                    if (options.bytes !== Array)
                        object["static"] = $util.newBuffer(object["static"]);
                }
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
            }
            if (message["static"] != null && message.hasOwnProperty("static"))
                object["static"] = options.bytes === String ? $util.base64.encode(message["static"], 0, message["static"].length) : options.bytes === Array ? Array.prototype.slice.call(message["static"]) : message["static"];
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            return object;
        };

        /**
         * Converts this ClientFinish to JSON.
         * @function toJSON
         * @memberof HandshakeMessage.ClientFinish
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientFinish.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClientFinish;
    })();

    HandshakeMessage.HandshakeMessage = (function() {

        /**
         * Properties of a HandshakeMessage.
         * @memberof HandshakeMessage
         * @interface IHandshakeMessage
         * @property {HandshakeMessage.IClientHello|null} [clientHello] HandshakeMessage clientHello
         * @property {HandshakeMessage.IServerHello|null} [serverHello] HandshakeMessage serverHello
         * @property {HandshakeMessage.IClientFinish|null} [clientFinish] HandshakeMessage clientFinish
         */

        /**
         * Constructs a new HandshakeMessage.
         * @memberof HandshakeMessage
         * @classdesc Represents a HandshakeMessage.
         * @implements IHandshakeMessage
         * @constructor
         * @param {HandshakeMessage.IHandshakeMessage=} [properties] Properties to set
         */
        function HandshakeMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HandshakeMessage clientHello.
         * @member {HandshakeMessage.IClientHello|null|undefined} clientHello
         * @memberof HandshakeMessage.HandshakeMessage
         * @instance
         */
        HandshakeMessage.prototype.clientHello = null;

        /**
         * HandshakeMessage serverHello.
         * @member {HandshakeMessage.IServerHello|null|undefined} serverHello
         * @memberof HandshakeMessage.HandshakeMessage
         * @instance
         */
        HandshakeMessage.prototype.serverHello = null;

        /**
         * HandshakeMessage clientFinish.
         * @member {HandshakeMessage.IClientFinish|null|undefined} clientFinish
         * @memberof HandshakeMessage.HandshakeMessage
         * @instance
         */
        HandshakeMessage.prototype.clientFinish = null;

        /**
         * Creates a new HandshakeMessage instance using the specified properties.
         * @function create
         * @memberof HandshakeMessage.HandshakeMessage
         * @static
         * @param {HandshakeMessage.IHandshakeMessage=} [properties] Properties to set
         * @returns {HandshakeMessage.HandshakeMessage} HandshakeMessage instance
         */
        HandshakeMessage.create = function create(properties) {
            return new HandshakeMessage(properties);
        };

        /**
         * Encodes the specified HandshakeMessage message. Does not implicitly {@link HandshakeMessage.HandshakeMessage.verify|verify} messages.
         * @function encode
         * @memberof HandshakeMessage.HandshakeMessage
         * @static
         * @param {HandshakeMessage.IHandshakeMessage} message HandshakeMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HandshakeMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clientHello != null && Object.hasOwnProperty.call(message, "clientHello"))
                $root.HandshakeMessage.ClientHello.encode(message.clientHello, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.serverHello != null && Object.hasOwnProperty.call(message, "serverHello"))
                $root.HandshakeMessage.ServerHello.encode(message.serverHello, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.clientFinish != null && Object.hasOwnProperty.call(message, "clientFinish"))
                $root.HandshakeMessage.ClientFinish.encode(message.clientFinish, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified HandshakeMessage message, length delimited. Does not implicitly {@link HandshakeMessage.HandshakeMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof HandshakeMessage.HandshakeMessage
         * @static
         * @param {HandshakeMessage.IHandshakeMessage} message HandshakeMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HandshakeMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HandshakeMessage message from the specified reader or buffer.
         * @function decode
         * @memberof HandshakeMessage.HandshakeMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {HandshakeMessage.HandshakeMessage} HandshakeMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HandshakeMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.HandshakeMessage.HandshakeMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.clientHello = $root.HandshakeMessage.ClientHello.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.serverHello = $root.HandshakeMessage.ServerHello.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.clientFinish = $root.HandshakeMessage.ClientFinish.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HandshakeMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof HandshakeMessage.HandshakeMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {HandshakeMessage.HandshakeMessage} HandshakeMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HandshakeMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HandshakeMessage message.
         * @function verify
         * @memberof HandshakeMessage.HandshakeMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HandshakeMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clientHello != null && message.hasOwnProperty("clientHello")) {
                var error = $root.HandshakeMessage.ClientHello.verify(message.clientHello);
                if (error)
                    return "clientHello." + error;
            }
            if (message.serverHello != null && message.hasOwnProperty("serverHello")) {
                var error = $root.HandshakeMessage.ServerHello.verify(message.serverHello);
                if (error)
                    return "serverHello." + error;
            }
            if (message.clientFinish != null && message.hasOwnProperty("clientFinish")) {
                var error = $root.HandshakeMessage.ClientFinish.verify(message.clientFinish);
                if (error)
                    return "clientFinish." + error;
            }
            return null;
        };

        /**
         * Creates a HandshakeMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof HandshakeMessage.HandshakeMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {HandshakeMessage.HandshakeMessage} HandshakeMessage
         */
        HandshakeMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.HandshakeMessage.HandshakeMessage)
                return object;
            var message = new $root.HandshakeMessage.HandshakeMessage();
            if (object.clientHello != null) {
                if (typeof object.clientHello !== "object")
                    throw TypeError(".HandshakeMessage.HandshakeMessage.clientHello: object expected");
                message.clientHello = $root.HandshakeMessage.ClientHello.fromObject(object.clientHello);
            }
            if (object.serverHello != null) {
                if (typeof object.serverHello !== "object")
                    throw TypeError(".HandshakeMessage.HandshakeMessage.serverHello: object expected");
                message.serverHello = $root.HandshakeMessage.ServerHello.fromObject(object.serverHello);
            }
            if (object.clientFinish != null) {
                if (typeof object.clientFinish !== "object")
                    throw TypeError(".HandshakeMessage.HandshakeMessage.clientFinish: object expected");
                message.clientFinish = $root.HandshakeMessage.ClientFinish.fromObject(object.clientFinish);
            }
            return message;
        };

        /**
         * Creates a plain object from a HandshakeMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof HandshakeMessage.HandshakeMessage
         * @static
         * @param {HandshakeMessage.HandshakeMessage} message HandshakeMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HandshakeMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.clientHello = null;
                object.serverHello = null;
                object.clientFinish = null;
            }
            if (message.clientHello != null && message.hasOwnProperty("clientHello"))
                object.clientHello = $root.HandshakeMessage.ClientHello.toObject(message.clientHello, options);
            if (message.serverHello != null && message.hasOwnProperty("serverHello"))
                object.serverHello = $root.HandshakeMessage.ServerHello.toObject(message.serverHello, options);
            if (message.clientFinish != null && message.hasOwnProperty("clientFinish"))
                object.clientFinish = $root.HandshakeMessage.ClientFinish.toObject(message.clientFinish, options);
            return object;
        };

        /**
         * Converts this HandshakeMessage to JSON.
         * @function toJSON
         * @memberof HandshakeMessage.HandshakeMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HandshakeMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HandshakeMessage;
    })();

    return HandshakeMessage;
})();

$root.Message = (function() {

    /**
     * Namespace Message.
     * @exports Message
     * @namespace
     */
    var Message = {};

    Message.SenderKeyMessage = (function() {

        /**
         * Properties of a SenderKeyMessage.
         * @memberof Message
         * @interface ISenderKeyMessage
         * @property {number|null} [id] SenderKeyMessage id
         * @property {number|null} [iteration] SenderKeyMessage iteration
         * @property {Uint8Array|null} [ciphertext] SenderKeyMessage ciphertext
         */

        /**
         * Constructs a new SenderKeyMessage.
         * @memberof Message
         * @classdesc Represents a SenderKeyMessage.
         * @implements ISenderKeyMessage
         * @constructor
         * @param {Message.ISenderKeyMessage=} [properties] Properties to set
         */
        function SenderKeyMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SenderKeyMessage id.
         * @member {number} id
         * @memberof Message.SenderKeyMessage
         * @instance
         */
        SenderKeyMessage.prototype.id = 0;

        /**
         * SenderKeyMessage iteration.
         * @member {number} iteration
         * @memberof Message.SenderKeyMessage
         * @instance
         */
        SenderKeyMessage.prototype.iteration = 0;

        /**
         * SenderKeyMessage ciphertext.
         * @member {Uint8Array} ciphertext
         * @memberof Message.SenderKeyMessage
         * @instance
         */
        SenderKeyMessage.prototype.ciphertext = $util.newBuffer([]);

        /**
         * Creates a new SenderKeyMessage instance using the specified properties.
         * @function create
         * @memberof Message.SenderKeyMessage
         * @static
         * @param {Message.ISenderKeyMessage=} [properties] Properties to set
         * @returns {Message.SenderKeyMessage} SenderKeyMessage instance
         */
        SenderKeyMessage.create = function create(properties) {
            return new SenderKeyMessage(properties);
        };

        /**
         * Encodes the specified SenderKeyMessage message. Does not implicitly {@link Message.SenderKeyMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.SenderKeyMessage
         * @static
         * @param {Message.ISenderKeyMessage} message SenderKeyMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderKeyMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.iteration != null && Object.hasOwnProperty.call(message, "iteration"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.iteration);
            if (message.ciphertext != null && Object.hasOwnProperty.call(message, "ciphertext"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.ciphertext);
            return writer;
        };

        /**
         * Encodes the specified SenderKeyMessage message, length delimited. Does not implicitly {@link Message.SenderKeyMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.SenderKeyMessage
         * @static
         * @param {Message.ISenderKeyMessage} message SenderKeyMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderKeyMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SenderKeyMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.SenderKeyMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.SenderKeyMessage} SenderKeyMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderKeyMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.SenderKeyMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint32();
                    break;
                case 2:
                    message.iteration = reader.uint32();
                    break;
                case 3:
                    message.ciphertext = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SenderKeyMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.SenderKeyMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.SenderKeyMessage} SenderKeyMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderKeyMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SenderKeyMessage message.
         * @function verify
         * @memberof Message.SenderKeyMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SenderKeyMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.iteration != null && message.hasOwnProperty("iteration"))
                if (!$util.isInteger(message.iteration))
                    return "iteration: integer expected";
            if (message.ciphertext != null && message.hasOwnProperty("ciphertext"))
                if (!(message.ciphertext && typeof message.ciphertext.length === "number" || $util.isString(message.ciphertext)))
                    return "ciphertext: buffer expected";
            return null;
        };

        /**
         * Creates a SenderKeyMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.SenderKeyMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.SenderKeyMessage} SenderKeyMessage
         */
        SenderKeyMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.SenderKeyMessage)
                return object;
            var message = new $root.Message.SenderKeyMessage();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.iteration != null)
                message.iteration = object.iteration >>> 0;
            if (object.ciphertext != null)
                if (typeof object.ciphertext === "string")
                    $util.base64.decode(object.ciphertext, message.ciphertext = $util.newBuffer($util.base64.length(object.ciphertext)), 0);
                else if (object.ciphertext.length)
                    message.ciphertext = object.ciphertext;
            return message;
        };

        /**
         * Creates a plain object from a SenderKeyMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.SenderKeyMessage
         * @static
         * @param {Message.SenderKeyMessage} message SenderKeyMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SenderKeyMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.iteration = 0;
                if (options.bytes === String)
                    object.ciphertext = "";
                else {
                    object.ciphertext = [];
                    if (options.bytes !== Array)
                        object.ciphertext = $util.newBuffer(object.ciphertext);
                }
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.iteration != null && message.hasOwnProperty("iteration"))
                object.iteration = message.iteration;
            if (message.ciphertext != null && message.hasOwnProperty("ciphertext"))
                object.ciphertext = options.bytes === String ? $util.base64.encode(message.ciphertext, 0, message.ciphertext.length) : options.bytes === Array ? Array.prototype.slice.call(message.ciphertext) : message.ciphertext;
            return object;
        };

        /**
         * Converts this SenderKeyMessage to JSON.
         * @function toJSON
         * @memberof Message.SenderKeyMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SenderKeyMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SenderKeyMessage;
    })();

    Message.SenderChainKey = (function() {

        /**
         * Properties of a SenderChainKey.
         * @memberof Message
         * @interface ISenderChainKey
         * @property {number|null} [iteration] SenderChainKey iteration
         * @property {Uint8Array|null} [seed] SenderChainKey seed
         */

        /**
         * Constructs a new SenderChainKey.
         * @memberof Message
         * @classdesc Represents a SenderChainKey.
         * @implements ISenderChainKey
         * @constructor
         * @param {Message.ISenderChainKey=} [properties] Properties to set
         */
        function SenderChainKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SenderChainKey iteration.
         * @member {number} iteration
         * @memberof Message.SenderChainKey
         * @instance
         */
        SenderChainKey.prototype.iteration = 0;

        /**
         * SenderChainKey seed.
         * @member {Uint8Array} seed
         * @memberof Message.SenderChainKey
         * @instance
         */
        SenderChainKey.prototype.seed = $util.newBuffer([]);

        /**
         * Creates a new SenderChainKey instance using the specified properties.
         * @function create
         * @memberof Message.SenderChainKey
         * @static
         * @param {Message.ISenderChainKey=} [properties] Properties to set
         * @returns {Message.SenderChainKey} SenderChainKey instance
         */
        SenderChainKey.create = function create(properties) {
            return new SenderChainKey(properties);
        };

        /**
         * Encodes the specified SenderChainKey message. Does not implicitly {@link Message.SenderChainKey.verify|verify} messages.
         * @function encode
         * @memberof Message.SenderChainKey
         * @static
         * @param {Message.ISenderChainKey} message SenderChainKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderChainKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.iteration != null && Object.hasOwnProperty.call(message, "iteration"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.iteration);
            if (message.seed != null && Object.hasOwnProperty.call(message, "seed"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.seed);
            return writer;
        };

        /**
         * Encodes the specified SenderChainKey message, length delimited. Does not implicitly {@link Message.SenderChainKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.SenderChainKey
         * @static
         * @param {Message.ISenderChainKey} message SenderChainKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderChainKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SenderChainKey message from the specified reader or buffer.
         * @function decode
         * @memberof Message.SenderChainKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.SenderChainKey} SenderChainKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderChainKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.SenderChainKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.iteration = reader.uint32();
                    break;
                case 2:
                    message.seed = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SenderChainKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.SenderChainKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.SenderChainKey} SenderChainKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderChainKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SenderChainKey message.
         * @function verify
         * @memberof Message.SenderChainKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SenderChainKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.iteration != null && message.hasOwnProperty("iteration"))
                if (!$util.isInteger(message.iteration))
                    return "iteration: integer expected";
            if (message.seed != null && message.hasOwnProperty("seed"))
                if (!(message.seed && typeof message.seed.length === "number" || $util.isString(message.seed)))
                    return "seed: buffer expected";
            return null;
        };

        /**
         * Creates a SenderChainKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.SenderChainKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.SenderChainKey} SenderChainKey
         */
        SenderChainKey.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.SenderChainKey)
                return object;
            var message = new $root.Message.SenderChainKey();
            if (object.iteration != null)
                message.iteration = object.iteration >>> 0;
            if (object.seed != null)
                if (typeof object.seed === "string")
                    $util.base64.decode(object.seed, message.seed = $util.newBuffer($util.base64.length(object.seed)), 0);
                else if (object.seed.length)
                    message.seed = object.seed;
            return message;
        };

        /**
         * Creates a plain object from a SenderChainKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.SenderChainKey
         * @static
         * @param {Message.SenderChainKey} message SenderChainKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SenderChainKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.iteration = 0;
                if (options.bytes === String)
                    object.seed = "";
                else {
                    object.seed = [];
                    if (options.bytes !== Array)
                        object.seed = $util.newBuffer(object.seed);
                }
            }
            if (message.iteration != null && message.hasOwnProperty("iteration"))
                object.iteration = message.iteration;
            if (message.seed != null && message.hasOwnProperty("seed"))
                object.seed = options.bytes === String ? $util.base64.encode(message.seed, 0, message.seed.length) : options.bytes === Array ? Array.prototype.slice.call(message.seed) : message.seed;
            return object;
        };

        /**
         * Converts this SenderChainKey to JSON.
         * @function toJSON
         * @memberof Message.SenderChainKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SenderChainKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SenderChainKey;
    })();

    Message.SenderMessageKey = (function() {

        /**
         * Properties of a SenderMessageKey.
         * @memberof Message
         * @interface ISenderMessageKey
         * @property {number|null} [iteration] SenderMessageKey iteration
         * @property {Uint8Array|null} [seed] SenderMessageKey seed
         */

        /**
         * Constructs a new SenderMessageKey.
         * @memberof Message
         * @classdesc Represents a SenderMessageKey.
         * @implements ISenderMessageKey
         * @constructor
         * @param {Message.ISenderMessageKey=} [properties] Properties to set
         */
        function SenderMessageKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SenderMessageKey iteration.
         * @member {number} iteration
         * @memberof Message.SenderMessageKey
         * @instance
         */
        SenderMessageKey.prototype.iteration = 0;

        /**
         * SenderMessageKey seed.
         * @member {Uint8Array} seed
         * @memberof Message.SenderMessageKey
         * @instance
         */
        SenderMessageKey.prototype.seed = $util.newBuffer([]);

        /**
         * Creates a new SenderMessageKey instance using the specified properties.
         * @function create
         * @memberof Message.SenderMessageKey
         * @static
         * @param {Message.ISenderMessageKey=} [properties] Properties to set
         * @returns {Message.SenderMessageKey} SenderMessageKey instance
         */
        SenderMessageKey.create = function create(properties) {
            return new SenderMessageKey(properties);
        };

        /**
         * Encodes the specified SenderMessageKey message. Does not implicitly {@link Message.SenderMessageKey.verify|verify} messages.
         * @function encode
         * @memberof Message.SenderMessageKey
         * @static
         * @param {Message.ISenderMessageKey} message SenderMessageKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderMessageKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.iteration != null && Object.hasOwnProperty.call(message, "iteration"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.iteration);
            if (message.seed != null && Object.hasOwnProperty.call(message, "seed"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.seed);
            return writer;
        };

        /**
         * Encodes the specified SenderMessageKey message, length delimited. Does not implicitly {@link Message.SenderMessageKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.SenderMessageKey
         * @static
         * @param {Message.ISenderMessageKey} message SenderMessageKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderMessageKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SenderMessageKey message from the specified reader or buffer.
         * @function decode
         * @memberof Message.SenderMessageKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.SenderMessageKey} SenderMessageKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderMessageKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.SenderMessageKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.iteration = reader.uint32();
                    break;
                case 2:
                    message.seed = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SenderMessageKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.SenderMessageKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.SenderMessageKey} SenderMessageKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderMessageKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SenderMessageKey message.
         * @function verify
         * @memberof Message.SenderMessageKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SenderMessageKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.iteration != null && message.hasOwnProperty("iteration"))
                if (!$util.isInteger(message.iteration))
                    return "iteration: integer expected";
            if (message.seed != null && message.hasOwnProperty("seed"))
                if (!(message.seed && typeof message.seed.length === "number" || $util.isString(message.seed)))
                    return "seed: buffer expected";
            return null;
        };

        /**
         * Creates a SenderMessageKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.SenderMessageKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.SenderMessageKey} SenderMessageKey
         */
        SenderMessageKey.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.SenderMessageKey)
                return object;
            var message = new $root.Message.SenderMessageKey();
            if (object.iteration != null)
                message.iteration = object.iteration >>> 0;
            if (object.seed != null)
                if (typeof object.seed === "string")
                    $util.base64.decode(object.seed, message.seed = $util.newBuffer($util.base64.length(object.seed)), 0);
                else if (object.seed.length)
                    message.seed = object.seed;
            return message;
        };

        /**
         * Creates a plain object from a SenderMessageKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.SenderMessageKey
         * @static
         * @param {Message.SenderMessageKey} message SenderMessageKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SenderMessageKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.iteration = 0;
                if (options.bytes === String)
                    object.seed = "";
                else {
                    object.seed = [];
                    if (options.bytes !== Array)
                        object.seed = $util.newBuffer(object.seed);
                }
            }
            if (message.iteration != null && message.hasOwnProperty("iteration"))
                object.iteration = message.iteration;
            if (message.seed != null && message.hasOwnProperty("seed"))
                object.seed = options.bytes === String ? $util.base64.encode(message.seed, 0, message.seed.length) : options.bytes === Array ? Array.prototype.slice.call(message.seed) : message.seed;
            return object;
        };

        /**
         * Converts this SenderMessageKey to JSON.
         * @function toJSON
         * @memberof Message.SenderMessageKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SenderMessageKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SenderMessageKey;
    })();

    Message.SenderSigningKey = (function() {

        /**
         * Properties of a SenderSigningKey.
         * @memberof Message
         * @interface ISenderSigningKey
         * @property {Uint8Array|null} ["public"] SenderSigningKey public
         * @property {Uint8Array|null} ["private"] SenderSigningKey private
         */

        /**
         * Constructs a new SenderSigningKey.
         * @memberof Message
         * @classdesc Represents a SenderSigningKey.
         * @implements ISenderSigningKey
         * @constructor
         * @param {Message.ISenderSigningKey=} [properties] Properties to set
         */
        function SenderSigningKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SenderSigningKey public.
         * @member {Uint8Array} public
         * @memberof Message.SenderSigningKey
         * @instance
         */
        SenderSigningKey.prototype["public"] = $util.newBuffer([]);

        /**
         * SenderSigningKey private.
         * @member {Uint8Array} private
         * @memberof Message.SenderSigningKey
         * @instance
         */
        SenderSigningKey.prototype["private"] = $util.newBuffer([]);

        /**
         * Creates a new SenderSigningKey instance using the specified properties.
         * @function create
         * @memberof Message.SenderSigningKey
         * @static
         * @param {Message.ISenderSigningKey=} [properties] Properties to set
         * @returns {Message.SenderSigningKey} SenderSigningKey instance
         */
        SenderSigningKey.create = function create(properties) {
            return new SenderSigningKey(properties);
        };

        /**
         * Encodes the specified SenderSigningKey message. Does not implicitly {@link Message.SenderSigningKey.verify|verify} messages.
         * @function encode
         * @memberof Message.SenderSigningKey
         * @static
         * @param {Message.ISenderSigningKey} message SenderSigningKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderSigningKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message["public"] != null && Object.hasOwnProperty.call(message, "public"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message["public"]);
            if (message["private"] != null && Object.hasOwnProperty.call(message, "private"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message["private"]);
            return writer;
        };

        /**
         * Encodes the specified SenderSigningKey message, length delimited. Does not implicitly {@link Message.SenderSigningKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.SenderSigningKey
         * @static
         * @param {Message.ISenderSigningKey} message SenderSigningKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderSigningKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SenderSigningKey message from the specified reader or buffer.
         * @function decode
         * @memberof Message.SenderSigningKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.SenderSigningKey} SenderSigningKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderSigningKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.SenderSigningKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message["public"] = reader.bytes();
                    break;
                case 2:
                    message["private"] = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SenderSigningKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.SenderSigningKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.SenderSigningKey} SenderSigningKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderSigningKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SenderSigningKey message.
         * @function verify
         * @memberof Message.SenderSigningKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SenderSigningKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["public"] != null && message.hasOwnProperty("public"))
                if (!(message["public"] && typeof message["public"].length === "number" || $util.isString(message["public"])))
                    return "public: buffer expected";
            if (message["private"] != null && message.hasOwnProperty("private"))
                if (!(message["private"] && typeof message["private"].length === "number" || $util.isString(message["private"])))
                    return "private: buffer expected";
            return null;
        };

        /**
         * Creates a SenderSigningKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.SenderSigningKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.SenderSigningKey} SenderSigningKey
         */
        SenderSigningKey.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.SenderSigningKey)
                return object;
            var message = new $root.Message.SenderSigningKey();
            if (object["public"] != null)
                if (typeof object["public"] === "string")
                    $util.base64.decode(object["public"], message["public"] = $util.newBuffer($util.base64.length(object["public"])), 0);
                else if (object["public"].length)
                    message["public"] = object["public"];
            if (object["private"] != null)
                if (typeof object["private"] === "string")
                    $util.base64.decode(object["private"], message["private"] = $util.newBuffer($util.base64.length(object["private"])), 0);
                else if (object["private"].length)
                    message["private"] = object["private"];
            return message;
        };

        /**
         * Creates a plain object from a SenderSigningKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.SenderSigningKey
         * @static
         * @param {Message.SenderSigningKey} message SenderSigningKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SenderSigningKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object["public"] = "";
                else {
                    object["public"] = [];
                    if (options.bytes !== Array)
                        object["public"] = $util.newBuffer(object["public"]);
                }
                if (options.bytes === String)
                    object["private"] = "";
                else {
                    object["private"] = [];
                    if (options.bytes !== Array)
                        object["private"] = $util.newBuffer(object["private"]);
                }
            }
            if (message["public"] != null && message.hasOwnProperty("public"))
                object["public"] = options.bytes === String ? $util.base64.encode(message["public"], 0, message["public"].length) : options.bytes === Array ? Array.prototype.slice.call(message["public"]) : message["public"];
            if (message["private"] != null && message.hasOwnProperty("private"))
                object["private"] = options.bytes === String ? $util.base64.encode(message["private"], 0, message["private"].length) : options.bytes === Array ? Array.prototype.slice.call(message["private"]) : message["private"];
            return object;
        };

        /**
         * Converts this SenderSigningKey to JSON.
         * @function toJSON
         * @memberof Message.SenderSigningKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SenderSigningKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SenderSigningKey;
    })();

    Message.SenderKeyStateStructure = (function() {

        /**
         * Properties of a SenderKeyStateStructure.
         * @memberof Message
         * @interface ISenderKeyStateStructure
         * @property {number|null} [senderKeyId] SenderKeyStateStructure senderKeyId
         * @property {Message.ISenderChainKey|null} [senderChainKey] SenderKeyStateStructure senderChainKey
         * @property {Message.ISenderSigningKey|null} [senderSigningKey] SenderKeyStateStructure senderSigningKey
         * @property {Array.<Message.ISenderMessageKey>|null} [senderMessageKeys] SenderKeyStateStructure senderMessageKeys
         */

        /**
         * Constructs a new SenderKeyStateStructure.
         * @memberof Message
         * @classdesc Represents a SenderKeyStateStructure.
         * @implements ISenderKeyStateStructure
         * @constructor
         * @param {Message.ISenderKeyStateStructure=} [properties] Properties to set
         */
        function SenderKeyStateStructure(properties) {
            this.senderMessageKeys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SenderKeyStateStructure senderKeyId.
         * @member {number} senderKeyId
         * @memberof Message.SenderKeyStateStructure
         * @instance
         */
        SenderKeyStateStructure.prototype.senderKeyId = 0;

        /**
         * SenderKeyStateStructure senderChainKey.
         * @member {Message.ISenderChainKey|null|undefined} senderChainKey
         * @memberof Message.SenderKeyStateStructure
         * @instance
         */
        SenderKeyStateStructure.prototype.senderChainKey = null;

        /**
         * SenderKeyStateStructure senderSigningKey.
         * @member {Message.ISenderSigningKey|null|undefined} senderSigningKey
         * @memberof Message.SenderKeyStateStructure
         * @instance
         */
        SenderKeyStateStructure.prototype.senderSigningKey = null;

        /**
         * SenderKeyStateStructure senderMessageKeys.
         * @member {Array.<Message.ISenderMessageKey>} senderMessageKeys
         * @memberof Message.SenderKeyStateStructure
         * @instance
         */
        SenderKeyStateStructure.prototype.senderMessageKeys = $util.emptyArray;

        /**
         * Creates a new SenderKeyStateStructure instance using the specified properties.
         * @function create
         * @memberof Message.SenderKeyStateStructure
         * @static
         * @param {Message.ISenderKeyStateStructure=} [properties] Properties to set
         * @returns {Message.SenderKeyStateStructure} SenderKeyStateStructure instance
         */
        SenderKeyStateStructure.create = function create(properties) {
            return new SenderKeyStateStructure(properties);
        };

        /**
         * Encodes the specified SenderKeyStateStructure message. Does not implicitly {@link Message.SenderKeyStateStructure.verify|verify} messages.
         * @function encode
         * @memberof Message.SenderKeyStateStructure
         * @static
         * @param {Message.ISenderKeyStateStructure} message SenderKeyStateStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderKeyStateStructure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.senderKeyId != null && Object.hasOwnProperty.call(message, "senderKeyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.senderKeyId);
            if (message.senderChainKey != null && Object.hasOwnProperty.call(message, "senderChainKey"))
                $root.Message.SenderChainKey.encode(message.senderChainKey, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.senderSigningKey != null && Object.hasOwnProperty.call(message, "senderSigningKey"))
                $root.Message.SenderSigningKey.encode(message.senderSigningKey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.senderMessageKeys != null && message.senderMessageKeys.length)
                for (var i = 0; i < message.senderMessageKeys.length; ++i)
                    $root.Message.SenderMessageKey.encode(message.senderMessageKeys[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SenderKeyStateStructure message, length delimited. Does not implicitly {@link Message.SenderKeyStateStructure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.SenderKeyStateStructure
         * @static
         * @param {Message.ISenderKeyStateStructure} message SenderKeyStateStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderKeyStateStructure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SenderKeyStateStructure message from the specified reader or buffer.
         * @function decode
         * @memberof Message.SenderKeyStateStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.SenderKeyStateStructure} SenderKeyStateStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderKeyStateStructure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.SenderKeyStateStructure();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.senderKeyId = reader.uint32();
                    break;
                case 2:
                    message.senderChainKey = $root.Message.SenderChainKey.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.senderSigningKey = $root.Message.SenderSigningKey.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.senderMessageKeys && message.senderMessageKeys.length))
                        message.senderMessageKeys = [];
                    message.senderMessageKeys.push($root.Message.SenderMessageKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SenderKeyStateStructure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.SenderKeyStateStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.SenderKeyStateStructure} SenderKeyStateStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderKeyStateStructure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SenderKeyStateStructure message.
         * @function verify
         * @memberof Message.SenderKeyStateStructure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SenderKeyStateStructure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.senderKeyId != null && message.hasOwnProperty("senderKeyId"))
                if (!$util.isInteger(message.senderKeyId))
                    return "senderKeyId: integer expected";
            if (message.senderChainKey != null && message.hasOwnProperty("senderChainKey")) {
                var error = $root.Message.SenderChainKey.verify(message.senderChainKey);
                if (error)
                    return "senderChainKey." + error;
            }
            if (message.senderSigningKey != null && message.hasOwnProperty("senderSigningKey")) {
                var error = $root.Message.SenderSigningKey.verify(message.senderSigningKey);
                if (error)
                    return "senderSigningKey." + error;
            }
            if (message.senderMessageKeys != null && message.hasOwnProperty("senderMessageKeys")) {
                if (!Array.isArray(message.senderMessageKeys))
                    return "senderMessageKeys: array expected";
                for (var i = 0; i < message.senderMessageKeys.length; ++i) {
                    var error = $root.Message.SenderMessageKey.verify(message.senderMessageKeys[i]);
                    if (error)
                        return "senderMessageKeys." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SenderKeyStateStructure message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.SenderKeyStateStructure
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.SenderKeyStateStructure} SenderKeyStateStructure
         */
        SenderKeyStateStructure.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.SenderKeyStateStructure)
                return object;
            var message = new $root.Message.SenderKeyStateStructure();
            if (object.senderKeyId != null)
                message.senderKeyId = object.senderKeyId >>> 0;
            if (object.senderChainKey != null) {
                if (typeof object.senderChainKey !== "object")
                    throw TypeError(".Message.SenderKeyStateStructure.senderChainKey: object expected");
                message.senderChainKey = $root.Message.SenderChainKey.fromObject(object.senderChainKey);
            }
            if (object.senderSigningKey != null) {
                if (typeof object.senderSigningKey !== "object")
                    throw TypeError(".Message.SenderKeyStateStructure.senderSigningKey: object expected");
                message.senderSigningKey = $root.Message.SenderSigningKey.fromObject(object.senderSigningKey);
            }
            if (object.senderMessageKeys) {
                if (!Array.isArray(object.senderMessageKeys))
                    throw TypeError(".Message.SenderKeyStateStructure.senderMessageKeys: array expected");
                message.senderMessageKeys = [];
                for (var i = 0; i < object.senderMessageKeys.length; ++i) {
                    if (typeof object.senderMessageKeys[i] !== "object")
                        throw TypeError(".Message.SenderKeyStateStructure.senderMessageKeys: object expected");
                    message.senderMessageKeys[i] = $root.Message.SenderMessageKey.fromObject(object.senderMessageKeys[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SenderKeyStateStructure message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.SenderKeyStateStructure
         * @static
         * @param {Message.SenderKeyStateStructure} message SenderKeyStateStructure
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SenderKeyStateStructure.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.senderMessageKeys = [];
            if (options.defaults) {
                object.senderKeyId = 0;
                object.senderChainKey = null;
                object.senderSigningKey = null;
            }
            if (message.senderKeyId != null && message.hasOwnProperty("senderKeyId"))
                object.senderKeyId = message.senderKeyId;
            if (message.senderChainKey != null && message.hasOwnProperty("senderChainKey"))
                object.senderChainKey = $root.Message.SenderChainKey.toObject(message.senderChainKey, options);
            if (message.senderSigningKey != null && message.hasOwnProperty("senderSigningKey"))
                object.senderSigningKey = $root.Message.SenderSigningKey.toObject(message.senderSigningKey, options);
            if (message.senderMessageKeys && message.senderMessageKeys.length) {
                object.senderMessageKeys = [];
                for (var j = 0; j < message.senderMessageKeys.length; ++j)
                    object.senderMessageKeys[j] = $root.Message.SenderMessageKey.toObject(message.senderMessageKeys[j], options);
            }
            return object;
        };

        /**
         * Converts this SenderKeyStateStructure to JSON.
         * @function toJSON
         * @memberof Message.SenderKeyStateStructure
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SenderKeyStateStructure.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SenderKeyStateStructure;
    })();

    Message.SenderKeyRecordStructure = (function() {

        /**
         * Properties of a SenderKeyRecordStructure.
         * @memberof Message
         * @interface ISenderKeyRecordStructure
         * @property {Array.<Message.ISenderKeyStateStructure>|null} [senderKeyStates] SenderKeyRecordStructure senderKeyStates
         */

        /**
         * Constructs a new SenderKeyRecordStructure.
         * @memberof Message
         * @classdesc Represents a SenderKeyRecordStructure.
         * @implements ISenderKeyRecordStructure
         * @constructor
         * @param {Message.ISenderKeyRecordStructure=} [properties] Properties to set
         */
        function SenderKeyRecordStructure(properties) {
            this.senderKeyStates = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SenderKeyRecordStructure senderKeyStates.
         * @member {Array.<Message.ISenderKeyStateStructure>} senderKeyStates
         * @memberof Message.SenderKeyRecordStructure
         * @instance
         */
        SenderKeyRecordStructure.prototype.senderKeyStates = $util.emptyArray;

        /**
         * Creates a new SenderKeyRecordStructure instance using the specified properties.
         * @function create
         * @memberof Message.SenderKeyRecordStructure
         * @static
         * @param {Message.ISenderKeyRecordStructure=} [properties] Properties to set
         * @returns {Message.SenderKeyRecordStructure} SenderKeyRecordStructure instance
         */
        SenderKeyRecordStructure.create = function create(properties) {
            return new SenderKeyRecordStructure(properties);
        };

        /**
         * Encodes the specified SenderKeyRecordStructure message. Does not implicitly {@link Message.SenderKeyRecordStructure.verify|verify} messages.
         * @function encode
         * @memberof Message.SenderKeyRecordStructure
         * @static
         * @param {Message.ISenderKeyRecordStructure} message SenderKeyRecordStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderKeyRecordStructure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.senderKeyStates != null && message.senderKeyStates.length)
                for (var i = 0; i < message.senderKeyStates.length; ++i)
                    $root.Message.SenderKeyStateStructure.encode(message.senderKeyStates[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SenderKeyRecordStructure message, length delimited. Does not implicitly {@link Message.SenderKeyRecordStructure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.SenderKeyRecordStructure
         * @static
         * @param {Message.ISenderKeyRecordStructure} message SenderKeyRecordStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderKeyRecordStructure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SenderKeyRecordStructure message from the specified reader or buffer.
         * @function decode
         * @memberof Message.SenderKeyRecordStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.SenderKeyRecordStructure} SenderKeyRecordStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderKeyRecordStructure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.SenderKeyRecordStructure();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.senderKeyStates && message.senderKeyStates.length))
                        message.senderKeyStates = [];
                    message.senderKeyStates.push($root.Message.SenderKeyStateStructure.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SenderKeyRecordStructure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.SenderKeyRecordStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.SenderKeyRecordStructure} SenderKeyRecordStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderKeyRecordStructure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SenderKeyRecordStructure message.
         * @function verify
         * @memberof Message.SenderKeyRecordStructure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SenderKeyRecordStructure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.senderKeyStates != null && message.hasOwnProperty("senderKeyStates")) {
                if (!Array.isArray(message.senderKeyStates))
                    return "senderKeyStates: array expected";
                for (var i = 0; i < message.senderKeyStates.length; ++i) {
                    var error = $root.Message.SenderKeyStateStructure.verify(message.senderKeyStates[i]);
                    if (error)
                        return "senderKeyStates." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SenderKeyRecordStructure message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.SenderKeyRecordStructure
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.SenderKeyRecordStructure} SenderKeyRecordStructure
         */
        SenderKeyRecordStructure.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.SenderKeyRecordStructure)
                return object;
            var message = new $root.Message.SenderKeyRecordStructure();
            if (object.senderKeyStates) {
                if (!Array.isArray(object.senderKeyStates))
                    throw TypeError(".Message.SenderKeyRecordStructure.senderKeyStates: array expected");
                message.senderKeyStates = [];
                for (var i = 0; i < object.senderKeyStates.length; ++i) {
                    if (typeof object.senderKeyStates[i] !== "object")
                        throw TypeError(".Message.SenderKeyRecordStructure.senderKeyStates: object expected");
                    message.senderKeyStates[i] = $root.Message.SenderKeyStateStructure.fromObject(object.senderKeyStates[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SenderKeyRecordStructure message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.SenderKeyRecordStructure
         * @static
         * @param {Message.SenderKeyRecordStructure} message SenderKeyRecordStructure
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SenderKeyRecordStructure.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.senderKeyStates = [];
            if (message.senderKeyStates && message.senderKeyStates.length) {
                object.senderKeyStates = [];
                for (var j = 0; j < message.senderKeyStates.length; ++j)
                    object.senderKeyStates[j] = $root.Message.SenderKeyStateStructure.toObject(message.senderKeyStates[j], options);
            }
            return object;
        };

        /**
         * Converts this SenderKeyRecordStructure to JSON.
         * @function toJSON
         * @memberof Message.SenderKeyRecordStructure
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SenderKeyRecordStructure.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SenderKeyRecordStructure;
    })();

    Message.HydratedQuickReplyButton = (function() {

        /**
         * Properties of a HydratedQuickReplyButton.
         * @memberof Message
         * @interface IHydratedQuickReplyButton
         * @property {string|null} [displayText] HydratedQuickReplyButton displayText
         * @property {string|null} [id] HydratedQuickReplyButton id
         */

        /**
         * Constructs a new HydratedQuickReplyButton.
         * @memberof Message
         * @classdesc Represents a HydratedQuickReplyButton.
         * @implements IHydratedQuickReplyButton
         * @constructor
         * @param {Message.IHydratedQuickReplyButton=} [properties] Properties to set
         */
        function HydratedQuickReplyButton(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HydratedQuickReplyButton displayText.
         * @member {string} displayText
         * @memberof Message.HydratedQuickReplyButton
         * @instance
         */
        HydratedQuickReplyButton.prototype.displayText = "";

        /**
         * HydratedQuickReplyButton id.
         * @member {string} id
         * @memberof Message.HydratedQuickReplyButton
         * @instance
         */
        HydratedQuickReplyButton.prototype.id = "";

        /**
         * Creates a new HydratedQuickReplyButton instance using the specified properties.
         * @function create
         * @memberof Message.HydratedQuickReplyButton
         * @static
         * @param {Message.IHydratedQuickReplyButton=} [properties] Properties to set
         * @returns {Message.HydratedQuickReplyButton} HydratedQuickReplyButton instance
         */
        HydratedQuickReplyButton.create = function create(properties) {
            return new HydratedQuickReplyButton(properties);
        };

        /**
         * Encodes the specified HydratedQuickReplyButton message. Does not implicitly {@link Message.HydratedQuickReplyButton.verify|verify} messages.
         * @function encode
         * @memberof Message.HydratedQuickReplyButton
         * @static
         * @param {Message.IHydratedQuickReplyButton} message HydratedQuickReplyButton message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HydratedQuickReplyButton.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.displayText != null && Object.hasOwnProperty.call(message, "displayText"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.displayText);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            return writer;
        };

        /**
         * Encodes the specified HydratedQuickReplyButton message, length delimited. Does not implicitly {@link Message.HydratedQuickReplyButton.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.HydratedQuickReplyButton
         * @static
         * @param {Message.IHydratedQuickReplyButton} message HydratedQuickReplyButton message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HydratedQuickReplyButton.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HydratedQuickReplyButton message from the specified reader or buffer.
         * @function decode
         * @memberof Message.HydratedQuickReplyButton
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.HydratedQuickReplyButton} HydratedQuickReplyButton
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HydratedQuickReplyButton.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.HydratedQuickReplyButton();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.displayText = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HydratedQuickReplyButton message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.HydratedQuickReplyButton
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.HydratedQuickReplyButton} HydratedQuickReplyButton
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HydratedQuickReplyButton.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HydratedQuickReplyButton message.
         * @function verify
         * @memberof Message.HydratedQuickReplyButton
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HydratedQuickReplyButton.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.displayText != null && message.hasOwnProperty("displayText"))
                if (!$util.isString(message.displayText))
                    return "displayText: string expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        /**
         * Creates a HydratedQuickReplyButton message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.HydratedQuickReplyButton
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.HydratedQuickReplyButton} HydratedQuickReplyButton
         */
        HydratedQuickReplyButton.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.HydratedQuickReplyButton)
                return object;
            var message = new $root.Message.HydratedQuickReplyButton();
            if (object.displayText != null)
                message.displayText = String(object.displayText);
            if (object.id != null)
                message.id = String(object.id);
            return message;
        };

        /**
         * Creates a plain object from a HydratedQuickReplyButton message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.HydratedQuickReplyButton
         * @static
         * @param {Message.HydratedQuickReplyButton} message HydratedQuickReplyButton
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HydratedQuickReplyButton.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.displayText = "";
                object.id = "";
            }
            if (message.displayText != null && message.hasOwnProperty("displayText"))
                object.displayText = message.displayText;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this HydratedQuickReplyButton to JSON.
         * @function toJSON
         * @memberof Message.HydratedQuickReplyButton
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HydratedQuickReplyButton.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HydratedQuickReplyButton;
    })();

    Message.HydratedURLButton = (function() {

        /**
         * Properties of a HydratedURLButton.
         * @memberof Message
         * @interface IHydratedURLButton
         * @property {string|null} [displayText] HydratedURLButton displayText
         * @property {string|null} [url] HydratedURLButton url
         */

        /**
         * Constructs a new HydratedURLButton.
         * @memberof Message
         * @classdesc Represents a HydratedURLButton.
         * @implements IHydratedURLButton
         * @constructor
         * @param {Message.IHydratedURLButton=} [properties] Properties to set
         */
        function HydratedURLButton(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HydratedURLButton displayText.
         * @member {string} displayText
         * @memberof Message.HydratedURLButton
         * @instance
         */
        HydratedURLButton.prototype.displayText = "";

        /**
         * HydratedURLButton url.
         * @member {string} url
         * @memberof Message.HydratedURLButton
         * @instance
         */
        HydratedURLButton.prototype.url = "";

        /**
         * Creates a new HydratedURLButton instance using the specified properties.
         * @function create
         * @memberof Message.HydratedURLButton
         * @static
         * @param {Message.IHydratedURLButton=} [properties] Properties to set
         * @returns {Message.HydratedURLButton} HydratedURLButton instance
         */
        HydratedURLButton.create = function create(properties) {
            return new HydratedURLButton(properties);
        };

        /**
         * Encodes the specified HydratedURLButton message. Does not implicitly {@link Message.HydratedURLButton.verify|verify} messages.
         * @function encode
         * @memberof Message.HydratedURLButton
         * @static
         * @param {Message.IHydratedURLButton} message HydratedURLButton message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HydratedURLButton.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.displayText != null && Object.hasOwnProperty.call(message, "displayText"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.displayText);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
            return writer;
        };

        /**
         * Encodes the specified HydratedURLButton message, length delimited. Does not implicitly {@link Message.HydratedURLButton.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.HydratedURLButton
         * @static
         * @param {Message.IHydratedURLButton} message HydratedURLButton message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HydratedURLButton.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HydratedURLButton message from the specified reader or buffer.
         * @function decode
         * @memberof Message.HydratedURLButton
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.HydratedURLButton} HydratedURLButton
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HydratedURLButton.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.HydratedURLButton();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.displayText = reader.string();
                    break;
                case 2:
                    message.url = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HydratedURLButton message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.HydratedURLButton
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.HydratedURLButton} HydratedURLButton
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HydratedURLButton.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HydratedURLButton message.
         * @function verify
         * @memberof Message.HydratedURLButton
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HydratedURLButton.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.displayText != null && message.hasOwnProperty("displayText"))
                if (!$util.isString(message.displayText))
                    return "displayText: string expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            return null;
        };

        /**
         * Creates a HydratedURLButton message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.HydratedURLButton
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.HydratedURLButton} HydratedURLButton
         */
        HydratedURLButton.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.HydratedURLButton)
                return object;
            var message = new $root.Message.HydratedURLButton();
            if (object.displayText != null)
                message.displayText = String(object.displayText);
            if (object.url != null)
                message.url = String(object.url);
            return message;
        };

        /**
         * Creates a plain object from a HydratedURLButton message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.HydratedURLButton
         * @static
         * @param {Message.HydratedURLButton} message HydratedURLButton
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HydratedURLButton.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.displayText = "";
                object.url = "";
            }
            if (message.displayText != null && message.hasOwnProperty("displayText"))
                object.displayText = message.displayText;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            return object;
        };

        /**
         * Converts this HydratedURLButton to JSON.
         * @function toJSON
         * @memberof Message.HydratedURLButton
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HydratedURLButton.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HydratedURLButton;
    })();

    Message.HydratedCallButton = (function() {

        /**
         * Properties of a HydratedCallButton.
         * @memberof Message
         * @interface IHydratedCallButton
         * @property {string|null} [displayText] HydratedCallButton displayText
         * @property {string|null} [phoneNumber] HydratedCallButton phoneNumber
         */

        /**
         * Constructs a new HydratedCallButton.
         * @memberof Message
         * @classdesc Represents a HydratedCallButton.
         * @implements IHydratedCallButton
         * @constructor
         * @param {Message.IHydratedCallButton=} [properties] Properties to set
         */
        function HydratedCallButton(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HydratedCallButton displayText.
         * @member {string} displayText
         * @memberof Message.HydratedCallButton
         * @instance
         */
        HydratedCallButton.prototype.displayText = "";

        /**
         * HydratedCallButton phoneNumber.
         * @member {string} phoneNumber
         * @memberof Message.HydratedCallButton
         * @instance
         */
        HydratedCallButton.prototype.phoneNumber = "";

        /**
         * Creates a new HydratedCallButton instance using the specified properties.
         * @function create
         * @memberof Message.HydratedCallButton
         * @static
         * @param {Message.IHydratedCallButton=} [properties] Properties to set
         * @returns {Message.HydratedCallButton} HydratedCallButton instance
         */
        HydratedCallButton.create = function create(properties) {
            return new HydratedCallButton(properties);
        };

        /**
         * Encodes the specified HydratedCallButton message. Does not implicitly {@link Message.HydratedCallButton.verify|verify} messages.
         * @function encode
         * @memberof Message.HydratedCallButton
         * @static
         * @param {Message.IHydratedCallButton} message HydratedCallButton message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HydratedCallButton.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.displayText != null && Object.hasOwnProperty.call(message, "displayText"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.displayText);
            if (message.phoneNumber != null && Object.hasOwnProperty.call(message, "phoneNumber"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.phoneNumber);
            return writer;
        };

        /**
         * Encodes the specified HydratedCallButton message, length delimited. Does not implicitly {@link Message.HydratedCallButton.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.HydratedCallButton
         * @static
         * @param {Message.IHydratedCallButton} message HydratedCallButton message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HydratedCallButton.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HydratedCallButton message from the specified reader or buffer.
         * @function decode
         * @memberof Message.HydratedCallButton
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.HydratedCallButton} HydratedCallButton
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HydratedCallButton.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.HydratedCallButton();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.displayText = reader.string();
                    break;
                case 2:
                    message.phoneNumber = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HydratedCallButton message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.HydratedCallButton
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.HydratedCallButton} HydratedCallButton
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HydratedCallButton.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HydratedCallButton message.
         * @function verify
         * @memberof Message.HydratedCallButton
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HydratedCallButton.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.displayText != null && message.hasOwnProperty("displayText"))
                if (!$util.isString(message.displayText))
                    return "displayText: string expected";
            if (message.phoneNumber != null && message.hasOwnProperty("phoneNumber"))
                if (!$util.isString(message.phoneNumber))
                    return "phoneNumber: string expected";
            return null;
        };

        /**
         * Creates a HydratedCallButton message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.HydratedCallButton
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.HydratedCallButton} HydratedCallButton
         */
        HydratedCallButton.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.HydratedCallButton)
                return object;
            var message = new $root.Message.HydratedCallButton();
            if (object.displayText != null)
                message.displayText = String(object.displayText);
            if (object.phoneNumber != null)
                message.phoneNumber = String(object.phoneNumber);
            return message;
        };

        /**
         * Creates a plain object from a HydratedCallButton message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.HydratedCallButton
         * @static
         * @param {Message.HydratedCallButton} message HydratedCallButton
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HydratedCallButton.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.displayText = "";
                object.phoneNumber = "";
            }
            if (message.displayText != null && message.hasOwnProperty("displayText"))
                object.displayText = message.displayText;
            if (message.phoneNumber != null && message.hasOwnProperty("phoneNumber"))
                object.phoneNumber = message.phoneNumber;
            return object;
        };

        /**
         * Converts this HydratedCallButton to JSON.
         * @function toJSON
         * @memberof Message.HydratedCallButton
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HydratedCallButton.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HydratedCallButton;
    })();

    Message.HydratedTemplateButton = (function() {

        /**
         * Properties of a HydratedTemplateButton.
         * @memberof Message
         * @interface IHydratedTemplateButton
         * @property {number|null} [index] HydratedTemplateButton index
         * @property {Message.IHydratedQuickReplyButton|null} [quickReplyButton] HydratedTemplateButton quickReplyButton
         * @property {Message.IHydratedURLButton|null} [urlButton] HydratedTemplateButton urlButton
         * @property {Message.IHydratedCallButton|null} [callButton] HydratedTemplateButton callButton
         */

        /**
         * Constructs a new HydratedTemplateButton.
         * @memberof Message
         * @classdesc Represents a HydratedTemplateButton.
         * @implements IHydratedTemplateButton
         * @constructor
         * @param {Message.IHydratedTemplateButton=} [properties] Properties to set
         */
        function HydratedTemplateButton(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HydratedTemplateButton index.
         * @member {number} index
         * @memberof Message.HydratedTemplateButton
         * @instance
         */
        HydratedTemplateButton.prototype.index = 0;

        /**
         * HydratedTemplateButton quickReplyButton.
         * @member {Message.IHydratedQuickReplyButton|null|undefined} quickReplyButton
         * @memberof Message.HydratedTemplateButton
         * @instance
         */
        HydratedTemplateButton.prototype.quickReplyButton = null;

        /**
         * HydratedTemplateButton urlButton.
         * @member {Message.IHydratedURLButton|null|undefined} urlButton
         * @memberof Message.HydratedTemplateButton
         * @instance
         */
        HydratedTemplateButton.prototype.urlButton = null;

        /**
         * HydratedTemplateButton callButton.
         * @member {Message.IHydratedCallButton|null|undefined} callButton
         * @memberof Message.HydratedTemplateButton
         * @instance
         */
        HydratedTemplateButton.prototype.callButton = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * HydratedTemplateButton hydratedButton.
         * @member {"quickReplyButton"|"urlButton"|"callButton"|undefined} hydratedButton
         * @memberof Message.HydratedTemplateButton
         * @instance
         */
        Object.defineProperty(HydratedTemplateButton.prototype, "hydratedButton", {
            get: $util.oneOfGetter($oneOfFields = ["quickReplyButton", "urlButton", "callButton"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new HydratedTemplateButton instance using the specified properties.
         * @function create
         * @memberof Message.HydratedTemplateButton
         * @static
         * @param {Message.IHydratedTemplateButton=} [properties] Properties to set
         * @returns {Message.HydratedTemplateButton} HydratedTemplateButton instance
         */
        HydratedTemplateButton.create = function create(properties) {
            return new HydratedTemplateButton(properties);
        };

        /**
         * Encodes the specified HydratedTemplateButton message. Does not implicitly {@link Message.HydratedTemplateButton.verify|verify} messages.
         * @function encode
         * @memberof Message.HydratedTemplateButton
         * @static
         * @param {Message.IHydratedTemplateButton} message HydratedTemplateButton message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HydratedTemplateButton.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.quickReplyButton != null && Object.hasOwnProperty.call(message, "quickReplyButton"))
                $root.Message.HydratedQuickReplyButton.encode(message.quickReplyButton, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.urlButton != null && Object.hasOwnProperty.call(message, "urlButton"))
                $root.Message.HydratedURLButton.encode(message.urlButton, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.callButton != null && Object.hasOwnProperty.call(message, "callButton"))
                $root.Message.HydratedCallButton.encode(message.callButton, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.index);
            return writer;
        };

        /**
         * Encodes the specified HydratedTemplateButton message, length delimited. Does not implicitly {@link Message.HydratedTemplateButton.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.HydratedTemplateButton
         * @static
         * @param {Message.IHydratedTemplateButton} message HydratedTemplateButton message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HydratedTemplateButton.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HydratedTemplateButton message from the specified reader or buffer.
         * @function decode
         * @memberof Message.HydratedTemplateButton
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.HydratedTemplateButton} HydratedTemplateButton
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HydratedTemplateButton.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.HydratedTemplateButton();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 4:
                    message.index = reader.uint32();
                    break;
                case 1:
                    message.quickReplyButton = $root.Message.HydratedQuickReplyButton.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.urlButton = $root.Message.HydratedURLButton.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.callButton = $root.Message.HydratedCallButton.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HydratedTemplateButton message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.HydratedTemplateButton
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.HydratedTemplateButton} HydratedTemplateButton
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HydratedTemplateButton.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HydratedTemplateButton message.
         * @function verify
         * @memberof Message.HydratedTemplateButton
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HydratedTemplateButton.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.quickReplyButton != null && message.hasOwnProperty("quickReplyButton")) {
                properties.hydratedButton = 1;
                {
                    var error = $root.Message.HydratedQuickReplyButton.verify(message.quickReplyButton);
                    if (error)
                        return "quickReplyButton." + error;
                }
            }
            if (message.urlButton != null && message.hasOwnProperty("urlButton")) {
                if (properties.hydratedButton === 1)
                    return "hydratedButton: multiple values";
                properties.hydratedButton = 1;
                {
                    var error = $root.Message.HydratedURLButton.verify(message.urlButton);
                    if (error)
                        return "urlButton." + error;
                }
            }
            if (message.callButton != null && message.hasOwnProperty("callButton")) {
                if (properties.hydratedButton === 1)
                    return "hydratedButton: multiple values";
                properties.hydratedButton = 1;
                {
                    var error = $root.Message.HydratedCallButton.verify(message.callButton);
                    if (error)
                        return "callButton." + error;
                }
            }
            return null;
        };

        /**
         * Creates a HydratedTemplateButton message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.HydratedTemplateButton
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.HydratedTemplateButton} HydratedTemplateButton
         */
        HydratedTemplateButton.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.HydratedTemplateButton)
                return object;
            var message = new $root.Message.HydratedTemplateButton();
            if (object.index != null)
                message.index = object.index >>> 0;
            if (object.quickReplyButton != null) {
                if (typeof object.quickReplyButton !== "object")
                    throw TypeError(".Message.HydratedTemplateButton.quickReplyButton: object expected");
                message.quickReplyButton = $root.Message.HydratedQuickReplyButton.fromObject(object.quickReplyButton);
            }
            if (object.urlButton != null) {
                if (typeof object.urlButton !== "object")
                    throw TypeError(".Message.HydratedTemplateButton.urlButton: object expected");
                message.urlButton = $root.Message.HydratedURLButton.fromObject(object.urlButton);
            }
            if (object.callButton != null) {
                if (typeof object.callButton !== "object")
                    throw TypeError(".Message.HydratedTemplateButton.callButton: object expected");
                message.callButton = $root.Message.HydratedCallButton.fromObject(object.callButton);
            }
            return message;
        };

        /**
         * Creates a plain object from a HydratedTemplateButton message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.HydratedTemplateButton
         * @static
         * @param {Message.HydratedTemplateButton} message HydratedTemplateButton
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HydratedTemplateButton.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.index = 0;
            if (message.quickReplyButton != null && message.hasOwnProperty("quickReplyButton")) {
                object.quickReplyButton = $root.Message.HydratedQuickReplyButton.toObject(message.quickReplyButton, options);
                if (options.oneofs)
                    object.hydratedButton = "quickReplyButton";
            }
            if (message.urlButton != null && message.hasOwnProperty("urlButton")) {
                object.urlButton = $root.Message.HydratedURLButton.toObject(message.urlButton, options);
                if (options.oneofs)
                    object.hydratedButton = "urlButton";
            }
            if (message.callButton != null && message.hasOwnProperty("callButton")) {
                object.callButton = $root.Message.HydratedCallButton.toObject(message.callButton, options);
                if (options.oneofs)
                    object.hydratedButton = "callButton";
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };

        /**
         * Converts this HydratedTemplateButton to JSON.
         * @function toJSON
         * @memberof Message.HydratedTemplateButton
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HydratedTemplateButton.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HydratedTemplateButton;
    })();

    Message.QuickReplyButton = (function() {

        /**
         * Properties of a QuickReplyButton.
         * @memberof Message
         * @interface IQuickReplyButton
         * @property {Message.IHighlyStructuredMessage|null} [displayText] QuickReplyButton displayText
         * @property {string|null} [id] QuickReplyButton id
         */

        /**
         * Constructs a new QuickReplyButton.
         * @memberof Message
         * @classdesc Represents a QuickReplyButton.
         * @implements IQuickReplyButton
         * @constructor
         * @param {Message.IQuickReplyButton=} [properties] Properties to set
         */
        function QuickReplyButton(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QuickReplyButton displayText.
         * @member {Message.IHighlyStructuredMessage|null|undefined} displayText
         * @memberof Message.QuickReplyButton
         * @instance
         */
        QuickReplyButton.prototype.displayText = null;

        /**
         * QuickReplyButton id.
         * @member {string} id
         * @memberof Message.QuickReplyButton
         * @instance
         */
        QuickReplyButton.prototype.id = "";

        /**
         * Creates a new QuickReplyButton instance using the specified properties.
         * @function create
         * @memberof Message.QuickReplyButton
         * @static
         * @param {Message.IQuickReplyButton=} [properties] Properties to set
         * @returns {Message.QuickReplyButton} QuickReplyButton instance
         */
        QuickReplyButton.create = function create(properties) {
            return new QuickReplyButton(properties);
        };

        /**
         * Encodes the specified QuickReplyButton message. Does not implicitly {@link Message.QuickReplyButton.verify|verify} messages.
         * @function encode
         * @memberof Message.QuickReplyButton
         * @static
         * @param {Message.IQuickReplyButton} message QuickReplyButton message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QuickReplyButton.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.displayText != null && Object.hasOwnProperty.call(message, "displayText"))
                $root.Message.HighlyStructuredMessage.encode(message.displayText, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            return writer;
        };

        /**
         * Encodes the specified QuickReplyButton message, length delimited. Does not implicitly {@link Message.QuickReplyButton.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.QuickReplyButton
         * @static
         * @param {Message.IQuickReplyButton} message QuickReplyButton message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QuickReplyButton.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QuickReplyButton message from the specified reader or buffer.
         * @function decode
         * @memberof Message.QuickReplyButton
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.QuickReplyButton} QuickReplyButton
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QuickReplyButton.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.QuickReplyButton();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.displayText = $root.Message.HighlyStructuredMessage.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QuickReplyButton message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.QuickReplyButton
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.QuickReplyButton} QuickReplyButton
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QuickReplyButton.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QuickReplyButton message.
         * @function verify
         * @memberof Message.QuickReplyButton
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QuickReplyButton.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.displayText != null && message.hasOwnProperty("displayText")) {
                var error = $root.Message.HighlyStructuredMessage.verify(message.displayText);
                if (error)
                    return "displayText." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        /**
         * Creates a QuickReplyButton message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.QuickReplyButton
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.QuickReplyButton} QuickReplyButton
         */
        QuickReplyButton.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.QuickReplyButton)
                return object;
            var message = new $root.Message.QuickReplyButton();
            if (object.displayText != null) {
                if (typeof object.displayText !== "object")
                    throw TypeError(".Message.QuickReplyButton.displayText: object expected");
                message.displayText = $root.Message.HighlyStructuredMessage.fromObject(object.displayText);
            }
            if (object.id != null)
                message.id = String(object.id);
            return message;
        };

        /**
         * Creates a plain object from a QuickReplyButton message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.QuickReplyButton
         * @static
         * @param {Message.QuickReplyButton} message QuickReplyButton
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QuickReplyButton.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.displayText = null;
                object.id = "";
            }
            if (message.displayText != null && message.hasOwnProperty("displayText"))
                object.displayText = $root.Message.HighlyStructuredMessage.toObject(message.displayText, options);
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this QuickReplyButton to JSON.
         * @function toJSON
         * @memberof Message.QuickReplyButton
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QuickReplyButton.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QuickReplyButton;
    })();

    Message.URLButton = (function() {

        /**
         * Properties of a URLButton.
         * @memberof Message
         * @interface IURLButton
         * @property {Message.IHighlyStructuredMessage|null} [displayText] URLButton displayText
         * @property {Message.IHighlyStructuredMessage|null} [url] URLButton url
         */

        /**
         * Constructs a new URLButton.
         * @memberof Message
         * @classdesc Represents a URLButton.
         * @implements IURLButton
         * @constructor
         * @param {Message.IURLButton=} [properties] Properties to set
         */
        function URLButton(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * URLButton displayText.
         * @member {Message.IHighlyStructuredMessage|null|undefined} displayText
         * @memberof Message.URLButton
         * @instance
         */
        URLButton.prototype.displayText = null;

        /**
         * URLButton url.
         * @member {Message.IHighlyStructuredMessage|null|undefined} url
         * @memberof Message.URLButton
         * @instance
         */
        URLButton.prototype.url = null;

        /**
         * Creates a new URLButton instance using the specified properties.
         * @function create
         * @memberof Message.URLButton
         * @static
         * @param {Message.IURLButton=} [properties] Properties to set
         * @returns {Message.URLButton} URLButton instance
         */
        URLButton.create = function create(properties) {
            return new URLButton(properties);
        };

        /**
         * Encodes the specified URLButton message. Does not implicitly {@link Message.URLButton.verify|verify} messages.
         * @function encode
         * @memberof Message.URLButton
         * @static
         * @param {Message.IURLButton} message URLButton message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        URLButton.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.displayText != null && Object.hasOwnProperty.call(message, "displayText"))
                $root.Message.HighlyStructuredMessage.encode(message.displayText, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                $root.Message.HighlyStructuredMessage.encode(message.url, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified URLButton message, length delimited. Does not implicitly {@link Message.URLButton.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.URLButton
         * @static
         * @param {Message.IURLButton} message URLButton message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        URLButton.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a URLButton message from the specified reader or buffer.
         * @function decode
         * @memberof Message.URLButton
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.URLButton} URLButton
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        URLButton.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.URLButton();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.displayText = $root.Message.HighlyStructuredMessage.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.url = $root.Message.HighlyStructuredMessage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a URLButton message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.URLButton
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.URLButton} URLButton
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        URLButton.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a URLButton message.
         * @function verify
         * @memberof Message.URLButton
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        URLButton.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.displayText != null && message.hasOwnProperty("displayText")) {
                var error = $root.Message.HighlyStructuredMessage.verify(message.displayText);
                if (error)
                    return "displayText." + error;
            }
            if (message.url != null && message.hasOwnProperty("url")) {
                var error = $root.Message.HighlyStructuredMessage.verify(message.url);
                if (error)
                    return "url." + error;
            }
            return null;
        };

        /**
         * Creates a URLButton message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.URLButton
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.URLButton} URLButton
         */
        URLButton.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.URLButton)
                return object;
            var message = new $root.Message.URLButton();
            if (object.displayText != null) {
                if (typeof object.displayText !== "object")
                    throw TypeError(".Message.URLButton.displayText: object expected");
                message.displayText = $root.Message.HighlyStructuredMessage.fromObject(object.displayText);
            }
            if (object.url != null) {
                if (typeof object.url !== "object")
                    throw TypeError(".Message.URLButton.url: object expected");
                message.url = $root.Message.HighlyStructuredMessage.fromObject(object.url);
            }
            return message;
        };

        /**
         * Creates a plain object from a URLButton message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.URLButton
         * @static
         * @param {Message.URLButton} message URLButton
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        URLButton.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.displayText = null;
                object.url = null;
            }
            if (message.displayText != null && message.hasOwnProperty("displayText"))
                object.displayText = $root.Message.HighlyStructuredMessage.toObject(message.displayText, options);
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = $root.Message.HighlyStructuredMessage.toObject(message.url, options);
            return object;
        };

        /**
         * Converts this URLButton to JSON.
         * @function toJSON
         * @memberof Message.URLButton
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        URLButton.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return URLButton;
    })();

    Message.CallButton = (function() {

        /**
         * Properties of a CallButton.
         * @memberof Message
         * @interface ICallButton
         * @property {Message.IHighlyStructuredMessage|null} [displayText] CallButton displayText
         * @property {Message.IHighlyStructuredMessage|null} [phoneNumber] CallButton phoneNumber
         */

        /**
         * Constructs a new CallButton.
         * @memberof Message
         * @classdesc Represents a CallButton.
         * @implements ICallButton
         * @constructor
         * @param {Message.ICallButton=} [properties] Properties to set
         */
        function CallButton(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CallButton displayText.
         * @member {Message.IHighlyStructuredMessage|null|undefined} displayText
         * @memberof Message.CallButton
         * @instance
         */
        CallButton.prototype.displayText = null;

        /**
         * CallButton phoneNumber.
         * @member {Message.IHighlyStructuredMessage|null|undefined} phoneNumber
         * @memberof Message.CallButton
         * @instance
         */
        CallButton.prototype.phoneNumber = null;

        /**
         * Creates a new CallButton instance using the specified properties.
         * @function create
         * @memberof Message.CallButton
         * @static
         * @param {Message.ICallButton=} [properties] Properties to set
         * @returns {Message.CallButton} CallButton instance
         */
        CallButton.create = function create(properties) {
            return new CallButton(properties);
        };

        /**
         * Encodes the specified CallButton message. Does not implicitly {@link Message.CallButton.verify|verify} messages.
         * @function encode
         * @memberof Message.CallButton
         * @static
         * @param {Message.ICallButton} message CallButton message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallButton.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.displayText != null && Object.hasOwnProperty.call(message, "displayText"))
                $root.Message.HighlyStructuredMessage.encode(message.displayText, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.phoneNumber != null && Object.hasOwnProperty.call(message, "phoneNumber"))
                $root.Message.HighlyStructuredMessage.encode(message.phoneNumber, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CallButton message, length delimited. Does not implicitly {@link Message.CallButton.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.CallButton
         * @static
         * @param {Message.ICallButton} message CallButton message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CallButton.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CallButton message from the specified reader or buffer.
         * @function decode
         * @memberof Message.CallButton
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.CallButton} CallButton
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallButton.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.CallButton();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.displayText = $root.Message.HighlyStructuredMessage.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.phoneNumber = $root.Message.HighlyStructuredMessage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CallButton message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.CallButton
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.CallButton} CallButton
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CallButton.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CallButton message.
         * @function verify
         * @memberof Message.CallButton
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CallButton.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.displayText != null && message.hasOwnProperty("displayText")) {
                var error = $root.Message.HighlyStructuredMessage.verify(message.displayText);
                if (error)
                    return "displayText." + error;
            }
            if (message.phoneNumber != null && message.hasOwnProperty("phoneNumber")) {
                var error = $root.Message.HighlyStructuredMessage.verify(message.phoneNumber);
                if (error)
                    return "phoneNumber." + error;
            }
            return null;
        };

        /**
         * Creates a CallButton message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.CallButton
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.CallButton} CallButton
         */
        CallButton.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.CallButton)
                return object;
            var message = new $root.Message.CallButton();
            if (object.displayText != null) {
                if (typeof object.displayText !== "object")
                    throw TypeError(".Message.CallButton.displayText: object expected");
                message.displayText = $root.Message.HighlyStructuredMessage.fromObject(object.displayText);
            }
            if (object.phoneNumber != null) {
                if (typeof object.phoneNumber !== "object")
                    throw TypeError(".Message.CallButton.phoneNumber: object expected");
                message.phoneNumber = $root.Message.HighlyStructuredMessage.fromObject(object.phoneNumber);
            }
            return message;
        };

        /**
         * Creates a plain object from a CallButton message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.CallButton
         * @static
         * @param {Message.CallButton} message CallButton
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CallButton.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.displayText = null;
                object.phoneNumber = null;
            }
            if (message.displayText != null && message.hasOwnProperty("displayText"))
                object.displayText = $root.Message.HighlyStructuredMessage.toObject(message.displayText, options);
            if (message.phoneNumber != null && message.hasOwnProperty("phoneNumber"))
                object.phoneNumber = $root.Message.HighlyStructuredMessage.toObject(message.phoneNumber, options);
            return object;
        };

        /**
         * Converts this CallButton to JSON.
         * @function toJSON
         * @memberof Message.CallButton
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CallButton.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CallButton;
    })();

    Message.TemplateButton = (function() {

        /**
         * Properties of a TemplateButton.
         * @memberof Message
         * @interface ITemplateButton
         * @property {number|null} [index] TemplateButton index
         * @property {Message.IQuickReplyButton|null} [quickReplyButton] TemplateButton quickReplyButton
         * @property {Message.IURLButton|null} [urlButton] TemplateButton urlButton
         * @property {Message.ICallButton|null} [callButton] TemplateButton callButton
         */

        /**
         * Constructs a new TemplateButton.
         * @memberof Message
         * @classdesc Represents a TemplateButton.
         * @implements ITemplateButton
         * @constructor
         * @param {Message.ITemplateButton=} [properties] Properties to set
         */
        function TemplateButton(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TemplateButton index.
         * @member {number} index
         * @memberof Message.TemplateButton
         * @instance
         */
        TemplateButton.prototype.index = 0;

        /**
         * TemplateButton quickReplyButton.
         * @member {Message.IQuickReplyButton|null|undefined} quickReplyButton
         * @memberof Message.TemplateButton
         * @instance
         */
        TemplateButton.prototype.quickReplyButton = null;

        /**
         * TemplateButton urlButton.
         * @member {Message.IURLButton|null|undefined} urlButton
         * @memberof Message.TemplateButton
         * @instance
         */
        TemplateButton.prototype.urlButton = null;

        /**
         * TemplateButton callButton.
         * @member {Message.ICallButton|null|undefined} callButton
         * @memberof Message.TemplateButton
         * @instance
         */
        TemplateButton.prototype.callButton = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * TemplateButton button.
         * @member {"quickReplyButton"|"urlButton"|"callButton"|undefined} button
         * @memberof Message.TemplateButton
         * @instance
         */
        Object.defineProperty(TemplateButton.prototype, "button", {
            get: $util.oneOfGetter($oneOfFields = ["quickReplyButton", "urlButton", "callButton"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new TemplateButton instance using the specified properties.
         * @function create
         * @memberof Message.TemplateButton
         * @static
         * @param {Message.ITemplateButton=} [properties] Properties to set
         * @returns {Message.TemplateButton} TemplateButton instance
         */
        TemplateButton.create = function create(properties) {
            return new TemplateButton(properties);
        };

        /**
         * Encodes the specified TemplateButton message. Does not implicitly {@link Message.TemplateButton.verify|verify} messages.
         * @function encode
         * @memberof Message.TemplateButton
         * @static
         * @param {Message.ITemplateButton} message TemplateButton message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TemplateButton.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.quickReplyButton != null && Object.hasOwnProperty.call(message, "quickReplyButton"))
                $root.Message.QuickReplyButton.encode(message.quickReplyButton, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.urlButton != null && Object.hasOwnProperty.call(message, "urlButton"))
                $root.Message.URLButton.encode(message.urlButton, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.callButton != null && Object.hasOwnProperty.call(message, "callButton"))
                $root.Message.CallButton.encode(message.callButton, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.index);
            return writer;
        };

        /**
         * Encodes the specified TemplateButton message, length delimited. Does not implicitly {@link Message.TemplateButton.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.TemplateButton
         * @static
         * @param {Message.ITemplateButton} message TemplateButton message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TemplateButton.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TemplateButton message from the specified reader or buffer.
         * @function decode
         * @memberof Message.TemplateButton
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.TemplateButton} TemplateButton
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TemplateButton.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.TemplateButton();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 4:
                    message.index = reader.uint32();
                    break;
                case 1:
                    message.quickReplyButton = $root.Message.QuickReplyButton.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.urlButton = $root.Message.URLButton.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.callButton = $root.Message.CallButton.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TemplateButton message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.TemplateButton
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.TemplateButton} TemplateButton
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TemplateButton.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TemplateButton message.
         * @function verify
         * @memberof Message.TemplateButton
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TemplateButton.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.quickReplyButton != null && message.hasOwnProperty("quickReplyButton")) {
                properties.button = 1;
                {
                    var error = $root.Message.QuickReplyButton.verify(message.quickReplyButton);
                    if (error)
                        return "quickReplyButton." + error;
                }
            }
            if (message.urlButton != null && message.hasOwnProperty("urlButton")) {
                if (properties.button === 1)
                    return "button: multiple values";
                properties.button = 1;
                {
                    var error = $root.Message.URLButton.verify(message.urlButton);
                    if (error)
                        return "urlButton." + error;
                }
            }
            if (message.callButton != null && message.hasOwnProperty("callButton")) {
                if (properties.button === 1)
                    return "button: multiple values";
                properties.button = 1;
                {
                    var error = $root.Message.CallButton.verify(message.callButton);
                    if (error)
                        return "callButton." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TemplateButton message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.TemplateButton
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.TemplateButton} TemplateButton
         */
        TemplateButton.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.TemplateButton)
                return object;
            var message = new $root.Message.TemplateButton();
            if (object.index != null)
                message.index = object.index >>> 0;
            if (object.quickReplyButton != null) {
                if (typeof object.quickReplyButton !== "object")
                    throw TypeError(".Message.TemplateButton.quickReplyButton: object expected");
                message.quickReplyButton = $root.Message.QuickReplyButton.fromObject(object.quickReplyButton);
            }
            if (object.urlButton != null) {
                if (typeof object.urlButton !== "object")
                    throw TypeError(".Message.TemplateButton.urlButton: object expected");
                message.urlButton = $root.Message.URLButton.fromObject(object.urlButton);
            }
            if (object.callButton != null) {
                if (typeof object.callButton !== "object")
                    throw TypeError(".Message.TemplateButton.callButton: object expected");
                message.callButton = $root.Message.CallButton.fromObject(object.callButton);
            }
            return message;
        };

        /**
         * Creates a plain object from a TemplateButton message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.TemplateButton
         * @static
         * @param {Message.TemplateButton} message TemplateButton
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TemplateButton.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.index = 0;
            if (message.quickReplyButton != null && message.hasOwnProperty("quickReplyButton")) {
                object.quickReplyButton = $root.Message.QuickReplyButton.toObject(message.quickReplyButton, options);
                if (options.oneofs)
                    object.button = "quickReplyButton";
            }
            if (message.urlButton != null && message.hasOwnProperty("urlButton")) {
                object.urlButton = $root.Message.URLButton.toObject(message.urlButton, options);
                if (options.oneofs)
                    object.button = "urlButton";
            }
            if (message.callButton != null && message.hasOwnProperty("callButton")) {
                object.callButton = $root.Message.CallButton.toObject(message.callButton, options);
                if (options.oneofs)
                    object.button = "callButton";
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };

        /**
         * Converts this TemplateButton to JSON.
         * @function toJSON
         * @memberof Message.TemplateButton
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TemplateButton.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TemplateButton;
    })();

    Message.Location = (function() {

        /**
         * Properties of a Location.
         * @memberof Message
         * @interface ILocation
         * @property {number|null} [degreesLatitude] Location degreesLatitude
         * @property {number|null} [degreesLongitude] Location degreesLongitude
         * @property {string|null} [name] Location name
         */

        /**
         * Constructs a new Location.
         * @memberof Message
         * @classdesc Represents a Location.
         * @implements ILocation
         * @constructor
         * @param {Message.ILocation=} [properties] Properties to set
         */
        function Location(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Location degreesLatitude.
         * @member {number} degreesLatitude
         * @memberof Message.Location
         * @instance
         */
        Location.prototype.degreesLatitude = 0;

        /**
         * Location degreesLongitude.
         * @member {number} degreesLongitude
         * @memberof Message.Location
         * @instance
         */
        Location.prototype.degreesLongitude = 0;

        /**
         * Location name.
         * @member {string} name
         * @memberof Message.Location
         * @instance
         */
        Location.prototype.name = "";

        /**
         * Creates a new Location instance using the specified properties.
         * @function create
         * @memberof Message.Location
         * @static
         * @param {Message.ILocation=} [properties] Properties to set
         * @returns {Message.Location} Location instance
         */
        Location.create = function create(properties) {
            return new Location(properties);
        };

        /**
         * Encodes the specified Location message. Does not implicitly {@link Message.Location.verify|verify} messages.
         * @function encode
         * @memberof Message.Location
         * @static
         * @param {Message.ILocation} message Location message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Location.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.degreesLatitude != null && Object.hasOwnProperty.call(message, "degreesLatitude"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.degreesLatitude);
            if (message.degreesLongitude != null && Object.hasOwnProperty.call(message, "degreesLongitude"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.degreesLongitude);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified Location message, length delimited. Does not implicitly {@link Message.Location.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.Location
         * @static
         * @param {Message.ILocation} message Location message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Location.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Location message from the specified reader or buffer.
         * @function decode
         * @memberof Message.Location
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.Location} Location
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Location.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.Location();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.degreesLatitude = reader.double();
                    break;
                case 2:
                    message.degreesLongitude = reader.double();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Location message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.Location
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.Location} Location
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Location.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Location message.
         * @function verify
         * @memberof Message.Location
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Location.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.degreesLatitude != null && message.hasOwnProperty("degreesLatitude"))
                if (typeof message.degreesLatitude !== "number")
                    return "degreesLatitude: number expected";
            if (message.degreesLongitude != null && message.hasOwnProperty("degreesLongitude"))
                if (typeof message.degreesLongitude !== "number")
                    return "degreesLongitude: number expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a Location message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.Location
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.Location} Location
         */
        Location.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.Location)
                return object;
            var message = new $root.Message.Location();
            if (object.degreesLatitude != null)
                message.degreesLatitude = Number(object.degreesLatitude);
            if (object.degreesLongitude != null)
                message.degreesLongitude = Number(object.degreesLongitude);
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a Location message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.Location
         * @static
         * @param {Message.Location} message Location
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Location.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.degreesLatitude = 0;
                object.degreesLongitude = 0;
                object.name = "";
            }
            if (message.degreesLatitude != null && message.hasOwnProperty("degreesLatitude"))
                object.degreesLatitude = options.json && !isFinite(message.degreesLatitude) ? String(message.degreesLatitude) : message.degreesLatitude;
            if (message.degreesLongitude != null && message.hasOwnProperty("degreesLongitude"))
                object.degreesLongitude = options.json && !isFinite(message.degreesLongitude) ? String(message.degreesLongitude) : message.degreesLongitude;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this Location to JSON.
         * @function toJSON
         * @memberof Message.Location
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Location.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Location;
    })();

    Message.Point = (function() {

        /**
         * Properties of a Point.
         * @memberof Message
         * @interface IPoint
         * @property {number|null} [xDeprecated] Point xDeprecated
         * @property {number|null} [yDeprecated] Point yDeprecated
         * @property {number|null} [x] Point x
         * @property {number|null} [y] Point y
         */

        /**
         * Constructs a new Point.
         * @memberof Message
         * @classdesc Represents a Point.
         * @implements IPoint
         * @constructor
         * @param {Message.IPoint=} [properties] Properties to set
         */
        function Point(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Point xDeprecated.
         * @member {number} xDeprecated
         * @memberof Message.Point
         * @instance
         */
        Point.prototype.xDeprecated = 0;

        /**
         * Point yDeprecated.
         * @member {number} yDeprecated
         * @memberof Message.Point
         * @instance
         */
        Point.prototype.yDeprecated = 0;

        /**
         * Point x.
         * @member {number} x
         * @memberof Message.Point
         * @instance
         */
        Point.prototype.x = 0;

        /**
         * Point y.
         * @member {number} y
         * @memberof Message.Point
         * @instance
         */
        Point.prototype.y = 0;

        /**
         * Creates a new Point instance using the specified properties.
         * @function create
         * @memberof Message.Point
         * @static
         * @param {Message.IPoint=} [properties] Properties to set
         * @returns {Message.Point} Point instance
         */
        Point.create = function create(properties) {
            return new Point(properties);
        };

        /**
         * Encodes the specified Point message. Does not implicitly {@link Message.Point.verify|verify} messages.
         * @function encode
         * @memberof Message.Point
         * @static
         * @param {Message.IPoint} message Point message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Point.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.xDeprecated != null && Object.hasOwnProperty.call(message, "xDeprecated"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.xDeprecated);
            if (message.yDeprecated != null && Object.hasOwnProperty.call(message, "yDeprecated"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.yDeprecated);
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.y);
            return writer;
        };

        /**
         * Encodes the specified Point message, length delimited. Does not implicitly {@link Message.Point.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.Point
         * @static
         * @param {Message.IPoint} message Point message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Point.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Point message from the specified reader or buffer.
         * @function decode
         * @memberof Message.Point
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.Point} Point
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Point.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.Point();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.xDeprecated = reader.int32();
                    break;
                case 2:
                    message.yDeprecated = reader.int32();
                    break;
                case 3:
                    message.x = reader.double();
                    break;
                case 4:
                    message.y = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Point message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.Point
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.Point} Point
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Point.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Point message.
         * @function verify
         * @memberof Message.Point
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Point.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.xDeprecated != null && message.hasOwnProperty("xDeprecated"))
                if (!$util.isInteger(message.xDeprecated))
                    return "xDeprecated: integer expected";
            if (message.yDeprecated != null && message.hasOwnProperty("yDeprecated"))
                if (!$util.isInteger(message.yDeprecated))
                    return "yDeprecated: integer expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            return null;
        };

        /**
         * Creates a Point message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.Point
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.Point} Point
         */
        Point.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.Point)
                return object;
            var message = new $root.Message.Point();
            if (object.xDeprecated != null)
                message.xDeprecated = object.xDeprecated | 0;
            if (object.yDeprecated != null)
                message.yDeprecated = object.yDeprecated | 0;
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            return message;
        };

        /**
         * Creates a plain object from a Point message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.Point
         * @static
         * @param {Message.Point} message Point
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Point.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.xDeprecated = 0;
                object.yDeprecated = 0;
                object.x = 0;
                object.y = 0;
            }
            if (message.xDeprecated != null && message.hasOwnProperty("xDeprecated"))
                object.xDeprecated = message.xDeprecated;
            if (message.yDeprecated != null && message.hasOwnProperty("yDeprecated"))
                object.yDeprecated = message.yDeprecated;
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            return object;
        };

        /**
         * Converts this Point to JSON.
         * @function toJSON
         * @memberof Message.Point
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Point.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Point;
    })();

    Message.InteractiveAnnotation = (function() {

        /**
         * Properties of an InteractiveAnnotation.
         * @memberof Message
         * @interface IInteractiveAnnotation
         * @property {Array.<Message.IPoint>|null} [polygonVertices] InteractiveAnnotation polygonVertices
         * @property {Message.ILocation|null} [location] InteractiveAnnotation location
         */

        /**
         * Constructs a new InteractiveAnnotation.
         * @memberof Message
         * @classdesc Represents an InteractiveAnnotation.
         * @implements IInteractiveAnnotation
         * @constructor
         * @param {Message.IInteractiveAnnotation=} [properties] Properties to set
         */
        function InteractiveAnnotation(properties) {
            this.polygonVertices = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InteractiveAnnotation polygonVertices.
         * @member {Array.<Message.IPoint>} polygonVertices
         * @memberof Message.InteractiveAnnotation
         * @instance
         */
        InteractiveAnnotation.prototype.polygonVertices = $util.emptyArray;

        /**
         * InteractiveAnnotation location.
         * @member {Message.ILocation|null|undefined} location
         * @memberof Message.InteractiveAnnotation
         * @instance
         */
        InteractiveAnnotation.prototype.location = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * InteractiveAnnotation action.
         * @member {"location"|undefined} action
         * @memberof Message.InteractiveAnnotation
         * @instance
         */
        Object.defineProperty(InteractiveAnnotation.prototype, "action", {
            get: $util.oneOfGetter($oneOfFields = ["location"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new InteractiveAnnotation instance using the specified properties.
         * @function create
         * @memberof Message.InteractiveAnnotation
         * @static
         * @param {Message.IInteractiveAnnotation=} [properties] Properties to set
         * @returns {Message.InteractiveAnnotation} InteractiveAnnotation instance
         */
        InteractiveAnnotation.create = function create(properties) {
            return new InteractiveAnnotation(properties);
        };

        /**
         * Encodes the specified InteractiveAnnotation message. Does not implicitly {@link Message.InteractiveAnnotation.verify|verify} messages.
         * @function encode
         * @memberof Message.InteractiveAnnotation
         * @static
         * @param {Message.IInteractiveAnnotation} message InteractiveAnnotation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InteractiveAnnotation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.polygonVertices != null && message.polygonVertices.length)
                for (var i = 0; i < message.polygonVertices.length; ++i)
                    $root.Message.Point.encode(message.polygonVertices[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                $root.Message.Location.encode(message.location, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified InteractiveAnnotation message, length delimited. Does not implicitly {@link Message.InteractiveAnnotation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.InteractiveAnnotation
         * @static
         * @param {Message.IInteractiveAnnotation} message InteractiveAnnotation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InteractiveAnnotation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InteractiveAnnotation message from the specified reader or buffer.
         * @function decode
         * @memberof Message.InteractiveAnnotation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.InteractiveAnnotation} InteractiveAnnotation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InteractiveAnnotation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.InteractiveAnnotation();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.polygonVertices && message.polygonVertices.length))
                        message.polygonVertices = [];
                    message.polygonVertices.push($root.Message.Point.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.location = $root.Message.Location.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InteractiveAnnotation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.InteractiveAnnotation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.InteractiveAnnotation} InteractiveAnnotation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InteractiveAnnotation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InteractiveAnnotation message.
         * @function verify
         * @memberof Message.InteractiveAnnotation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InteractiveAnnotation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.polygonVertices != null && message.hasOwnProperty("polygonVertices")) {
                if (!Array.isArray(message.polygonVertices))
                    return "polygonVertices: array expected";
                for (var i = 0; i < message.polygonVertices.length; ++i) {
                    var error = $root.Message.Point.verify(message.polygonVertices[i]);
                    if (error)
                        return "polygonVertices." + error;
                }
            }
            if (message.location != null && message.hasOwnProperty("location")) {
                properties.action = 1;
                {
                    var error = $root.Message.Location.verify(message.location);
                    if (error)
                        return "location." + error;
                }
            }
            return null;
        };

        /**
         * Creates an InteractiveAnnotation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.InteractiveAnnotation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.InteractiveAnnotation} InteractiveAnnotation
         */
        InteractiveAnnotation.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.InteractiveAnnotation)
                return object;
            var message = new $root.Message.InteractiveAnnotation();
            if (object.polygonVertices) {
                if (!Array.isArray(object.polygonVertices))
                    throw TypeError(".Message.InteractiveAnnotation.polygonVertices: array expected");
                message.polygonVertices = [];
                for (var i = 0; i < object.polygonVertices.length; ++i) {
                    if (typeof object.polygonVertices[i] !== "object")
                        throw TypeError(".Message.InteractiveAnnotation.polygonVertices: object expected");
                    message.polygonVertices[i] = $root.Message.Point.fromObject(object.polygonVertices[i]);
                }
            }
            if (object.location != null) {
                if (typeof object.location !== "object")
                    throw TypeError(".Message.InteractiveAnnotation.location: object expected");
                message.location = $root.Message.Location.fromObject(object.location);
            }
            return message;
        };

        /**
         * Creates a plain object from an InteractiveAnnotation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.InteractiveAnnotation
         * @static
         * @param {Message.InteractiveAnnotation} message InteractiveAnnotation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InteractiveAnnotation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.polygonVertices = [];
            if (message.polygonVertices && message.polygonVertices.length) {
                object.polygonVertices = [];
                for (var j = 0; j < message.polygonVertices.length; ++j)
                    object.polygonVertices[j] = $root.Message.Point.toObject(message.polygonVertices[j], options);
            }
            if (message.location != null && message.hasOwnProperty("location")) {
                object.location = $root.Message.Location.toObject(message.location, options);
                if (options.oneofs)
                    object.action = "location";
            }
            return object;
        };

        /**
         * Converts this InteractiveAnnotation to JSON.
         * @function toJSON
         * @memberof Message.InteractiveAnnotation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InteractiveAnnotation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InteractiveAnnotation;
    })();

    Message.AdReplyInfo = (function() {

        /**
         * Properties of an AdReplyInfo.
         * @memberof Message
         * @interface IAdReplyInfo
         * @property {string|null} [advertiserName] AdReplyInfo advertiserName
         * @property {Message.AdReplyInfo.AD_REPLY_INFO_MEDIATYPE|null} [mediaType] AdReplyInfo mediaType
         * @property {Uint8Array|null} [jpegThumbnail] AdReplyInfo jpegThumbnail
         * @property {string|null} [caption] AdReplyInfo caption
         */

        /**
         * Constructs a new AdReplyInfo.
         * @memberof Message
         * @classdesc Represents an AdReplyInfo.
         * @implements IAdReplyInfo
         * @constructor
         * @param {Message.IAdReplyInfo=} [properties] Properties to set
         */
        function AdReplyInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AdReplyInfo advertiserName.
         * @member {string} advertiserName
         * @memberof Message.AdReplyInfo
         * @instance
         */
        AdReplyInfo.prototype.advertiserName = "";

        /**
         * AdReplyInfo mediaType.
         * @member {Message.AdReplyInfo.AD_REPLY_INFO_MEDIATYPE} mediaType
         * @memberof Message.AdReplyInfo
         * @instance
         */
        AdReplyInfo.prototype.mediaType = 0;

        /**
         * AdReplyInfo jpegThumbnail.
         * @member {Uint8Array} jpegThumbnail
         * @memberof Message.AdReplyInfo
         * @instance
         */
        AdReplyInfo.prototype.jpegThumbnail = $util.newBuffer([]);

        /**
         * AdReplyInfo caption.
         * @member {string} caption
         * @memberof Message.AdReplyInfo
         * @instance
         */
        AdReplyInfo.prototype.caption = "";

        /**
         * Creates a new AdReplyInfo instance using the specified properties.
         * @function create
         * @memberof Message.AdReplyInfo
         * @static
         * @param {Message.IAdReplyInfo=} [properties] Properties to set
         * @returns {Message.AdReplyInfo} AdReplyInfo instance
         */
        AdReplyInfo.create = function create(properties) {
            return new AdReplyInfo(properties);
        };

        /**
         * Encodes the specified AdReplyInfo message. Does not implicitly {@link Message.AdReplyInfo.verify|verify} messages.
         * @function encode
         * @memberof Message.AdReplyInfo
         * @static
         * @param {Message.IAdReplyInfo} message AdReplyInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdReplyInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.advertiserName != null && Object.hasOwnProperty.call(message, "advertiserName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.advertiserName);
            if (message.mediaType != null && Object.hasOwnProperty.call(message, "mediaType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mediaType);
            if (message.jpegThumbnail != null && Object.hasOwnProperty.call(message, "jpegThumbnail"))
                writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.jpegThumbnail);
            if (message.caption != null && Object.hasOwnProperty.call(message, "caption"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.caption);
            return writer;
        };

        /**
         * Encodes the specified AdReplyInfo message, length delimited. Does not implicitly {@link Message.AdReplyInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.AdReplyInfo
         * @static
         * @param {Message.IAdReplyInfo} message AdReplyInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AdReplyInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AdReplyInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Message.AdReplyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.AdReplyInfo} AdReplyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdReplyInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.AdReplyInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.advertiserName = reader.string();
                    break;
                case 2:
                    message.mediaType = reader.int32();
                    break;
                case 16:
                    message.jpegThumbnail = reader.bytes();
                    break;
                case 17:
                    message.caption = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AdReplyInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.AdReplyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.AdReplyInfo} AdReplyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AdReplyInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AdReplyInfo message.
         * @function verify
         * @memberof Message.AdReplyInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AdReplyInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.advertiserName != null && message.hasOwnProperty("advertiserName"))
                if (!$util.isString(message.advertiserName))
                    return "advertiserName: string expected";
            if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                switch (message.mediaType) {
                default:
                    return "mediaType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                if (!(message.jpegThumbnail && typeof message.jpegThumbnail.length === "number" || $util.isString(message.jpegThumbnail)))
                    return "jpegThumbnail: buffer expected";
            if (message.caption != null && message.hasOwnProperty("caption"))
                if (!$util.isString(message.caption))
                    return "caption: string expected";
            return null;
        };

        /**
         * Creates an AdReplyInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.AdReplyInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.AdReplyInfo} AdReplyInfo
         */
        AdReplyInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.AdReplyInfo)
                return object;
            var message = new $root.Message.AdReplyInfo();
            if (object.advertiserName != null)
                message.advertiserName = String(object.advertiserName);
            switch (object.mediaType) {
            case "NONE":
            case 0:
                message.mediaType = 0;
                break;
            case "IMAGE":
            case 1:
                message.mediaType = 1;
                break;
            case "VIDEO":
            case 2:
                message.mediaType = 2;
                break;
            }
            if (object.jpegThumbnail != null)
                if (typeof object.jpegThumbnail === "string")
                    $util.base64.decode(object.jpegThumbnail, message.jpegThumbnail = $util.newBuffer($util.base64.length(object.jpegThumbnail)), 0);
                else if (object.jpegThumbnail.length)
                    message.jpegThumbnail = object.jpegThumbnail;
            if (object.caption != null)
                message.caption = String(object.caption);
            return message;
        };

        /**
         * Creates a plain object from an AdReplyInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.AdReplyInfo
         * @static
         * @param {Message.AdReplyInfo} message AdReplyInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AdReplyInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.advertiserName = "";
                object.mediaType = options.enums === String ? "NONE" : 0;
                if (options.bytes === String)
                    object.jpegThumbnail = "";
                else {
                    object.jpegThumbnail = [];
                    if (options.bytes !== Array)
                        object.jpegThumbnail = $util.newBuffer(object.jpegThumbnail);
                }
                object.caption = "";
            }
            if (message.advertiserName != null && message.hasOwnProperty("advertiserName"))
                object.advertiserName = message.advertiserName;
            if (message.mediaType != null && message.hasOwnProperty("mediaType"))
                object.mediaType = options.enums === String ? $root.Message.AdReplyInfo.AD_REPLY_INFO_MEDIATYPE[message.mediaType] : message.mediaType;
            if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                object.jpegThumbnail = options.bytes === String ? $util.base64.encode(message.jpegThumbnail, 0, message.jpegThumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.jpegThumbnail) : message.jpegThumbnail;
            if (message.caption != null && message.hasOwnProperty("caption"))
                object.caption = message.caption;
            return object;
        };

        /**
         * Converts this AdReplyInfo to JSON.
         * @function toJSON
         * @memberof Message.AdReplyInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AdReplyInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * AD_REPLY_INFO_MEDIATYPE enum.
         * @name Message.AdReplyInfo.AD_REPLY_INFO_MEDIATYPE
         * @enum {number}
         * @property {number} NONE=0 NONE value
         * @property {number} IMAGE=1 IMAGE value
         * @property {number} VIDEO=2 VIDEO value
         */
        AdReplyInfo.AD_REPLY_INFO_MEDIATYPE = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NONE"] = 0;
            values[valuesById[1] = "IMAGE"] = 1;
            values[valuesById[2] = "VIDEO"] = 2;
            return values;
        })();

        return AdReplyInfo;
    })();

    Message.ContextInfo = (function() {

        /**
         * Properties of a ContextInfo.
         * @memberof Message
         * @interface IContextInfo
         * @property {string|null} [stanzaId] ContextInfo stanzaId
         * @property {string|null} [participant] ContextInfo participant
         * @property {Message.IMessage|null} [quotedMessage] ContextInfo quotedMessage
         * @property {string|null} [remoteJid] ContextInfo remoteJid
         * @property {Array.<string>|null} [mentionedJid] ContextInfo mentionedJid
         * @property {string|null} [conversionSource] ContextInfo conversionSource
         * @property {Uint8Array|null} [conversionData] ContextInfo conversionData
         * @property {number|null} [conversionDelaySeconds] ContextInfo conversionDelaySeconds
         * @property {number|null} [forwardingScore] ContextInfo forwardingScore
         * @property {boolean|null} [isForwarded] ContextInfo isForwarded
         * @property {Message.IAdReplyInfo|null} [quotedAd] ContextInfo quotedAd
         * @property {Message.IMessageKey|null} [placeholderKey] ContextInfo placeholderKey
         * @property {number|null} [expiration] ContextInfo expiration
         * @property {number|Long|null} [ephemeralSettingTimestamp] ContextInfo ephemeralSettingTimestamp
         * @property {Uint8Array|null} [ephemeralSharedSecret] ContextInfo ephemeralSharedSecret
         */

        /**
         * Constructs a new ContextInfo.
         * @memberof Message
         * @classdesc Represents a ContextInfo.
         * @implements IContextInfo
         * @constructor
         * @param {Message.IContextInfo=} [properties] Properties to set
         */
        function ContextInfo(properties) {
            this.mentionedJid = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContextInfo stanzaId.
         * @member {string} stanzaId
         * @memberof Message.ContextInfo
         * @instance
         */
        ContextInfo.prototype.stanzaId = "";

        /**
         * ContextInfo participant.
         * @member {string} participant
         * @memberof Message.ContextInfo
         * @instance
         */
        ContextInfo.prototype.participant = "";

        /**
         * ContextInfo quotedMessage.
         * @member {Message.IMessage|null|undefined} quotedMessage
         * @memberof Message.ContextInfo
         * @instance
         */
        ContextInfo.prototype.quotedMessage = null;

        /**
         * ContextInfo remoteJid.
         * @member {string} remoteJid
         * @memberof Message.ContextInfo
         * @instance
         */
        ContextInfo.prototype.remoteJid = "";

        /**
         * ContextInfo mentionedJid.
         * @member {Array.<string>} mentionedJid
         * @memberof Message.ContextInfo
         * @instance
         */
        ContextInfo.prototype.mentionedJid = $util.emptyArray;

        /**
         * ContextInfo conversionSource.
         * @member {string} conversionSource
         * @memberof Message.ContextInfo
         * @instance
         */
        ContextInfo.prototype.conversionSource = "";

        /**
         * ContextInfo conversionData.
         * @member {Uint8Array} conversionData
         * @memberof Message.ContextInfo
         * @instance
         */
        ContextInfo.prototype.conversionData = $util.newBuffer([]);

        /**
         * ContextInfo conversionDelaySeconds.
         * @member {number} conversionDelaySeconds
         * @memberof Message.ContextInfo
         * @instance
         */
        ContextInfo.prototype.conversionDelaySeconds = 0;

        /**
         * ContextInfo forwardingScore.
         * @member {number} forwardingScore
         * @memberof Message.ContextInfo
         * @instance
         */
        ContextInfo.prototype.forwardingScore = 0;

        /**
         * ContextInfo isForwarded.
         * @member {boolean} isForwarded
         * @memberof Message.ContextInfo
         * @instance
         */
        ContextInfo.prototype.isForwarded = false;

        /**
         * ContextInfo quotedAd.
         * @member {Message.IAdReplyInfo|null|undefined} quotedAd
         * @memberof Message.ContextInfo
         * @instance
         */
        ContextInfo.prototype.quotedAd = null;

        /**
         * ContextInfo placeholderKey.
         * @member {Message.IMessageKey|null|undefined} placeholderKey
         * @memberof Message.ContextInfo
         * @instance
         */
        ContextInfo.prototype.placeholderKey = null;

        /**
         * ContextInfo expiration.
         * @member {number} expiration
         * @memberof Message.ContextInfo
         * @instance
         */
        ContextInfo.prototype.expiration = 0;

        /**
         * ContextInfo ephemeralSettingTimestamp.
         * @member {number|Long} ephemeralSettingTimestamp
         * @memberof Message.ContextInfo
         * @instance
         */
        ContextInfo.prototype.ephemeralSettingTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ContextInfo ephemeralSharedSecret.
         * @member {Uint8Array} ephemeralSharedSecret
         * @memberof Message.ContextInfo
         * @instance
         */
        ContextInfo.prototype.ephemeralSharedSecret = $util.newBuffer([]);

        /**
         * Creates a new ContextInfo instance using the specified properties.
         * @function create
         * @memberof Message.ContextInfo
         * @static
         * @param {Message.IContextInfo=} [properties] Properties to set
         * @returns {Message.ContextInfo} ContextInfo instance
         */
        ContextInfo.create = function create(properties) {
            return new ContextInfo(properties);
        };

        /**
         * Encodes the specified ContextInfo message. Does not implicitly {@link Message.ContextInfo.verify|verify} messages.
         * @function encode
         * @memberof Message.ContextInfo
         * @static
         * @param {Message.IContextInfo} message ContextInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContextInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stanzaId != null && Object.hasOwnProperty.call(message, "stanzaId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.stanzaId);
            if (message.participant != null && Object.hasOwnProperty.call(message, "participant"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.participant);
            if (message.quotedMessage != null && Object.hasOwnProperty.call(message, "quotedMessage"))
                $root.Message.Message.encode(message.quotedMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.remoteJid != null && Object.hasOwnProperty.call(message, "remoteJid"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.remoteJid);
            if (message.mentionedJid != null && message.mentionedJid.length)
                for (var i = 0; i < message.mentionedJid.length; ++i)
                    writer.uint32(/* id 15, wireType 2 =*/122).string(message.mentionedJid[i]);
            if (message.conversionSource != null && Object.hasOwnProperty.call(message, "conversionSource"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.conversionSource);
            if (message.conversionData != null && Object.hasOwnProperty.call(message, "conversionData"))
                writer.uint32(/* id 19, wireType 2 =*/154).bytes(message.conversionData);
            if (message.conversionDelaySeconds != null && Object.hasOwnProperty.call(message, "conversionDelaySeconds"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.conversionDelaySeconds);
            if (message.forwardingScore != null && Object.hasOwnProperty.call(message, "forwardingScore"))
                writer.uint32(/* id 21, wireType 0 =*/168).uint32(message.forwardingScore);
            if (message.isForwarded != null && Object.hasOwnProperty.call(message, "isForwarded"))
                writer.uint32(/* id 22, wireType 0 =*/176).bool(message.isForwarded);
            if (message.quotedAd != null && Object.hasOwnProperty.call(message, "quotedAd"))
                $root.Message.AdReplyInfo.encode(message.quotedAd, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            if (message.placeholderKey != null && Object.hasOwnProperty.call(message, "placeholderKey"))
                $root.Message.MessageKey.encode(message.placeholderKey, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.expiration != null && Object.hasOwnProperty.call(message, "expiration"))
                writer.uint32(/* id 25, wireType 0 =*/200).uint32(message.expiration);
            if (message.ephemeralSettingTimestamp != null && Object.hasOwnProperty.call(message, "ephemeralSettingTimestamp"))
                writer.uint32(/* id 26, wireType 0 =*/208).int64(message.ephemeralSettingTimestamp);
            if (message.ephemeralSharedSecret != null && Object.hasOwnProperty.call(message, "ephemeralSharedSecret"))
                writer.uint32(/* id 27, wireType 2 =*/218).bytes(message.ephemeralSharedSecret);
            return writer;
        };

        /**
         * Encodes the specified ContextInfo message, length delimited. Does not implicitly {@link Message.ContextInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.ContextInfo
         * @static
         * @param {Message.IContextInfo} message ContextInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContextInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContextInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Message.ContextInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.ContextInfo} ContextInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContextInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.ContextInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stanzaId = reader.string();
                    break;
                case 2:
                    message.participant = reader.string();
                    break;
                case 3:
                    message.quotedMessage = $root.Message.Message.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.remoteJid = reader.string();
                    break;
                case 15:
                    if (!(message.mentionedJid && message.mentionedJid.length))
                        message.mentionedJid = [];
                    message.mentionedJid.push(reader.string());
                    break;
                case 18:
                    message.conversionSource = reader.string();
                    break;
                case 19:
                    message.conversionData = reader.bytes();
                    break;
                case 20:
                    message.conversionDelaySeconds = reader.uint32();
                    break;
                case 21:
                    message.forwardingScore = reader.uint32();
                    break;
                case 22:
                    message.isForwarded = reader.bool();
                    break;
                case 23:
                    message.quotedAd = $root.Message.AdReplyInfo.decode(reader, reader.uint32());
                    break;
                case 24:
                    message.placeholderKey = $root.Message.MessageKey.decode(reader, reader.uint32());
                    break;
                case 25:
                    message.expiration = reader.uint32();
                    break;
                case 26:
                    message.ephemeralSettingTimestamp = reader.int64();
                    break;
                case 27:
                    message.ephemeralSharedSecret = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContextInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.ContextInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.ContextInfo} ContextInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContextInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContextInfo message.
         * @function verify
         * @memberof Message.ContextInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContextInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stanzaId != null && message.hasOwnProperty("stanzaId"))
                if (!$util.isString(message.stanzaId))
                    return "stanzaId: string expected";
            if (message.participant != null && message.hasOwnProperty("participant"))
                if (!$util.isString(message.participant))
                    return "participant: string expected";
            if (message.quotedMessage != null && message.hasOwnProperty("quotedMessage")) {
                var error = $root.Message.Message.verify(message.quotedMessage);
                if (error)
                    return "quotedMessage." + error;
            }
            if (message.remoteJid != null && message.hasOwnProperty("remoteJid"))
                if (!$util.isString(message.remoteJid))
                    return "remoteJid: string expected";
            if (message.mentionedJid != null && message.hasOwnProperty("mentionedJid")) {
                if (!Array.isArray(message.mentionedJid))
                    return "mentionedJid: array expected";
                for (var i = 0; i < message.mentionedJid.length; ++i)
                    if (!$util.isString(message.mentionedJid[i]))
                        return "mentionedJid: string[] expected";
            }
            if (message.conversionSource != null && message.hasOwnProperty("conversionSource"))
                if (!$util.isString(message.conversionSource))
                    return "conversionSource: string expected";
            if (message.conversionData != null && message.hasOwnProperty("conversionData"))
                if (!(message.conversionData && typeof message.conversionData.length === "number" || $util.isString(message.conversionData)))
                    return "conversionData: buffer expected";
            if (message.conversionDelaySeconds != null && message.hasOwnProperty("conversionDelaySeconds"))
                if (!$util.isInteger(message.conversionDelaySeconds))
                    return "conversionDelaySeconds: integer expected";
            if (message.forwardingScore != null && message.hasOwnProperty("forwardingScore"))
                if (!$util.isInteger(message.forwardingScore))
                    return "forwardingScore: integer expected";
            if (message.isForwarded != null && message.hasOwnProperty("isForwarded"))
                if (typeof message.isForwarded !== "boolean")
                    return "isForwarded: boolean expected";
            if (message.quotedAd != null && message.hasOwnProperty("quotedAd")) {
                var error = $root.Message.AdReplyInfo.verify(message.quotedAd);
                if (error)
                    return "quotedAd." + error;
            }
            if (message.placeholderKey != null && message.hasOwnProperty("placeholderKey")) {
                var error = $root.Message.MessageKey.verify(message.placeholderKey);
                if (error)
                    return "placeholderKey." + error;
            }
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (!$util.isInteger(message.expiration))
                    return "expiration: integer expected";
            if (message.ephemeralSettingTimestamp != null && message.hasOwnProperty("ephemeralSettingTimestamp"))
                if (!$util.isInteger(message.ephemeralSettingTimestamp) && !(message.ephemeralSettingTimestamp && $util.isInteger(message.ephemeralSettingTimestamp.low) && $util.isInteger(message.ephemeralSettingTimestamp.high)))
                    return "ephemeralSettingTimestamp: integer|Long expected";
            if (message.ephemeralSharedSecret != null && message.hasOwnProperty("ephemeralSharedSecret"))
                if (!(message.ephemeralSharedSecret && typeof message.ephemeralSharedSecret.length === "number" || $util.isString(message.ephemeralSharedSecret)))
                    return "ephemeralSharedSecret: buffer expected";
            return null;
        };

        /**
         * Creates a ContextInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.ContextInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.ContextInfo} ContextInfo
         */
        ContextInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.ContextInfo)
                return object;
            var message = new $root.Message.ContextInfo();
            if (object.stanzaId != null)
                message.stanzaId = String(object.stanzaId);
            if (object.participant != null)
                message.participant = String(object.participant);
            if (object.quotedMessage != null) {
                if (typeof object.quotedMessage !== "object")
                    throw TypeError(".Message.ContextInfo.quotedMessage: object expected");
                message.quotedMessage = $root.Message.Message.fromObject(object.quotedMessage);
            }
            if (object.remoteJid != null)
                message.remoteJid = String(object.remoteJid);
            if (object.mentionedJid) {
                if (!Array.isArray(object.mentionedJid))
                    throw TypeError(".Message.ContextInfo.mentionedJid: array expected");
                message.mentionedJid = [];
                for (var i = 0; i < object.mentionedJid.length; ++i)
                    message.mentionedJid[i] = String(object.mentionedJid[i]);
            }
            if (object.conversionSource != null)
                message.conversionSource = String(object.conversionSource);
            if (object.conversionData != null)
                if (typeof object.conversionData === "string")
                    $util.base64.decode(object.conversionData, message.conversionData = $util.newBuffer($util.base64.length(object.conversionData)), 0);
                else if (object.conversionData.length)
                    message.conversionData = object.conversionData;
            if (object.conversionDelaySeconds != null)
                message.conversionDelaySeconds = object.conversionDelaySeconds >>> 0;
            if (object.forwardingScore != null)
                message.forwardingScore = object.forwardingScore >>> 0;
            if (object.isForwarded != null)
                message.isForwarded = Boolean(object.isForwarded);
            if (object.quotedAd != null) {
                if (typeof object.quotedAd !== "object")
                    throw TypeError(".Message.ContextInfo.quotedAd: object expected");
                message.quotedAd = $root.Message.AdReplyInfo.fromObject(object.quotedAd);
            }
            if (object.placeholderKey != null) {
                if (typeof object.placeholderKey !== "object")
                    throw TypeError(".Message.ContextInfo.placeholderKey: object expected");
                message.placeholderKey = $root.Message.MessageKey.fromObject(object.placeholderKey);
            }
            if (object.expiration != null)
                message.expiration = object.expiration >>> 0;
            if (object.ephemeralSettingTimestamp != null)
                if ($util.Long)
                    (message.ephemeralSettingTimestamp = $util.Long.fromValue(object.ephemeralSettingTimestamp)).unsigned = false;
                else if (typeof object.ephemeralSettingTimestamp === "string")
                    message.ephemeralSettingTimestamp = parseInt(object.ephemeralSettingTimestamp, 10);
                else if (typeof object.ephemeralSettingTimestamp === "number")
                    message.ephemeralSettingTimestamp = object.ephemeralSettingTimestamp;
                else if (typeof object.ephemeralSettingTimestamp === "object")
                    message.ephemeralSettingTimestamp = new $util.LongBits(object.ephemeralSettingTimestamp.low >>> 0, object.ephemeralSettingTimestamp.high >>> 0).toNumber();
            if (object.ephemeralSharedSecret != null)
                if (typeof object.ephemeralSharedSecret === "string")
                    $util.base64.decode(object.ephemeralSharedSecret, message.ephemeralSharedSecret = $util.newBuffer($util.base64.length(object.ephemeralSharedSecret)), 0);
                else if (object.ephemeralSharedSecret.length)
                    message.ephemeralSharedSecret = object.ephemeralSharedSecret;
            return message;
        };

        /**
         * Creates a plain object from a ContextInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.ContextInfo
         * @static
         * @param {Message.ContextInfo} message ContextInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContextInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.mentionedJid = [];
            if (options.defaults) {
                object.stanzaId = "";
                object.participant = "";
                object.quotedMessage = null;
                object.remoteJid = "";
                object.conversionSource = "";
                if (options.bytes === String)
                    object.conversionData = "";
                else {
                    object.conversionData = [];
                    if (options.bytes !== Array)
                        object.conversionData = $util.newBuffer(object.conversionData);
                }
                object.conversionDelaySeconds = 0;
                object.forwardingScore = 0;
                object.isForwarded = false;
                object.quotedAd = null;
                object.placeholderKey = null;
                object.expiration = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.ephemeralSettingTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ephemeralSettingTimestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.ephemeralSharedSecret = "";
                else {
                    object.ephemeralSharedSecret = [];
                    if (options.bytes !== Array)
                        object.ephemeralSharedSecret = $util.newBuffer(object.ephemeralSharedSecret);
                }
            }
            if (message.stanzaId != null && message.hasOwnProperty("stanzaId"))
                object.stanzaId = message.stanzaId;
            if (message.participant != null && message.hasOwnProperty("participant"))
                object.participant = message.participant;
            if (message.quotedMessage != null && message.hasOwnProperty("quotedMessage"))
                object.quotedMessage = $root.Message.Message.toObject(message.quotedMessage, options);
            if (message.remoteJid != null && message.hasOwnProperty("remoteJid"))
                object.remoteJid = message.remoteJid;
            if (message.mentionedJid && message.mentionedJid.length) {
                object.mentionedJid = [];
                for (var j = 0; j < message.mentionedJid.length; ++j)
                    object.mentionedJid[j] = message.mentionedJid[j];
            }
            if (message.conversionSource != null && message.hasOwnProperty("conversionSource"))
                object.conversionSource = message.conversionSource;
            if (message.conversionData != null && message.hasOwnProperty("conversionData"))
                object.conversionData = options.bytes === String ? $util.base64.encode(message.conversionData, 0, message.conversionData.length) : options.bytes === Array ? Array.prototype.slice.call(message.conversionData) : message.conversionData;
            if (message.conversionDelaySeconds != null && message.hasOwnProperty("conversionDelaySeconds"))
                object.conversionDelaySeconds = message.conversionDelaySeconds;
            if (message.forwardingScore != null && message.hasOwnProperty("forwardingScore"))
                object.forwardingScore = message.forwardingScore;
            if (message.isForwarded != null && message.hasOwnProperty("isForwarded"))
                object.isForwarded = message.isForwarded;
            if (message.quotedAd != null && message.hasOwnProperty("quotedAd"))
                object.quotedAd = $root.Message.AdReplyInfo.toObject(message.quotedAd, options);
            if (message.placeholderKey != null && message.hasOwnProperty("placeholderKey"))
                object.placeholderKey = $root.Message.MessageKey.toObject(message.placeholderKey, options);
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                object.expiration = message.expiration;
            if (message.ephemeralSettingTimestamp != null && message.hasOwnProperty("ephemeralSettingTimestamp"))
                if (typeof message.ephemeralSettingTimestamp === "number")
                    object.ephemeralSettingTimestamp = options.longs === String ? String(message.ephemeralSettingTimestamp) : message.ephemeralSettingTimestamp;
                else
                    object.ephemeralSettingTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.ephemeralSettingTimestamp) : options.longs === Number ? new $util.LongBits(message.ephemeralSettingTimestamp.low >>> 0, message.ephemeralSettingTimestamp.high >>> 0).toNumber() : message.ephemeralSettingTimestamp;
            if (message.ephemeralSharedSecret != null && message.hasOwnProperty("ephemeralSharedSecret"))
                object.ephemeralSharedSecret = options.bytes === String ? $util.base64.encode(message.ephemeralSharedSecret, 0, message.ephemeralSharedSecret.length) : options.bytes === Array ? Array.prototype.slice.call(message.ephemeralSharedSecret) : message.ephemeralSharedSecret;
            return object;
        };

        /**
         * Converts this ContextInfo to JSON.
         * @function toJSON
         * @memberof Message.ContextInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContextInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ContextInfo;
    })();

    Message.SenderKeyDistributionMessage = (function() {

        /**
         * Properties of a SenderKeyDistributionMessage.
         * @memberof Message
         * @interface ISenderKeyDistributionMessage
         * @property {string|null} [groupId] SenderKeyDistributionMessage groupId
         * @property {Uint8Array|null} [axolotlSenderKeyDistributionMessage] SenderKeyDistributionMessage axolotlSenderKeyDistributionMessage
         */

        /**
         * Constructs a new SenderKeyDistributionMessage.
         * @memberof Message
         * @classdesc Represents a SenderKeyDistributionMessage.
         * @implements ISenderKeyDistributionMessage
         * @constructor
         * @param {Message.ISenderKeyDistributionMessage=} [properties] Properties to set
         */
        function SenderKeyDistributionMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SenderKeyDistributionMessage groupId.
         * @member {string} groupId
         * @memberof Message.SenderKeyDistributionMessage
         * @instance
         */
        SenderKeyDistributionMessage.prototype.groupId = "";

        /**
         * SenderKeyDistributionMessage axolotlSenderKeyDistributionMessage.
         * @member {Uint8Array} axolotlSenderKeyDistributionMessage
         * @memberof Message.SenderKeyDistributionMessage
         * @instance
         */
        SenderKeyDistributionMessage.prototype.axolotlSenderKeyDistributionMessage = $util.newBuffer([]);

        /**
         * Creates a new SenderKeyDistributionMessage instance using the specified properties.
         * @function create
         * @memberof Message.SenderKeyDistributionMessage
         * @static
         * @param {Message.ISenderKeyDistributionMessage=} [properties] Properties to set
         * @returns {Message.SenderKeyDistributionMessage} SenderKeyDistributionMessage instance
         */
        SenderKeyDistributionMessage.create = function create(properties) {
            return new SenderKeyDistributionMessage(properties);
        };

        /**
         * Encodes the specified SenderKeyDistributionMessage message. Does not implicitly {@link Message.SenderKeyDistributionMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.SenderKeyDistributionMessage
         * @static
         * @param {Message.ISenderKeyDistributionMessage} message SenderKeyDistributionMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderKeyDistributionMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
            if (message.axolotlSenderKeyDistributionMessage != null && Object.hasOwnProperty.call(message, "axolotlSenderKeyDistributionMessage"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.axolotlSenderKeyDistributionMessage);
            return writer;
        };

        /**
         * Encodes the specified SenderKeyDistributionMessage message, length delimited. Does not implicitly {@link Message.SenderKeyDistributionMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.SenderKeyDistributionMessage
         * @static
         * @param {Message.ISenderKeyDistributionMessage} message SenderKeyDistributionMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderKeyDistributionMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SenderKeyDistributionMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.SenderKeyDistributionMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.SenderKeyDistributionMessage} SenderKeyDistributionMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderKeyDistributionMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.SenderKeyDistributionMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.groupId = reader.string();
                    break;
                case 2:
                    message.axolotlSenderKeyDistributionMessage = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SenderKeyDistributionMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.SenderKeyDistributionMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.SenderKeyDistributionMessage} SenderKeyDistributionMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderKeyDistributionMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SenderKeyDistributionMessage message.
         * @function verify
         * @memberof Message.SenderKeyDistributionMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SenderKeyDistributionMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (!$util.isString(message.groupId))
                    return "groupId: string expected";
            if (message.axolotlSenderKeyDistributionMessage != null && message.hasOwnProperty("axolotlSenderKeyDistributionMessage"))
                if (!(message.axolotlSenderKeyDistributionMessage && typeof message.axolotlSenderKeyDistributionMessage.length === "number" || $util.isString(message.axolotlSenderKeyDistributionMessage)))
                    return "axolotlSenderKeyDistributionMessage: buffer expected";
            return null;
        };

        /**
         * Creates a SenderKeyDistributionMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.SenderKeyDistributionMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.SenderKeyDistributionMessage} SenderKeyDistributionMessage
         */
        SenderKeyDistributionMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.SenderKeyDistributionMessage)
                return object;
            var message = new $root.Message.SenderKeyDistributionMessage();
            if (object.groupId != null)
                message.groupId = String(object.groupId);
            if (object.axolotlSenderKeyDistributionMessage != null)
                if (typeof object.axolotlSenderKeyDistributionMessage === "string")
                    $util.base64.decode(object.axolotlSenderKeyDistributionMessage, message.axolotlSenderKeyDistributionMessage = $util.newBuffer($util.base64.length(object.axolotlSenderKeyDistributionMessage)), 0);
                else if (object.axolotlSenderKeyDistributionMessage.length)
                    message.axolotlSenderKeyDistributionMessage = object.axolotlSenderKeyDistributionMessage;
            return message;
        };

        /**
         * Creates a plain object from a SenderKeyDistributionMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.SenderKeyDistributionMessage
         * @static
         * @param {Message.SenderKeyDistributionMessage} message SenderKeyDistributionMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SenderKeyDistributionMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.groupId = "";
                if (options.bytes === String)
                    object.axolotlSenderKeyDistributionMessage = "";
                else {
                    object.axolotlSenderKeyDistributionMessage = [];
                    if (options.bytes !== Array)
                        object.axolotlSenderKeyDistributionMessage = $util.newBuffer(object.axolotlSenderKeyDistributionMessage);
                }
            }
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                object.groupId = message.groupId;
            if (message.axolotlSenderKeyDistributionMessage != null && message.hasOwnProperty("axolotlSenderKeyDistributionMessage"))
                object.axolotlSenderKeyDistributionMessage = options.bytes === String ? $util.base64.encode(message.axolotlSenderKeyDistributionMessage, 0, message.axolotlSenderKeyDistributionMessage.length) : options.bytes === Array ? Array.prototype.slice.call(message.axolotlSenderKeyDistributionMessage) : message.axolotlSenderKeyDistributionMessage;
            return object;
        };

        /**
         * Converts this SenderKeyDistributionMessage to JSON.
         * @function toJSON
         * @memberof Message.SenderKeyDistributionMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SenderKeyDistributionMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SenderKeyDistributionMessage;
    })();

    Message.WhisperSenderKeyDistributionMessage = (function() {

        /**
         * Properties of a WhisperSenderKeyDistributionMessage.
         * @memberof Message
         * @interface IWhisperSenderKeyDistributionMessage
         * @property {string|null} [groupId] WhisperSenderKeyDistributionMessage groupId
         * @property {Uint8Array|null} [axolotlSenderKeyDistributionMessage] WhisperSenderKeyDistributionMessage axolotlSenderKeyDistributionMessage
         */

        /**
         * Constructs a new WhisperSenderKeyDistributionMessage.
         * @memberof Message
         * @classdesc Represents a WhisperSenderKeyDistributionMessage.
         * @implements IWhisperSenderKeyDistributionMessage
         * @constructor
         * @param {Message.IWhisperSenderKeyDistributionMessage=} [properties] Properties to set
         */
        function WhisperSenderKeyDistributionMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WhisperSenderKeyDistributionMessage groupId.
         * @member {string} groupId
         * @memberof Message.WhisperSenderKeyDistributionMessage
         * @instance
         */
        WhisperSenderKeyDistributionMessage.prototype.groupId = "";

        /**
         * WhisperSenderKeyDistributionMessage axolotlSenderKeyDistributionMessage.
         * @member {Uint8Array} axolotlSenderKeyDistributionMessage
         * @memberof Message.WhisperSenderKeyDistributionMessage
         * @instance
         */
        WhisperSenderKeyDistributionMessage.prototype.axolotlSenderKeyDistributionMessage = $util.newBuffer([]);

        /**
         * Creates a new WhisperSenderKeyDistributionMessage instance using the specified properties.
         * @function create
         * @memberof Message.WhisperSenderKeyDistributionMessage
         * @static
         * @param {Message.IWhisperSenderKeyDistributionMessage=} [properties] Properties to set
         * @returns {Message.WhisperSenderKeyDistributionMessage} WhisperSenderKeyDistributionMessage instance
         */
        WhisperSenderKeyDistributionMessage.create = function create(properties) {
            return new WhisperSenderKeyDistributionMessage(properties);
        };

        /**
         * Encodes the specified WhisperSenderKeyDistributionMessage message. Does not implicitly {@link Message.WhisperSenderKeyDistributionMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.WhisperSenderKeyDistributionMessage
         * @static
         * @param {Message.IWhisperSenderKeyDistributionMessage} message WhisperSenderKeyDistributionMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WhisperSenderKeyDistributionMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupId);
            if (message.axolotlSenderKeyDistributionMessage != null && Object.hasOwnProperty.call(message, "axolotlSenderKeyDistributionMessage"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.axolotlSenderKeyDistributionMessage);
            return writer;
        };

        /**
         * Encodes the specified WhisperSenderKeyDistributionMessage message, length delimited. Does not implicitly {@link Message.WhisperSenderKeyDistributionMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.WhisperSenderKeyDistributionMessage
         * @static
         * @param {Message.IWhisperSenderKeyDistributionMessage} message WhisperSenderKeyDistributionMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WhisperSenderKeyDistributionMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WhisperSenderKeyDistributionMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.WhisperSenderKeyDistributionMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.WhisperSenderKeyDistributionMessage} WhisperSenderKeyDistributionMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WhisperSenderKeyDistributionMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.WhisperSenderKeyDistributionMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.groupId = reader.string();
                    break;
                case 2:
                    message.axolotlSenderKeyDistributionMessage = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WhisperSenderKeyDistributionMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.WhisperSenderKeyDistributionMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.WhisperSenderKeyDistributionMessage} WhisperSenderKeyDistributionMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WhisperSenderKeyDistributionMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WhisperSenderKeyDistributionMessage message.
         * @function verify
         * @memberof Message.WhisperSenderKeyDistributionMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WhisperSenderKeyDistributionMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (!$util.isString(message.groupId))
                    return "groupId: string expected";
            if (message.axolotlSenderKeyDistributionMessage != null && message.hasOwnProperty("axolotlSenderKeyDistributionMessage"))
                if (!(message.axolotlSenderKeyDistributionMessage && typeof message.axolotlSenderKeyDistributionMessage.length === "number" || $util.isString(message.axolotlSenderKeyDistributionMessage)))
                    return "axolotlSenderKeyDistributionMessage: buffer expected";
            return null;
        };

        /**
         * Creates a WhisperSenderKeyDistributionMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.WhisperSenderKeyDistributionMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.WhisperSenderKeyDistributionMessage} WhisperSenderKeyDistributionMessage
         */
        WhisperSenderKeyDistributionMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.WhisperSenderKeyDistributionMessage)
                return object;
            var message = new $root.Message.WhisperSenderKeyDistributionMessage();
            if (object.groupId != null)
                message.groupId = String(object.groupId);
            if (object.axolotlSenderKeyDistributionMessage != null)
                if (typeof object.axolotlSenderKeyDistributionMessage === "string")
                    $util.base64.decode(object.axolotlSenderKeyDistributionMessage, message.axolotlSenderKeyDistributionMessage = $util.newBuffer($util.base64.length(object.axolotlSenderKeyDistributionMessage)), 0);
                else if (object.axolotlSenderKeyDistributionMessage.length)
                    message.axolotlSenderKeyDistributionMessage = object.axolotlSenderKeyDistributionMessage;
            return message;
        };

        /**
         * Creates a plain object from a WhisperSenderKeyDistributionMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.WhisperSenderKeyDistributionMessage
         * @static
         * @param {Message.WhisperSenderKeyDistributionMessage} message WhisperSenderKeyDistributionMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WhisperSenderKeyDistributionMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.groupId = "";
                if (options.bytes === String)
                    object.axolotlSenderKeyDistributionMessage = "";
                else {
                    object.axolotlSenderKeyDistributionMessage = [];
                    if (options.bytes !== Array)
                        object.axolotlSenderKeyDistributionMessage = $util.newBuffer(object.axolotlSenderKeyDistributionMessage);
                }
            }
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                object.groupId = message.groupId;
            if (message.axolotlSenderKeyDistributionMessage != null && message.hasOwnProperty("axolotlSenderKeyDistributionMessage"))
                object.axolotlSenderKeyDistributionMessage = options.bytes === String ? $util.base64.encode(message.axolotlSenderKeyDistributionMessage, 0, message.axolotlSenderKeyDistributionMessage.length) : options.bytes === Array ? Array.prototype.slice.call(message.axolotlSenderKeyDistributionMessage) : message.axolotlSenderKeyDistributionMessage;
            return object;
        };

        /**
         * Converts this WhisperSenderKeyDistributionMessage to JSON.
         * @function toJSON
         * @memberof Message.WhisperSenderKeyDistributionMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WhisperSenderKeyDistributionMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WhisperSenderKeyDistributionMessage;
    })();

    Message.ImageMessage = (function() {

        /**
         * Properties of an ImageMessage.
         * @memberof Message
         * @interface IImageMessage
         * @property {string|null} [url] ImageMessage url
         * @property {string|null} [mimetype] ImageMessage mimetype
         * @property {string|null} [caption] ImageMessage caption
         * @property {Uint8Array|null} [fileSha256] ImageMessage fileSha256
         * @property {number|Long|null} [fileLength] ImageMessage fileLength
         * @property {number|null} [height] ImageMessage height
         * @property {number|null} [width] ImageMessage width
         * @property {Uint8Array|null} [mediaKey] ImageMessage mediaKey
         * @property {Uint8Array|null} [fileEncSha256] ImageMessage fileEncSha256
         * @property {Array.<Message.IInteractiveAnnotation>|null} [interactiveAnnotations] ImageMessage interactiveAnnotations
         * @property {string|null} [directPath] ImageMessage directPath
         * @property {number|Long|null} [mediaKeyTimestamp] ImageMessage mediaKeyTimestamp
         * @property {Uint8Array|null} [jpegThumbnail] ImageMessage jpegThumbnail
         * @property {Message.IContextInfo|null} [contextInfo] ImageMessage contextInfo
         * @property {Uint8Array|null} [firstScanSidecar] ImageMessage firstScanSidecar
         * @property {number|null} [firstScanLength] ImageMessage firstScanLength
         * @property {number|null} [experimentGroupId] ImageMessage experimentGroupId
         * @property {Uint8Array|null} [scansSidecar] ImageMessage scansSidecar
         * @property {Array.<number>|null} [scanLengths] ImageMessage scanLengths
         * @property {Uint8Array|null} [midQualityFileSha256] ImageMessage midQualityFileSha256
         * @property {Uint8Array|null} [midQualityFileEncSha256] ImageMessage midQualityFileEncSha256
         */

        /**
         * Constructs a new ImageMessage.
         * @memberof Message
         * @classdesc Represents an ImageMessage.
         * @implements IImageMessage
         * @constructor
         * @param {Message.IImageMessage=} [properties] Properties to set
         */
        function ImageMessage(properties) {
            this.interactiveAnnotations = [];
            this.scanLengths = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImageMessage url.
         * @member {string} url
         * @memberof Message.ImageMessage
         * @instance
         */
        ImageMessage.prototype.url = "";

        /**
         * ImageMessage mimetype.
         * @member {string} mimetype
         * @memberof Message.ImageMessage
         * @instance
         */
        ImageMessage.prototype.mimetype = "";

        /**
         * ImageMessage caption.
         * @member {string} caption
         * @memberof Message.ImageMessage
         * @instance
         */
        ImageMessage.prototype.caption = "";

        /**
         * ImageMessage fileSha256.
         * @member {Uint8Array} fileSha256
         * @memberof Message.ImageMessage
         * @instance
         */
        ImageMessage.prototype.fileSha256 = $util.newBuffer([]);

        /**
         * ImageMessage fileLength.
         * @member {number|Long} fileLength
         * @memberof Message.ImageMessage
         * @instance
         */
        ImageMessage.prototype.fileLength = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ImageMessage height.
         * @member {number} height
         * @memberof Message.ImageMessage
         * @instance
         */
        ImageMessage.prototype.height = 0;

        /**
         * ImageMessage width.
         * @member {number} width
         * @memberof Message.ImageMessage
         * @instance
         */
        ImageMessage.prototype.width = 0;

        /**
         * ImageMessage mediaKey.
         * @member {Uint8Array} mediaKey
         * @memberof Message.ImageMessage
         * @instance
         */
        ImageMessage.prototype.mediaKey = $util.newBuffer([]);

        /**
         * ImageMessage fileEncSha256.
         * @member {Uint8Array} fileEncSha256
         * @memberof Message.ImageMessage
         * @instance
         */
        ImageMessage.prototype.fileEncSha256 = $util.newBuffer([]);

        /**
         * ImageMessage interactiveAnnotations.
         * @member {Array.<Message.IInteractiveAnnotation>} interactiveAnnotations
         * @memberof Message.ImageMessage
         * @instance
         */
        ImageMessage.prototype.interactiveAnnotations = $util.emptyArray;

        /**
         * ImageMessage directPath.
         * @member {string} directPath
         * @memberof Message.ImageMessage
         * @instance
         */
        ImageMessage.prototype.directPath = "";

        /**
         * ImageMessage mediaKeyTimestamp.
         * @member {number|Long} mediaKeyTimestamp
         * @memberof Message.ImageMessage
         * @instance
         */
        ImageMessage.prototype.mediaKeyTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ImageMessage jpegThumbnail.
         * @member {Uint8Array} jpegThumbnail
         * @memberof Message.ImageMessage
         * @instance
         */
        ImageMessage.prototype.jpegThumbnail = $util.newBuffer([]);

        /**
         * ImageMessage contextInfo.
         * @member {Message.IContextInfo|null|undefined} contextInfo
         * @memberof Message.ImageMessage
         * @instance
         */
        ImageMessage.prototype.contextInfo = null;

        /**
         * ImageMessage firstScanSidecar.
         * @member {Uint8Array} firstScanSidecar
         * @memberof Message.ImageMessage
         * @instance
         */
        ImageMessage.prototype.firstScanSidecar = $util.newBuffer([]);

        /**
         * ImageMessage firstScanLength.
         * @member {number} firstScanLength
         * @memberof Message.ImageMessage
         * @instance
         */
        ImageMessage.prototype.firstScanLength = 0;

        /**
         * ImageMessage experimentGroupId.
         * @member {number} experimentGroupId
         * @memberof Message.ImageMessage
         * @instance
         */
        ImageMessage.prototype.experimentGroupId = 0;

        /**
         * ImageMessage scansSidecar.
         * @member {Uint8Array} scansSidecar
         * @memberof Message.ImageMessage
         * @instance
         */
        ImageMessage.prototype.scansSidecar = $util.newBuffer([]);

        /**
         * ImageMessage scanLengths.
         * @member {Array.<number>} scanLengths
         * @memberof Message.ImageMessage
         * @instance
         */
        ImageMessage.prototype.scanLengths = $util.emptyArray;

        /**
         * ImageMessage midQualityFileSha256.
         * @member {Uint8Array} midQualityFileSha256
         * @memberof Message.ImageMessage
         * @instance
         */
        ImageMessage.prototype.midQualityFileSha256 = $util.newBuffer([]);

        /**
         * ImageMessage midQualityFileEncSha256.
         * @member {Uint8Array} midQualityFileEncSha256
         * @memberof Message.ImageMessage
         * @instance
         */
        ImageMessage.prototype.midQualityFileEncSha256 = $util.newBuffer([]);

        /**
         * Creates a new ImageMessage instance using the specified properties.
         * @function create
         * @memberof Message.ImageMessage
         * @static
         * @param {Message.IImageMessage=} [properties] Properties to set
         * @returns {Message.ImageMessage} ImageMessage instance
         */
        ImageMessage.create = function create(properties) {
            return new ImageMessage(properties);
        };

        /**
         * Encodes the specified ImageMessage message. Does not implicitly {@link Message.ImageMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.ImageMessage
         * @static
         * @param {Message.IImageMessage} message ImageMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImageMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
            if (message.mimetype != null && Object.hasOwnProperty.call(message, "mimetype"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.mimetype);
            if (message.caption != null && Object.hasOwnProperty.call(message, "caption"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.caption);
            if (message.fileSha256 != null && Object.hasOwnProperty.call(message, "fileSha256"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.fileSha256);
            if (message.fileLength != null && Object.hasOwnProperty.call(message, "fileLength"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.fileLength);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.height);
            if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.width);
            if (message.mediaKey != null && Object.hasOwnProperty.call(message, "mediaKey"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.mediaKey);
            if (message.fileEncSha256 != null && Object.hasOwnProperty.call(message, "fileEncSha256"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.fileEncSha256);
            if (message.interactiveAnnotations != null && message.interactiveAnnotations.length)
                for (var i = 0; i < message.interactiveAnnotations.length; ++i)
                    $root.Message.InteractiveAnnotation.encode(message.interactiveAnnotations[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.directPath != null && Object.hasOwnProperty.call(message, "directPath"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.directPath);
            if (message.mediaKeyTimestamp != null && Object.hasOwnProperty.call(message, "mediaKeyTimestamp"))
                writer.uint32(/* id 12, wireType 0 =*/96).int64(message.mediaKeyTimestamp);
            if (message.jpegThumbnail != null && Object.hasOwnProperty.call(message, "jpegThumbnail"))
                writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.jpegThumbnail);
            if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                $root.Message.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.firstScanSidecar != null && Object.hasOwnProperty.call(message, "firstScanSidecar"))
                writer.uint32(/* id 18, wireType 2 =*/146).bytes(message.firstScanSidecar);
            if (message.firstScanLength != null && Object.hasOwnProperty.call(message, "firstScanLength"))
                writer.uint32(/* id 19, wireType 0 =*/152).uint32(message.firstScanLength);
            if (message.experimentGroupId != null && Object.hasOwnProperty.call(message, "experimentGroupId"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.experimentGroupId);
            if (message.scansSidecar != null && Object.hasOwnProperty.call(message, "scansSidecar"))
                writer.uint32(/* id 21, wireType 2 =*/170).bytes(message.scansSidecar);
            if (message.scanLengths != null && message.scanLengths.length)
                for (var i = 0; i < message.scanLengths.length; ++i)
                    writer.uint32(/* id 22, wireType 0 =*/176).uint32(message.scanLengths[i]);
            if (message.midQualityFileSha256 != null && Object.hasOwnProperty.call(message, "midQualityFileSha256"))
                writer.uint32(/* id 23, wireType 2 =*/186).bytes(message.midQualityFileSha256);
            if (message.midQualityFileEncSha256 != null && Object.hasOwnProperty.call(message, "midQualityFileEncSha256"))
                writer.uint32(/* id 24, wireType 2 =*/194).bytes(message.midQualityFileEncSha256);
            return writer;
        };

        /**
         * Encodes the specified ImageMessage message, length delimited. Does not implicitly {@link Message.ImageMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.ImageMessage
         * @static
         * @param {Message.IImageMessage} message ImageMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImageMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImageMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.ImageMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.ImageMessage} ImageMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImageMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.ImageMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.url = reader.string();
                    break;
                case 2:
                    message.mimetype = reader.string();
                    break;
                case 3:
                    message.caption = reader.string();
                    break;
                case 4:
                    message.fileSha256 = reader.bytes();
                    break;
                case 5:
                    message.fileLength = reader.uint64();
                    break;
                case 6:
                    message.height = reader.uint32();
                    break;
                case 7:
                    message.width = reader.uint32();
                    break;
                case 8:
                    message.mediaKey = reader.bytes();
                    break;
                case 9:
                    message.fileEncSha256 = reader.bytes();
                    break;
                case 10:
                    if (!(message.interactiveAnnotations && message.interactiveAnnotations.length))
                        message.interactiveAnnotations = [];
                    message.interactiveAnnotations.push($root.Message.InteractiveAnnotation.decode(reader, reader.uint32()));
                    break;
                case 11:
                    message.directPath = reader.string();
                    break;
                case 12:
                    message.mediaKeyTimestamp = reader.int64();
                    break;
                case 16:
                    message.jpegThumbnail = reader.bytes();
                    break;
                case 17:
                    message.contextInfo = $root.Message.ContextInfo.decode(reader, reader.uint32());
                    break;
                case 18:
                    message.firstScanSidecar = reader.bytes();
                    break;
                case 19:
                    message.firstScanLength = reader.uint32();
                    break;
                case 20:
                    message.experimentGroupId = reader.uint32();
                    break;
                case 21:
                    message.scansSidecar = reader.bytes();
                    break;
                case 22:
                    if (!(message.scanLengths && message.scanLengths.length))
                        message.scanLengths = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.scanLengths.push(reader.uint32());
                    } else
                        message.scanLengths.push(reader.uint32());
                    break;
                case 23:
                    message.midQualityFileSha256 = reader.bytes();
                    break;
                case 24:
                    message.midQualityFileEncSha256 = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImageMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.ImageMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.ImageMessage} ImageMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImageMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImageMessage message.
         * @function verify
         * @memberof Message.ImageMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImageMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                if (!$util.isString(message.mimetype))
                    return "mimetype: string expected";
            if (message.caption != null && message.hasOwnProperty("caption"))
                if (!$util.isString(message.caption))
                    return "caption: string expected";
            if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                if (!(message.fileSha256 && typeof message.fileSha256.length === "number" || $util.isString(message.fileSha256)))
                    return "fileSha256: buffer expected";
            if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                if (!$util.isInteger(message.fileLength) && !(message.fileLength && $util.isInteger(message.fileLength.low) && $util.isInteger(message.fileLength.high)))
                    return "fileLength: integer|Long expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (!$util.isInteger(message.height))
                    return "height: integer expected";
            if (message.width != null && message.hasOwnProperty("width"))
                if (!$util.isInteger(message.width))
                    return "width: integer expected";
            if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                if (!(message.mediaKey && typeof message.mediaKey.length === "number" || $util.isString(message.mediaKey)))
                    return "mediaKey: buffer expected";
            if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                if (!(message.fileEncSha256 && typeof message.fileEncSha256.length === "number" || $util.isString(message.fileEncSha256)))
                    return "fileEncSha256: buffer expected";
            if (message.interactiveAnnotations != null && message.hasOwnProperty("interactiveAnnotations")) {
                if (!Array.isArray(message.interactiveAnnotations))
                    return "interactiveAnnotations: array expected";
                for (var i = 0; i < message.interactiveAnnotations.length; ++i) {
                    var error = $root.Message.InteractiveAnnotation.verify(message.interactiveAnnotations[i]);
                    if (error)
                        return "interactiveAnnotations." + error;
                }
            }
            if (message.directPath != null && message.hasOwnProperty("directPath"))
                if (!$util.isString(message.directPath))
                    return "directPath: string expected";
            if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                if (!$util.isInteger(message.mediaKeyTimestamp) && !(message.mediaKeyTimestamp && $util.isInteger(message.mediaKeyTimestamp.low) && $util.isInteger(message.mediaKeyTimestamp.high)))
                    return "mediaKeyTimestamp: integer|Long expected";
            if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                if (!(message.jpegThumbnail && typeof message.jpegThumbnail.length === "number" || $util.isString(message.jpegThumbnail)))
                    return "jpegThumbnail: buffer expected";
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                var error = $root.Message.ContextInfo.verify(message.contextInfo);
                if (error)
                    return "contextInfo." + error;
            }
            if (message.firstScanSidecar != null && message.hasOwnProperty("firstScanSidecar"))
                if (!(message.firstScanSidecar && typeof message.firstScanSidecar.length === "number" || $util.isString(message.firstScanSidecar)))
                    return "firstScanSidecar: buffer expected";
            if (message.firstScanLength != null && message.hasOwnProperty("firstScanLength"))
                if (!$util.isInteger(message.firstScanLength))
                    return "firstScanLength: integer expected";
            if (message.experimentGroupId != null && message.hasOwnProperty("experimentGroupId"))
                if (!$util.isInteger(message.experimentGroupId))
                    return "experimentGroupId: integer expected";
            if (message.scansSidecar != null && message.hasOwnProperty("scansSidecar"))
                if (!(message.scansSidecar && typeof message.scansSidecar.length === "number" || $util.isString(message.scansSidecar)))
                    return "scansSidecar: buffer expected";
            if (message.scanLengths != null && message.hasOwnProperty("scanLengths")) {
                if (!Array.isArray(message.scanLengths))
                    return "scanLengths: array expected";
                for (var i = 0; i < message.scanLengths.length; ++i)
                    if (!$util.isInteger(message.scanLengths[i]))
                        return "scanLengths: integer[] expected";
            }
            if (message.midQualityFileSha256 != null && message.hasOwnProperty("midQualityFileSha256"))
                if (!(message.midQualityFileSha256 && typeof message.midQualityFileSha256.length === "number" || $util.isString(message.midQualityFileSha256)))
                    return "midQualityFileSha256: buffer expected";
            if (message.midQualityFileEncSha256 != null && message.hasOwnProperty("midQualityFileEncSha256"))
                if (!(message.midQualityFileEncSha256 && typeof message.midQualityFileEncSha256.length === "number" || $util.isString(message.midQualityFileEncSha256)))
                    return "midQualityFileEncSha256: buffer expected";
            return null;
        };

        /**
         * Creates an ImageMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.ImageMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.ImageMessage} ImageMessage
         */
        ImageMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.ImageMessage)
                return object;
            var message = new $root.Message.ImageMessage();
            if (object.url != null)
                message.url = String(object.url);
            if (object.mimetype != null)
                message.mimetype = String(object.mimetype);
            if (object.caption != null)
                message.caption = String(object.caption);
            if (object.fileSha256 != null)
                if (typeof object.fileSha256 === "string")
                    $util.base64.decode(object.fileSha256, message.fileSha256 = $util.newBuffer($util.base64.length(object.fileSha256)), 0);
                else if (object.fileSha256.length)
                    message.fileSha256 = object.fileSha256;
            if (object.fileLength != null)
                if ($util.Long)
                    (message.fileLength = $util.Long.fromValue(object.fileLength)).unsigned = true;
                else if (typeof object.fileLength === "string")
                    message.fileLength = parseInt(object.fileLength, 10);
                else if (typeof object.fileLength === "number")
                    message.fileLength = object.fileLength;
                else if (typeof object.fileLength === "object")
                    message.fileLength = new $util.LongBits(object.fileLength.low >>> 0, object.fileLength.high >>> 0).toNumber(true);
            if (object.height != null)
                message.height = object.height >>> 0;
            if (object.width != null)
                message.width = object.width >>> 0;
            if (object.mediaKey != null)
                if (typeof object.mediaKey === "string")
                    $util.base64.decode(object.mediaKey, message.mediaKey = $util.newBuffer($util.base64.length(object.mediaKey)), 0);
                else if (object.mediaKey.length)
                    message.mediaKey = object.mediaKey;
            if (object.fileEncSha256 != null)
                if (typeof object.fileEncSha256 === "string")
                    $util.base64.decode(object.fileEncSha256, message.fileEncSha256 = $util.newBuffer($util.base64.length(object.fileEncSha256)), 0);
                else if (object.fileEncSha256.length)
                    message.fileEncSha256 = object.fileEncSha256;
            if (object.interactiveAnnotations) {
                if (!Array.isArray(object.interactiveAnnotations))
                    throw TypeError(".Message.ImageMessage.interactiveAnnotations: array expected");
                message.interactiveAnnotations = [];
                for (var i = 0; i < object.interactiveAnnotations.length; ++i) {
                    if (typeof object.interactiveAnnotations[i] !== "object")
                        throw TypeError(".Message.ImageMessage.interactiveAnnotations: object expected");
                    message.interactiveAnnotations[i] = $root.Message.InteractiveAnnotation.fromObject(object.interactiveAnnotations[i]);
                }
            }
            if (object.directPath != null)
                message.directPath = String(object.directPath);
            if (object.mediaKeyTimestamp != null)
                if ($util.Long)
                    (message.mediaKeyTimestamp = $util.Long.fromValue(object.mediaKeyTimestamp)).unsigned = false;
                else if (typeof object.mediaKeyTimestamp === "string")
                    message.mediaKeyTimestamp = parseInt(object.mediaKeyTimestamp, 10);
                else if (typeof object.mediaKeyTimestamp === "number")
                    message.mediaKeyTimestamp = object.mediaKeyTimestamp;
                else if (typeof object.mediaKeyTimestamp === "object")
                    message.mediaKeyTimestamp = new $util.LongBits(object.mediaKeyTimestamp.low >>> 0, object.mediaKeyTimestamp.high >>> 0).toNumber();
            if (object.jpegThumbnail != null)
                if (typeof object.jpegThumbnail === "string")
                    $util.base64.decode(object.jpegThumbnail, message.jpegThumbnail = $util.newBuffer($util.base64.length(object.jpegThumbnail)), 0);
                else if (object.jpegThumbnail.length)
                    message.jpegThumbnail = object.jpegThumbnail;
            if (object.contextInfo != null) {
                if (typeof object.contextInfo !== "object")
                    throw TypeError(".Message.ImageMessage.contextInfo: object expected");
                message.contextInfo = $root.Message.ContextInfo.fromObject(object.contextInfo);
            }
            if (object.firstScanSidecar != null)
                if (typeof object.firstScanSidecar === "string")
                    $util.base64.decode(object.firstScanSidecar, message.firstScanSidecar = $util.newBuffer($util.base64.length(object.firstScanSidecar)), 0);
                else if (object.firstScanSidecar.length)
                    message.firstScanSidecar = object.firstScanSidecar;
            if (object.firstScanLength != null)
                message.firstScanLength = object.firstScanLength >>> 0;
            if (object.experimentGroupId != null)
                message.experimentGroupId = object.experimentGroupId >>> 0;
            if (object.scansSidecar != null)
                if (typeof object.scansSidecar === "string")
                    $util.base64.decode(object.scansSidecar, message.scansSidecar = $util.newBuffer($util.base64.length(object.scansSidecar)), 0);
                else if (object.scansSidecar.length)
                    message.scansSidecar = object.scansSidecar;
            if (object.scanLengths) {
                if (!Array.isArray(object.scanLengths))
                    throw TypeError(".Message.ImageMessage.scanLengths: array expected");
                message.scanLengths = [];
                for (var i = 0; i < object.scanLengths.length; ++i)
                    message.scanLengths[i] = object.scanLengths[i] >>> 0;
            }
            if (object.midQualityFileSha256 != null)
                if (typeof object.midQualityFileSha256 === "string")
                    $util.base64.decode(object.midQualityFileSha256, message.midQualityFileSha256 = $util.newBuffer($util.base64.length(object.midQualityFileSha256)), 0);
                else if (object.midQualityFileSha256.length)
                    message.midQualityFileSha256 = object.midQualityFileSha256;
            if (object.midQualityFileEncSha256 != null)
                if (typeof object.midQualityFileEncSha256 === "string")
                    $util.base64.decode(object.midQualityFileEncSha256, message.midQualityFileEncSha256 = $util.newBuffer($util.base64.length(object.midQualityFileEncSha256)), 0);
                else if (object.midQualityFileEncSha256.length)
                    message.midQualityFileEncSha256 = object.midQualityFileEncSha256;
            return message;
        };

        /**
         * Creates a plain object from an ImageMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.ImageMessage
         * @static
         * @param {Message.ImageMessage} message ImageMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImageMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.interactiveAnnotations = [];
                object.scanLengths = [];
            }
            if (options.defaults) {
                object.url = "";
                object.mimetype = "";
                object.caption = "";
                if (options.bytes === String)
                    object.fileSha256 = "";
                else {
                    object.fileSha256 = [];
                    if (options.bytes !== Array)
                        object.fileSha256 = $util.newBuffer(object.fileSha256);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.fileLength = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fileLength = options.longs === String ? "0" : 0;
                object.height = 0;
                object.width = 0;
                if (options.bytes === String)
                    object.mediaKey = "";
                else {
                    object.mediaKey = [];
                    if (options.bytes !== Array)
                        object.mediaKey = $util.newBuffer(object.mediaKey);
                }
                if (options.bytes === String)
                    object.fileEncSha256 = "";
                else {
                    object.fileEncSha256 = [];
                    if (options.bytes !== Array)
                        object.fileEncSha256 = $util.newBuffer(object.fileEncSha256);
                }
                object.directPath = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.mediaKeyTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.mediaKeyTimestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.jpegThumbnail = "";
                else {
                    object.jpegThumbnail = [];
                    if (options.bytes !== Array)
                        object.jpegThumbnail = $util.newBuffer(object.jpegThumbnail);
                }
                object.contextInfo = null;
                if (options.bytes === String)
                    object.firstScanSidecar = "";
                else {
                    object.firstScanSidecar = [];
                    if (options.bytes !== Array)
                        object.firstScanSidecar = $util.newBuffer(object.firstScanSidecar);
                }
                object.firstScanLength = 0;
                object.experimentGroupId = 0;
                if (options.bytes === String)
                    object.scansSidecar = "";
                else {
                    object.scansSidecar = [];
                    if (options.bytes !== Array)
                        object.scansSidecar = $util.newBuffer(object.scansSidecar);
                }
                if (options.bytes === String)
                    object.midQualityFileSha256 = "";
                else {
                    object.midQualityFileSha256 = [];
                    if (options.bytes !== Array)
                        object.midQualityFileSha256 = $util.newBuffer(object.midQualityFileSha256);
                }
                if (options.bytes === String)
                    object.midQualityFileEncSha256 = "";
                else {
                    object.midQualityFileEncSha256 = [];
                    if (options.bytes !== Array)
                        object.midQualityFileEncSha256 = $util.newBuffer(object.midQualityFileEncSha256);
                }
            }
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                object.mimetype = message.mimetype;
            if (message.caption != null && message.hasOwnProperty("caption"))
                object.caption = message.caption;
            if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                object.fileSha256 = options.bytes === String ? $util.base64.encode(message.fileSha256, 0, message.fileSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileSha256) : message.fileSha256;
            if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                if (typeof message.fileLength === "number")
                    object.fileLength = options.longs === String ? String(message.fileLength) : message.fileLength;
                else
                    object.fileLength = options.longs === String ? $util.Long.prototype.toString.call(message.fileLength) : options.longs === Number ? new $util.LongBits(message.fileLength.low >>> 0, message.fileLength.high >>> 0).toNumber(true) : message.fileLength;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = message.height;
            if (message.width != null && message.hasOwnProperty("width"))
                object.width = message.width;
            if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                object.mediaKey = options.bytes === String ? $util.base64.encode(message.mediaKey, 0, message.mediaKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.mediaKey) : message.mediaKey;
            if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                object.fileEncSha256 = options.bytes === String ? $util.base64.encode(message.fileEncSha256, 0, message.fileEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileEncSha256) : message.fileEncSha256;
            if (message.interactiveAnnotations && message.interactiveAnnotations.length) {
                object.interactiveAnnotations = [];
                for (var j = 0; j < message.interactiveAnnotations.length; ++j)
                    object.interactiveAnnotations[j] = $root.Message.InteractiveAnnotation.toObject(message.interactiveAnnotations[j], options);
            }
            if (message.directPath != null && message.hasOwnProperty("directPath"))
                object.directPath = message.directPath;
            if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                if (typeof message.mediaKeyTimestamp === "number")
                    object.mediaKeyTimestamp = options.longs === String ? String(message.mediaKeyTimestamp) : message.mediaKeyTimestamp;
                else
                    object.mediaKeyTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.mediaKeyTimestamp) : options.longs === Number ? new $util.LongBits(message.mediaKeyTimestamp.low >>> 0, message.mediaKeyTimestamp.high >>> 0).toNumber() : message.mediaKeyTimestamp;
            if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                object.jpegThumbnail = options.bytes === String ? $util.base64.encode(message.jpegThumbnail, 0, message.jpegThumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.jpegThumbnail) : message.jpegThumbnail;
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                object.contextInfo = $root.Message.ContextInfo.toObject(message.contextInfo, options);
            if (message.firstScanSidecar != null && message.hasOwnProperty("firstScanSidecar"))
                object.firstScanSidecar = options.bytes === String ? $util.base64.encode(message.firstScanSidecar, 0, message.firstScanSidecar.length) : options.bytes === Array ? Array.prototype.slice.call(message.firstScanSidecar) : message.firstScanSidecar;
            if (message.firstScanLength != null && message.hasOwnProperty("firstScanLength"))
                object.firstScanLength = message.firstScanLength;
            if (message.experimentGroupId != null && message.hasOwnProperty("experimentGroupId"))
                object.experimentGroupId = message.experimentGroupId;
            if (message.scansSidecar != null && message.hasOwnProperty("scansSidecar"))
                object.scansSidecar = options.bytes === String ? $util.base64.encode(message.scansSidecar, 0, message.scansSidecar.length) : options.bytes === Array ? Array.prototype.slice.call(message.scansSidecar) : message.scansSidecar;
            if (message.scanLengths && message.scanLengths.length) {
                object.scanLengths = [];
                for (var j = 0; j < message.scanLengths.length; ++j)
                    object.scanLengths[j] = message.scanLengths[j];
            }
            if (message.midQualityFileSha256 != null && message.hasOwnProperty("midQualityFileSha256"))
                object.midQualityFileSha256 = options.bytes === String ? $util.base64.encode(message.midQualityFileSha256, 0, message.midQualityFileSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.midQualityFileSha256) : message.midQualityFileSha256;
            if (message.midQualityFileEncSha256 != null && message.hasOwnProperty("midQualityFileEncSha256"))
                object.midQualityFileEncSha256 = options.bytes === String ? $util.base64.encode(message.midQualityFileEncSha256, 0, message.midQualityFileEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.midQualityFileEncSha256) : message.midQualityFileEncSha256;
            return object;
        };

        /**
         * Converts this ImageMessage to JSON.
         * @function toJSON
         * @memberof Message.ImageMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImageMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ImageMessage;
    })();

    Message.ContactMessage = (function() {

        /**
         * Properties of a ContactMessage.
         * @memberof Message
         * @interface IContactMessage
         * @property {string|null} [displayName] ContactMessage displayName
         * @property {string|null} [vcard] ContactMessage vcard
         * @property {Message.IContextInfo|null} [contextInfo] ContactMessage contextInfo
         */

        /**
         * Constructs a new ContactMessage.
         * @memberof Message
         * @classdesc Represents a ContactMessage.
         * @implements IContactMessage
         * @constructor
         * @param {Message.IContactMessage=} [properties] Properties to set
         */
        function ContactMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContactMessage displayName.
         * @member {string} displayName
         * @memberof Message.ContactMessage
         * @instance
         */
        ContactMessage.prototype.displayName = "";

        /**
         * ContactMessage vcard.
         * @member {string} vcard
         * @memberof Message.ContactMessage
         * @instance
         */
        ContactMessage.prototype.vcard = "";

        /**
         * ContactMessage contextInfo.
         * @member {Message.IContextInfo|null|undefined} contextInfo
         * @memberof Message.ContactMessage
         * @instance
         */
        ContactMessage.prototype.contextInfo = null;

        /**
         * Creates a new ContactMessage instance using the specified properties.
         * @function create
         * @memberof Message.ContactMessage
         * @static
         * @param {Message.IContactMessage=} [properties] Properties to set
         * @returns {Message.ContactMessage} ContactMessage instance
         */
        ContactMessage.create = function create(properties) {
            return new ContactMessage(properties);
        };

        /**
         * Encodes the specified ContactMessage message. Does not implicitly {@link Message.ContactMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.ContactMessage
         * @static
         * @param {Message.IContactMessage} message ContactMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContactMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.displayName != null && Object.hasOwnProperty.call(message, "displayName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.displayName);
            if (message.vcard != null && Object.hasOwnProperty.call(message, "vcard"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.vcard);
            if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                $root.Message.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ContactMessage message, length delimited. Does not implicitly {@link Message.ContactMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.ContactMessage
         * @static
         * @param {Message.IContactMessage} message ContactMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContactMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContactMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.ContactMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.ContactMessage} ContactMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContactMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.ContactMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.displayName = reader.string();
                    break;
                case 16:
                    message.vcard = reader.string();
                    break;
                case 17:
                    message.contextInfo = $root.Message.ContextInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContactMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.ContactMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.ContactMessage} ContactMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContactMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContactMessage message.
         * @function verify
         * @memberof Message.ContactMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContactMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.displayName != null && message.hasOwnProperty("displayName"))
                if (!$util.isString(message.displayName))
                    return "displayName: string expected";
            if (message.vcard != null && message.hasOwnProperty("vcard"))
                if (!$util.isString(message.vcard))
                    return "vcard: string expected";
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                var error = $root.Message.ContextInfo.verify(message.contextInfo);
                if (error)
                    return "contextInfo." + error;
            }
            return null;
        };

        /**
         * Creates a ContactMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.ContactMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.ContactMessage} ContactMessage
         */
        ContactMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.ContactMessage)
                return object;
            var message = new $root.Message.ContactMessage();
            if (object.displayName != null)
                message.displayName = String(object.displayName);
            if (object.vcard != null)
                message.vcard = String(object.vcard);
            if (object.contextInfo != null) {
                if (typeof object.contextInfo !== "object")
                    throw TypeError(".Message.ContactMessage.contextInfo: object expected");
                message.contextInfo = $root.Message.ContextInfo.fromObject(object.contextInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a ContactMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.ContactMessage
         * @static
         * @param {Message.ContactMessage} message ContactMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContactMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.displayName = "";
                object.vcard = "";
                object.contextInfo = null;
            }
            if (message.displayName != null && message.hasOwnProperty("displayName"))
                object.displayName = message.displayName;
            if (message.vcard != null && message.hasOwnProperty("vcard"))
                object.vcard = message.vcard;
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                object.contextInfo = $root.Message.ContextInfo.toObject(message.contextInfo, options);
            return object;
        };

        /**
         * Converts this ContactMessage to JSON.
         * @function toJSON
         * @memberof Message.ContactMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContactMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ContactMessage;
    })();

    Message.LocationMessage = (function() {

        /**
         * Properties of a LocationMessage.
         * @memberof Message
         * @interface ILocationMessage
         * @property {number|null} [degreesLatitude] LocationMessage degreesLatitude
         * @property {number|null} [degreesLongitude] LocationMessage degreesLongitude
         * @property {string|null} [name] LocationMessage name
         * @property {string|null} [address] LocationMessage address
         * @property {string|null} [url] LocationMessage url
         * @property {boolean|null} [isLive] LocationMessage isLive
         * @property {number|null} [accuracyInMeters] LocationMessage accuracyInMeters
         * @property {number|null} [speedInMps] LocationMessage speedInMps
         * @property {number|null} [degreesClockwiseFromMagneticNorth] LocationMessage degreesClockwiseFromMagneticNorth
         * @property {string|null} [comment] LocationMessage comment
         * @property {Uint8Array|null} [jpegThumbnail] LocationMessage jpegThumbnail
         * @property {Message.IContextInfo|null} [contextInfo] LocationMessage contextInfo
         */

        /**
         * Constructs a new LocationMessage.
         * @memberof Message
         * @classdesc Represents a LocationMessage.
         * @implements ILocationMessage
         * @constructor
         * @param {Message.ILocationMessage=} [properties] Properties to set
         */
        function LocationMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LocationMessage degreesLatitude.
         * @member {number} degreesLatitude
         * @memberof Message.LocationMessage
         * @instance
         */
        LocationMessage.prototype.degreesLatitude = 0;

        /**
         * LocationMessage degreesLongitude.
         * @member {number} degreesLongitude
         * @memberof Message.LocationMessage
         * @instance
         */
        LocationMessage.prototype.degreesLongitude = 0;

        /**
         * LocationMessage name.
         * @member {string} name
         * @memberof Message.LocationMessage
         * @instance
         */
        LocationMessage.prototype.name = "";

        /**
         * LocationMessage address.
         * @member {string} address
         * @memberof Message.LocationMessage
         * @instance
         */
        LocationMessage.prototype.address = "";

        /**
         * LocationMessage url.
         * @member {string} url
         * @memberof Message.LocationMessage
         * @instance
         */
        LocationMessage.prototype.url = "";

        /**
         * LocationMessage isLive.
         * @member {boolean} isLive
         * @memberof Message.LocationMessage
         * @instance
         */
        LocationMessage.prototype.isLive = false;

        /**
         * LocationMessage accuracyInMeters.
         * @member {number} accuracyInMeters
         * @memberof Message.LocationMessage
         * @instance
         */
        LocationMessage.prototype.accuracyInMeters = 0;

        /**
         * LocationMessage speedInMps.
         * @member {number} speedInMps
         * @memberof Message.LocationMessage
         * @instance
         */
        LocationMessage.prototype.speedInMps = 0;

        /**
         * LocationMessage degreesClockwiseFromMagneticNorth.
         * @member {number} degreesClockwiseFromMagneticNorth
         * @memberof Message.LocationMessage
         * @instance
         */
        LocationMessage.prototype.degreesClockwiseFromMagneticNorth = 0;

        /**
         * LocationMessage comment.
         * @member {string} comment
         * @memberof Message.LocationMessage
         * @instance
         */
        LocationMessage.prototype.comment = "";

        /**
         * LocationMessage jpegThumbnail.
         * @member {Uint8Array} jpegThumbnail
         * @memberof Message.LocationMessage
         * @instance
         */
        LocationMessage.prototype.jpegThumbnail = $util.newBuffer([]);

        /**
         * LocationMessage contextInfo.
         * @member {Message.IContextInfo|null|undefined} contextInfo
         * @memberof Message.LocationMessage
         * @instance
         */
        LocationMessage.prototype.contextInfo = null;

        /**
         * Creates a new LocationMessage instance using the specified properties.
         * @function create
         * @memberof Message.LocationMessage
         * @static
         * @param {Message.ILocationMessage=} [properties] Properties to set
         * @returns {Message.LocationMessage} LocationMessage instance
         */
        LocationMessage.create = function create(properties) {
            return new LocationMessage(properties);
        };

        /**
         * Encodes the specified LocationMessage message. Does not implicitly {@link Message.LocationMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.LocationMessage
         * @static
         * @param {Message.ILocationMessage} message LocationMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LocationMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.degreesLatitude != null && Object.hasOwnProperty.call(message, "degreesLatitude"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.degreesLatitude);
            if (message.degreesLongitude != null && Object.hasOwnProperty.call(message, "degreesLongitude"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.degreesLongitude);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.address);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.url);
            if (message.isLive != null && Object.hasOwnProperty.call(message, "isLive"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isLive);
            if (message.accuracyInMeters != null && Object.hasOwnProperty.call(message, "accuracyInMeters"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.accuracyInMeters);
            if (message.speedInMps != null && Object.hasOwnProperty.call(message, "speedInMps"))
                writer.uint32(/* id 8, wireType 5 =*/69).float(message.speedInMps);
            if (message.degreesClockwiseFromMagneticNorth != null && Object.hasOwnProperty.call(message, "degreesClockwiseFromMagneticNorth"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.degreesClockwiseFromMagneticNorth);
            if (message.comment != null && Object.hasOwnProperty.call(message, "comment"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.comment);
            if (message.jpegThumbnail != null && Object.hasOwnProperty.call(message, "jpegThumbnail"))
                writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.jpegThumbnail);
            if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                $root.Message.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LocationMessage message, length delimited. Does not implicitly {@link Message.LocationMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.LocationMessage
         * @static
         * @param {Message.ILocationMessage} message LocationMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LocationMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LocationMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.LocationMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.LocationMessage} LocationMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LocationMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.LocationMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.degreesLatitude = reader.double();
                    break;
                case 2:
                    message.degreesLongitude = reader.double();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.address = reader.string();
                    break;
                case 5:
                    message.url = reader.string();
                    break;
                case 6:
                    message.isLive = reader.bool();
                    break;
                case 7:
                    message.accuracyInMeters = reader.uint32();
                    break;
                case 8:
                    message.speedInMps = reader.float();
                    break;
                case 9:
                    message.degreesClockwiseFromMagneticNorth = reader.uint32();
                    break;
                case 11:
                    message.comment = reader.string();
                    break;
                case 16:
                    message.jpegThumbnail = reader.bytes();
                    break;
                case 17:
                    message.contextInfo = $root.Message.ContextInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LocationMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.LocationMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.LocationMessage} LocationMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LocationMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LocationMessage message.
         * @function verify
         * @memberof Message.LocationMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LocationMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.degreesLatitude != null && message.hasOwnProperty("degreesLatitude"))
                if (typeof message.degreesLatitude !== "number")
                    return "degreesLatitude: number expected";
            if (message.degreesLongitude != null && message.hasOwnProperty("degreesLongitude"))
                if (typeof message.degreesLongitude !== "number")
                    return "degreesLongitude: number expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!$util.isString(message.address))
                    return "address: string expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.isLive != null && message.hasOwnProperty("isLive"))
                if (typeof message.isLive !== "boolean")
                    return "isLive: boolean expected";
            if (message.accuracyInMeters != null && message.hasOwnProperty("accuracyInMeters"))
                if (!$util.isInteger(message.accuracyInMeters))
                    return "accuracyInMeters: integer expected";
            if (message.speedInMps != null && message.hasOwnProperty("speedInMps"))
                if (typeof message.speedInMps !== "number")
                    return "speedInMps: number expected";
            if (message.degreesClockwiseFromMagneticNorth != null && message.hasOwnProperty("degreesClockwiseFromMagneticNorth"))
                if (!$util.isInteger(message.degreesClockwiseFromMagneticNorth))
                    return "degreesClockwiseFromMagneticNorth: integer expected";
            if (message.comment != null && message.hasOwnProperty("comment"))
                if (!$util.isString(message.comment))
                    return "comment: string expected";
            if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                if (!(message.jpegThumbnail && typeof message.jpegThumbnail.length === "number" || $util.isString(message.jpegThumbnail)))
                    return "jpegThumbnail: buffer expected";
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                var error = $root.Message.ContextInfo.verify(message.contextInfo);
                if (error)
                    return "contextInfo." + error;
            }
            return null;
        };

        /**
         * Creates a LocationMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.LocationMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.LocationMessage} LocationMessage
         */
        LocationMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.LocationMessage)
                return object;
            var message = new $root.Message.LocationMessage();
            if (object.degreesLatitude != null)
                message.degreesLatitude = Number(object.degreesLatitude);
            if (object.degreesLongitude != null)
                message.degreesLongitude = Number(object.degreesLongitude);
            if (object.name != null)
                message.name = String(object.name);
            if (object.address != null)
                message.address = String(object.address);
            if (object.url != null)
                message.url = String(object.url);
            if (object.isLive != null)
                message.isLive = Boolean(object.isLive);
            if (object.accuracyInMeters != null)
                message.accuracyInMeters = object.accuracyInMeters >>> 0;
            if (object.speedInMps != null)
                message.speedInMps = Number(object.speedInMps);
            if (object.degreesClockwiseFromMagneticNorth != null)
                message.degreesClockwiseFromMagneticNorth = object.degreesClockwiseFromMagneticNorth >>> 0;
            if (object.comment != null)
                message.comment = String(object.comment);
            if (object.jpegThumbnail != null)
                if (typeof object.jpegThumbnail === "string")
                    $util.base64.decode(object.jpegThumbnail, message.jpegThumbnail = $util.newBuffer($util.base64.length(object.jpegThumbnail)), 0);
                else if (object.jpegThumbnail.length)
                    message.jpegThumbnail = object.jpegThumbnail;
            if (object.contextInfo != null) {
                if (typeof object.contextInfo !== "object")
                    throw TypeError(".Message.LocationMessage.contextInfo: object expected");
                message.contextInfo = $root.Message.ContextInfo.fromObject(object.contextInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a LocationMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.LocationMessage
         * @static
         * @param {Message.LocationMessage} message LocationMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LocationMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.degreesLatitude = 0;
                object.degreesLongitude = 0;
                object.name = "";
                object.address = "";
                object.url = "";
                object.isLive = false;
                object.accuracyInMeters = 0;
                object.speedInMps = 0;
                object.degreesClockwiseFromMagneticNorth = 0;
                object.comment = "";
                if (options.bytes === String)
                    object.jpegThumbnail = "";
                else {
                    object.jpegThumbnail = [];
                    if (options.bytes !== Array)
                        object.jpegThumbnail = $util.newBuffer(object.jpegThumbnail);
                }
                object.contextInfo = null;
            }
            if (message.degreesLatitude != null && message.hasOwnProperty("degreesLatitude"))
                object.degreesLatitude = options.json && !isFinite(message.degreesLatitude) ? String(message.degreesLatitude) : message.degreesLatitude;
            if (message.degreesLongitude != null && message.hasOwnProperty("degreesLongitude"))
                object.degreesLongitude = options.json && !isFinite(message.degreesLongitude) ? String(message.degreesLongitude) : message.degreesLongitude;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = message.address;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.isLive != null && message.hasOwnProperty("isLive"))
                object.isLive = message.isLive;
            if (message.accuracyInMeters != null && message.hasOwnProperty("accuracyInMeters"))
                object.accuracyInMeters = message.accuracyInMeters;
            if (message.speedInMps != null && message.hasOwnProperty("speedInMps"))
                object.speedInMps = options.json && !isFinite(message.speedInMps) ? String(message.speedInMps) : message.speedInMps;
            if (message.degreesClockwiseFromMagneticNorth != null && message.hasOwnProperty("degreesClockwiseFromMagneticNorth"))
                object.degreesClockwiseFromMagneticNorth = message.degreesClockwiseFromMagneticNorth;
            if (message.comment != null && message.hasOwnProperty("comment"))
                object.comment = message.comment;
            if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                object.jpegThumbnail = options.bytes === String ? $util.base64.encode(message.jpegThumbnail, 0, message.jpegThumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.jpegThumbnail) : message.jpegThumbnail;
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                object.contextInfo = $root.Message.ContextInfo.toObject(message.contextInfo, options);
            return object;
        };

        /**
         * Converts this LocationMessage to JSON.
         * @function toJSON
         * @memberof Message.LocationMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LocationMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LocationMessage;
    })();

    Message.ExtendedTextMessage = (function() {

        /**
         * Properties of an ExtendedTextMessage.
         * @memberof Message
         * @interface IExtendedTextMessage
         * @property {string|null} [text] ExtendedTextMessage text
         * @property {string|null} [matchedText] ExtendedTextMessage matchedText
         * @property {string|null} [canonicalUrl] ExtendedTextMessage canonicalUrl
         * @property {string|null} [description] ExtendedTextMessage description
         * @property {string|null} [title] ExtendedTextMessage title
         * @property {number|null} [textArgb] ExtendedTextMessage textArgb
         * @property {number|null} [backgroundArgb] ExtendedTextMessage backgroundArgb
         * @property {Message.ExtendedTextMessage.EXTENDED_TEXT_MESSAGE_FONTTYPE|null} [font] ExtendedTextMessage font
         * @property {Message.ExtendedTextMessage.EXTENDED_TEXT_MESSAGE_PREVIEWTYPE|null} [previewType] ExtendedTextMessage previewType
         * @property {Uint8Array|null} [jpegThumbnail] ExtendedTextMessage jpegThumbnail
         * @property {Message.IContextInfo|null} [contextInfo] ExtendedTextMessage contextInfo
         * @property {boolean|null} [doNotPlayInline] ExtendedTextMessage doNotPlayInline
         */

        /**
         * Constructs a new ExtendedTextMessage.
         * @memberof Message
         * @classdesc Represents an ExtendedTextMessage.
         * @implements IExtendedTextMessage
         * @constructor
         * @param {Message.IExtendedTextMessage=} [properties] Properties to set
         */
        function ExtendedTextMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExtendedTextMessage text.
         * @member {string} text
         * @memberof Message.ExtendedTextMessage
         * @instance
         */
        ExtendedTextMessage.prototype.text = "";

        /**
         * ExtendedTextMessage matchedText.
         * @member {string} matchedText
         * @memberof Message.ExtendedTextMessage
         * @instance
         */
        ExtendedTextMessage.prototype.matchedText = "";

        /**
         * ExtendedTextMessage canonicalUrl.
         * @member {string} canonicalUrl
         * @memberof Message.ExtendedTextMessage
         * @instance
         */
        ExtendedTextMessage.prototype.canonicalUrl = "";

        /**
         * ExtendedTextMessage description.
         * @member {string} description
         * @memberof Message.ExtendedTextMessage
         * @instance
         */
        ExtendedTextMessage.prototype.description = "";

        /**
         * ExtendedTextMessage title.
         * @member {string} title
         * @memberof Message.ExtendedTextMessage
         * @instance
         */
        ExtendedTextMessage.prototype.title = "";

        /**
         * ExtendedTextMessage textArgb.
         * @member {number} textArgb
         * @memberof Message.ExtendedTextMessage
         * @instance
         */
        ExtendedTextMessage.prototype.textArgb = 0;

        /**
         * ExtendedTextMessage backgroundArgb.
         * @member {number} backgroundArgb
         * @memberof Message.ExtendedTextMessage
         * @instance
         */
        ExtendedTextMessage.prototype.backgroundArgb = 0;

        /**
         * ExtendedTextMessage font.
         * @member {Message.ExtendedTextMessage.EXTENDED_TEXT_MESSAGE_FONTTYPE} font
         * @memberof Message.ExtendedTextMessage
         * @instance
         */
        ExtendedTextMessage.prototype.font = 0;

        /**
         * ExtendedTextMessage previewType.
         * @member {Message.ExtendedTextMessage.EXTENDED_TEXT_MESSAGE_PREVIEWTYPE} previewType
         * @memberof Message.ExtendedTextMessage
         * @instance
         */
        ExtendedTextMessage.prototype.previewType = 0;

        /**
         * ExtendedTextMessage jpegThumbnail.
         * @member {Uint8Array} jpegThumbnail
         * @memberof Message.ExtendedTextMessage
         * @instance
         */
        ExtendedTextMessage.prototype.jpegThumbnail = $util.newBuffer([]);

        /**
         * ExtendedTextMessage contextInfo.
         * @member {Message.IContextInfo|null|undefined} contextInfo
         * @memberof Message.ExtendedTextMessage
         * @instance
         */
        ExtendedTextMessage.prototype.contextInfo = null;

        /**
         * ExtendedTextMessage doNotPlayInline.
         * @member {boolean} doNotPlayInline
         * @memberof Message.ExtendedTextMessage
         * @instance
         */
        ExtendedTextMessage.prototype.doNotPlayInline = false;

        /**
         * Creates a new ExtendedTextMessage instance using the specified properties.
         * @function create
         * @memberof Message.ExtendedTextMessage
         * @static
         * @param {Message.IExtendedTextMessage=} [properties] Properties to set
         * @returns {Message.ExtendedTextMessage} ExtendedTextMessage instance
         */
        ExtendedTextMessage.create = function create(properties) {
            return new ExtendedTextMessage(properties);
        };

        /**
         * Encodes the specified ExtendedTextMessage message. Does not implicitly {@link Message.ExtendedTextMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.ExtendedTextMessage
         * @static
         * @param {Message.IExtendedTextMessage} message ExtendedTextMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExtendedTextMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
            if (message.matchedText != null && Object.hasOwnProperty.call(message, "matchedText"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.matchedText);
            if (message.canonicalUrl != null && Object.hasOwnProperty.call(message, "canonicalUrl"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.canonicalUrl);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.title);
            if (message.textArgb != null && Object.hasOwnProperty.call(message, "textArgb"))
                writer.uint32(/* id 7, wireType 5 =*/61).fixed32(message.textArgb);
            if (message.backgroundArgb != null && Object.hasOwnProperty.call(message, "backgroundArgb"))
                writer.uint32(/* id 8, wireType 5 =*/69).fixed32(message.backgroundArgb);
            if (message.font != null && Object.hasOwnProperty.call(message, "font"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.font);
            if (message.previewType != null && Object.hasOwnProperty.call(message, "previewType"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.previewType);
            if (message.jpegThumbnail != null && Object.hasOwnProperty.call(message, "jpegThumbnail"))
                writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.jpegThumbnail);
            if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                $root.Message.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.doNotPlayInline != null && Object.hasOwnProperty.call(message, "doNotPlayInline"))
                writer.uint32(/* id 18, wireType 0 =*/144).bool(message.doNotPlayInline);
            return writer;
        };

        /**
         * Encodes the specified ExtendedTextMessage message, length delimited. Does not implicitly {@link Message.ExtendedTextMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.ExtendedTextMessage
         * @static
         * @param {Message.IExtendedTextMessage} message ExtendedTextMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExtendedTextMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExtendedTextMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.ExtendedTextMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.ExtendedTextMessage} ExtendedTextMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExtendedTextMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.ExtendedTextMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                case 2:
                    message.matchedText = reader.string();
                    break;
                case 4:
                    message.canonicalUrl = reader.string();
                    break;
                case 5:
                    message.description = reader.string();
                    break;
                case 6:
                    message.title = reader.string();
                    break;
                case 7:
                    message.textArgb = reader.fixed32();
                    break;
                case 8:
                    message.backgroundArgb = reader.fixed32();
                    break;
                case 9:
                    message.font = reader.int32();
                    break;
                case 10:
                    message.previewType = reader.int32();
                    break;
                case 16:
                    message.jpegThumbnail = reader.bytes();
                    break;
                case 17:
                    message.contextInfo = $root.Message.ContextInfo.decode(reader, reader.uint32());
                    break;
                case 18:
                    message.doNotPlayInline = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExtendedTextMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.ExtendedTextMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.ExtendedTextMessage} ExtendedTextMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExtendedTextMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExtendedTextMessage message.
         * @function verify
         * @memberof Message.ExtendedTextMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExtendedTextMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.matchedText != null && message.hasOwnProperty("matchedText"))
                if (!$util.isString(message.matchedText))
                    return "matchedText: string expected";
            if (message.canonicalUrl != null && message.hasOwnProperty("canonicalUrl"))
                if (!$util.isString(message.canonicalUrl))
                    return "canonicalUrl: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.textArgb != null && message.hasOwnProperty("textArgb"))
                if (!$util.isInteger(message.textArgb))
                    return "textArgb: integer expected";
            if (message.backgroundArgb != null && message.hasOwnProperty("backgroundArgb"))
                if (!$util.isInteger(message.backgroundArgb))
                    return "backgroundArgb: integer expected";
            if (message.font != null && message.hasOwnProperty("font"))
                switch (message.font) {
                default:
                    return "font: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.previewType != null && message.hasOwnProperty("previewType"))
                switch (message.previewType) {
                default:
                    return "previewType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                if (!(message.jpegThumbnail && typeof message.jpegThumbnail.length === "number" || $util.isString(message.jpegThumbnail)))
                    return "jpegThumbnail: buffer expected";
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                var error = $root.Message.ContextInfo.verify(message.contextInfo);
                if (error)
                    return "contextInfo." + error;
            }
            if (message.doNotPlayInline != null && message.hasOwnProperty("doNotPlayInline"))
                if (typeof message.doNotPlayInline !== "boolean")
                    return "doNotPlayInline: boolean expected";
            return null;
        };

        /**
         * Creates an ExtendedTextMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.ExtendedTextMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.ExtendedTextMessage} ExtendedTextMessage
         */
        ExtendedTextMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.ExtendedTextMessage)
                return object;
            var message = new $root.Message.ExtendedTextMessage();
            if (object.text != null)
                message.text = String(object.text);
            if (object.matchedText != null)
                message.matchedText = String(object.matchedText);
            if (object.canonicalUrl != null)
                message.canonicalUrl = String(object.canonicalUrl);
            if (object.description != null)
                message.description = String(object.description);
            if (object.title != null)
                message.title = String(object.title);
            if (object.textArgb != null)
                message.textArgb = object.textArgb >>> 0;
            if (object.backgroundArgb != null)
                message.backgroundArgb = object.backgroundArgb >>> 0;
            switch (object.font) {
            case "SANS_SERIF":
            case 0:
                message.font = 0;
                break;
            case "SERIF":
            case 1:
                message.font = 1;
                break;
            case "NORICAN_REGULAR":
            case 2:
                message.font = 2;
                break;
            case "BRYNDAN_WRITE":
            case 3:
                message.font = 3;
                break;
            case "BEBASNEUE_REGULAR":
            case 4:
                message.font = 4;
                break;
            case "OSWALD_HEAVY":
            case 5:
                message.font = 5;
                break;
            }
            switch (object.previewType) {
            case "NONE":
            case 0:
                message.previewType = 0;
                break;
            case "VIDEO":
            case 1:
                message.previewType = 1;
                break;
            }
            if (object.jpegThumbnail != null)
                if (typeof object.jpegThumbnail === "string")
                    $util.base64.decode(object.jpegThumbnail, message.jpegThumbnail = $util.newBuffer($util.base64.length(object.jpegThumbnail)), 0);
                else if (object.jpegThumbnail.length)
                    message.jpegThumbnail = object.jpegThumbnail;
            if (object.contextInfo != null) {
                if (typeof object.contextInfo !== "object")
                    throw TypeError(".Message.ExtendedTextMessage.contextInfo: object expected");
                message.contextInfo = $root.Message.ContextInfo.fromObject(object.contextInfo);
            }
            if (object.doNotPlayInline != null)
                message.doNotPlayInline = Boolean(object.doNotPlayInline);
            return message;
        };

        /**
         * Creates a plain object from an ExtendedTextMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.ExtendedTextMessage
         * @static
         * @param {Message.ExtendedTextMessage} message ExtendedTextMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExtendedTextMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.text = "";
                object.matchedText = "";
                object.canonicalUrl = "";
                object.description = "";
                object.title = "";
                object.textArgb = 0;
                object.backgroundArgb = 0;
                object.font = options.enums === String ? "SANS_SERIF" : 0;
                object.previewType = options.enums === String ? "NONE" : 0;
                if (options.bytes === String)
                    object.jpegThumbnail = "";
                else {
                    object.jpegThumbnail = [];
                    if (options.bytes !== Array)
                        object.jpegThumbnail = $util.newBuffer(object.jpegThumbnail);
                }
                object.contextInfo = null;
                object.doNotPlayInline = false;
            }
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.matchedText != null && message.hasOwnProperty("matchedText"))
                object.matchedText = message.matchedText;
            if (message.canonicalUrl != null && message.hasOwnProperty("canonicalUrl"))
                object.canonicalUrl = message.canonicalUrl;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.textArgb != null && message.hasOwnProperty("textArgb"))
                object.textArgb = message.textArgb;
            if (message.backgroundArgb != null && message.hasOwnProperty("backgroundArgb"))
                object.backgroundArgb = message.backgroundArgb;
            if (message.font != null && message.hasOwnProperty("font"))
                object.font = options.enums === String ? $root.Message.ExtendedTextMessage.EXTENDED_TEXT_MESSAGE_FONTTYPE[message.font] : message.font;
            if (message.previewType != null && message.hasOwnProperty("previewType"))
                object.previewType = options.enums === String ? $root.Message.ExtendedTextMessage.EXTENDED_TEXT_MESSAGE_PREVIEWTYPE[message.previewType] : message.previewType;
            if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                object.jpegThumbnail = options.bytes === String ? $util.base64.encode(message.jpegThumbnail, 0, message.jpegThumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.jpegThumbnail) : message.jpegThumbnail;
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                object.contextInfo = $root.Message.ContextInfo.toObject(message.contextInfo, options);
            if (message.doNotPlayInline != null && message.hasOwnProperty("doNotPlayInline"))
                object.doNotPlayInline = message.doNotPlayInline;
            return object;
        };

        /**
         * Converts this ExtendedTextMessage to JSON.
         * @function toJSON
         * @memberof Message.ExtendedTextMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExtendedTextMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * EXTENDED_TEXT_MESSAGE_FONTTYPE enum.
         * @name Message.ExtendedTextMessage.EXTENDED_TEXT_MESSAGE_FONTTYPE
         * @enum {number}
         * @property {number} SANS_SERIF=0 SANS_SERIF value
         * @property {number} SERIF=1 SERIF value
         * @property {number} NORICAN_REGULAR=2 NORICAN_REGULAR value
         * @property {number} BRYNDAN_WRITE=3 BRYNDAN_WRITE value
         * @property {number} BEBASNEUE_REGULAR=4 BEBASNEUE_REGULAR value
         * @property {number} OSWALD_HEAVY=5 OSWALD_HEAVY value
         */
        ExtendedTextMessage.EXTENDED_TEXT_MESSAGE_FONTTYPE = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SANS_SERIF"] = 0;
            values[valuesById[1] = "SERIF"] = 1;
            values[valuesById[2] = "NORICAN_REGULAR"] = 2;
            values[valuesById[3] = "BRYNDAN_WRITE"] = 3;
            values[valuesById[4] = "BEBASNEUE_REGULAR"] = 4;
            values[valuesById[5] = "OSWALD_HEAVY"] = 5;
            return values;
        })();

        /**
         * EXTENDED_TEXT_MESSAGE_PREVIEWTYPE enum.
         * @name Message.ExtendedTextMessage.EXTENDED_TEXT_MESSAGE_PREVIEWTYPE
         * @enum {number}
         * @property {number} NONE=0 NONE value
         * @property {number} VIDEO=1 VIDEO value
         */
        ExtendedTextMessage.EXTENDED_TEXT_MESSAGE_PREVIEWTYPE = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NONE"] = 0;
            values[valuesById[1] = "VIDEO"] = 1;
            return values;
        })();

        return ExtendedTextMessage;
    })();

    Message.DocumentMessage = (function() {

        /**
         * Properties of a DocumentMessage.
         * @memberof Message
         * @interface IDocumentMessage
         * @property {string|null} [url] DocumentMessage url
         * @property {string|null} [mimetype] DocumentMessage mimetype
         * @property {string|null} [title] DocumentMessage title
         * @property {Uint8Array|null} [fileSha256] DocumentMessage fileSha256
         * @property {number|Long|null} [fileLength] DocumentMessage fileLength
         * @property {number|null} [pageCount] DocumentMessage pageCount
         * @property {Uint8Array|null} [mediaKey] DocumentMessage mediaKey
         * @property {string|null} [fileName] DocumentMessage fileName
         * @property {Uint8Array|null} [fileEncSha256] DocumentMessage fileEncSha256
         * @property {string|null} [directPath] DocumentMessage directPath
         * @property {number|Long|null} [mediaKeyTimestamp] DocumentMessage mediaKeyTimestamp
         * @property {Uint8Array|null} [jpegThumbnail] DocumentMessage jpegThumbnail
         * @property {Message.IContextInfo|null} [contextInfo] DocumentMessage contextInfo
         */

        /**
         * Constructs a new DocumentMessage.
         * @memberof Message
         * @classdesc Represents a DocumentMessage.
         * @implements IDocumentMessage
         * @constructor
         * @param {Message.IDocumentMessage=} [properties] Properties to set
         */
        function DocumentMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DocumentMessage url.
         * @member {string} url
         * @memberof Message.DocumentMessage
         * @instance
         */
        DocumentMessage.prototype.url = "";

        /**
         * DocumentMessage mimetype.
         * @member {string} mimetype
         * @memberof Message.DocumentMessage
         * @instance
         */
        DocumentMessage.prototype.mimetype = "";

        /**
         * DocumentMessage title.
         * @member {string} title
         * @memberof Message.DocumentMessage
         * @instance
         */
        DocumentMessage.prototype.title = "";

        /**
         * DocumentMessage fileSha256.
         * @member {Uint8Array} fileSha256
         * @memberof Message.DocumentMessage
         * @instance
         */
        DocumentMessage.prototype.fileSha256 = $util.newBuffer([]);

        /**
         * DocumentMessage fileLength.
         * @member {number|Long} fileLength
         * @memberof Message.DocumentMessage
         * @instance
         */
        DocumentMessage.prototype.fileLength = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DocumentMessage pageCount.
         * @member {number} pageCount
         * @memberof Message.DocumentMessage
         * @instance
         */
        DocumentMessage.prototype.pageCount = 0;

        /**
         * DocumentMessage mediaKey.
         * @member {Uint8Array} mediaKey
         * @memberof Message.DocumentMessage
         * @instance
         */
        DocumentMessage.prototype.mediaKey = $util.newBuffer([]);

        /**
         * DocumentMessage fileName.
         * @member {string} fileName
         * @memberof Message.DocumentMessage
         * @instance
         */
        DocumentMessage.prototype.fileName = "";

        /**
         * DocumentMessage fileEncSha256.
         * @member {Uint8Array} fileEncSha256
         * @memberof Message.DocumentMessage
         * @instance
         */
        DocumentMessage.prototype.fileEncSha256 = $util.newBuffer([]);

        /**
         * DocumentMessage directPath.
         * @member {string} directPath
         * @memberof Message.DocumentMessage
         * @instance
         */
        DocumentMessage.prototype.directPath = "";

        /**
         * DocumentMessage mediaKeyTimestamp.
         * @member {number|Long} mediaKeyTimestamp
         * @memberof Message.DocumentMessage
         * @instance
         */
        DocumentMessage.prototype.mediaKeyTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DocumentMessage jpegThumbnail.
         * @member {Uint8Array} jpegThumbnail
         * @memberof Message.DocumentMessage
         * @instance
         */
        DocumentMessage.prototype.jpegThumbnail = $util.newBuffer([]);

        /**
         * DocumentMessage contextInfo.
         * @member {Message.IContextInfo|null|undefined} contextInfo
         * @memberof Message.DocumentMessage
         * @instance
         */
        DocumentMessage.prototype.contextInfo = null;

        /**
         * Creates a new DocumentMessage instance using the specified properties.
         * @function create
         * @memberof Message.DocumentMessage
         * @static
         * @param {Message.IDocumentMessage=} [properties] Properties to set
         * @returns {Message.DocumentMessage} DocumentMessage instance
         */
        DocumentMessage.create = function create(properties) {
            return new DocumentMessage(properties);
        };

        /**
         * Encodes the specified DocumentMessage message. Does not implicitly {@link Message.DocumentMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.DocumentMessage
         * @static
         * @param {Message.IDocumentMessage} message DocumentMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DocumentMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
            if (message.mimetype != null && Object.hasOwnProperty.call(message, "mimetype"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.mimetype);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.title);
            if (message.fileSha256 != null && Object.hasOwnProperty.call(message, "fileSha256"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.fileSha256);
            if (message.fileLength != null && Object.hasOwnProperty.call(message, "fileLength"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.fileLength);
            if (message.pageCount != null && Object.hasOwnProperty.call(message, "pageCount"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.pageCount);
            if (message.mediaKey != null && Object.hasOwnProperty.call(message, "mediaKey"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.mediaKey);
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.fileName);
            if (message.fileEncSha256 != null && Object.hasOwnProperty.call(message, "fileEncSha256"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.fileEncSha256);
            if (message.directPath != null && Object.hasOwnProperty.call(message, "directPath"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.directPath);
            if (message.mediaKeyTimestamp != null && Object.hasOwnProperty.call(message, "mediaKeyTimestamp"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.mediaKeyTimestamp);
            if (message.jpegThumbnail != null && Object.hasOwnProperty.call(message, "jpegThumbnail"))
                writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.jpegThumbnail);
            if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                $root.Message.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DocumentMessage message, length delimited. Does not implicitly {@link Message.DocumentMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.DocumentMessage
         * @static
         * @param {Message.IDocumentMessage} message DocumentMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DocumentMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DocumentMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.DocumentMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.DocumentMessage} DocumentMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DocumentMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.DocumentMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.url = reader.string();
                    break;
                case 2:
                    message.mimetype = reader.string();
                    break;
                case 3:
                    message.title = reader.string();
                    break;
                case 4:
                    message.fileSha256 = reader.bytes();
                    break;
                case 5:
                    message.fileLength = reader.uint64();
                    break;
                case 6:
                    message.pageCount = reader.uint32();
                    break;
                case 7:
                    message.mediaKey = reader.bytes();
                    break;
                case 8:
                    message.fileName = reader.string();
                    break;
                case 9:
                    message.fileEncSha256 = reader.bytes();
                    break;
                case 10:
                    message.directPath = reader.string();
                    break;
                case 11:
                    message.mediaKeyTimestamp = reader.int64();
                    break;
                case 16:
                    message.jpegThumbnail = reader.bytes();
                    break;
                case 17:
                    message.contextInfo = $root.Message.ContextInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DocumentMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.DocumentMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.DocumentMessage} DocumentMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DocumentMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DocumentMessage message.
         * @function verify
         * @memberof Message.DocumentMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DocumentMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                if (!$util.isString(message.mimetype))
                    return "mimetype: string expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                if (!(message.fileSha256 && typeof message.fileSha256.length === "number" || $util.isString(message.fileSha256)))
                    return "fileSha256: buffer expected";
            if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                if (!$util.isInteger(message.fileLength) && !(message.fileLength && $util.isInteger(message.fileLength.low) && $util.isInteger(message.fileLength.high)))
                    return "fileLength: integer|Long expected";
            if (message.pageCount != null && message.hasOwnProperty("pageCount"))
                if (!$util.isInteger(message.pageCount))
                    return "pageCount: integer expected";
            if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                if (!(message.mediaKey && typeof message.mediaKey.length === "number" || $util.isString(message.mediaKey)))
                    return "mediaKey: buffer expected";
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                if (!(message.fileEncSha256 && typeof message.fileEncSha256.length === "number" || $util.isString(message.fileEncSha256)))
                    return "fileEncSha256: buffer expected";
            if (message.directPath != null && message.hasOwnProperty("directPath"))
                if (!$util.isString(message.directPath))
                    return "directPath: string expected";
            if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                if (!$util.isInteger(message.mediaKeyTimestamp) && !(message.mediaKeyTimestamp && $util.isInteger(message.mediaKeyTimestamp.low) && $util.isInteger(message.mediaKeyTimestamp.high)))
                    return "mediaKeyTimestamp: integer|Long expected";
            if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                if (!(message.jpegThumbnail && typeof message.jpegThumbnail.length === "number" || $util.isString(message.jpegThumbnail)))
                    return "jpegThumbnail: buffer expected";
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                var error = $root.Message.ContextInfo.verify(message.contextInfo);
                if (error)
                    return "contextInfo." + error;
            }
            return null;
        };

        /**
         * Creates a DocumentMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.DocumentMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.DocumentMessage} DocumentMessage
         */
        DocumentMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.DocumentMessage)
                return object;
            var message = new $root.Message.DocumentMessage();
            if (object.url != null)
                message.url = String(object.url);
            if (object.mimetype != null)
                message.mimetype = String(object.mimetype);
            if (object.title != null)
                message.title = String(object.title);
            if (object.fileSha256 != null)
                if (typeof object.fileSha256 === "string")
                    $util.base64.decode(object.fileSha256, message.fileSha256 = $util.newBuffer($util.base64.length(object.fileSha256)), 0);
                else if (object.fileSha256.length)
                    message.fileSha256 = object.fileSha256;
            if (object.fileLength != null)
                if ($util.Long)
                    (message.fileLength = $util.Long.fromValue(object.fileLength)).unsigned = true;
                else if (typeof object.fileLength === "string")
                    message.fileLength = parseInt(object.fileLength, 10);
                else if (typeof object.fileLength === "number")
                    message.fileLength = object.fileLength;
                else if (typeof object.fileLength === "object")
                    message.fileLength = new $util.LongBits(object.fileLength.low >>> 0, object.fileLength.high >>> 0).toNumber(true);
            if (object.pageCount != null)
                message.pageCount = object.pageCount >>> 0;
            if (object.mediaKey != null)
                if (typeof object.mediaKey === "string")
                    $util.base64.decode(object.mediaKey, message.mediaKey = $util.newBuffer($util.base64.length(object.mediaKey)), 0);
                else if (object.mediaKey.length)
                    message.mediaKey = object.mediaKey;
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            if (object.fileEncSha256 != null)
                if (typeof object.fileEncSha256 === "string")
                    $util.base64.decode(object.fileEncSha256, message.fileEncSha256 = $util.newBuffer($util.base64.length(object.fileEncSha256)), 0);
                else if (object.fileEncSha256.length)
                    message.fileEncSha256 = object.fileEncSha256;
            if (object.directPath != null)
                message.directPath = String(object.directPath);
            if (object.mediaKeyTimestamp != null)
                if ($util.Long)
                    (message.mediaKeyTimestamp = $util.Long.fromValue(object.mediaKeyTimestamp)).unsigned = false;
                else if (typeof object.mediaKeyTimestamp === "string")
                    message.mediaKeyTimestamp = parseInt(object.mediaKeyTimestamp, 10);
                else if (typeof object.mediaKeyTimestamp === "number")
                    message.mediaKeyTimestamp = object.mediaKeyTimestamp;
                else if (typeof object.mediaKeyTimestamp === "object")
                    message.mediaKeyTimestamp = new $util.LongBits(object.mediaKeyTimestamp.low >>> 0, object.mediaKeyTimestamp.high >>> 0).toNumber();
            if (object.jpegThumbnail != null)
                if (typeof object.jpegThumbnail === "string")
                    $util.base64.decode(object.jpegThumbnail, message.jpegThumbnail = $util.newBuffer($util.base64.length(object.jpegThumbnail)), 0);
                else if (object.jpegThumbnail.length)
                    message.jpegThumbnail = object.jpegThumbnail;
            if (object.contextInfo != null) {
                if (typeof object.contextInfo !== "object")
                    throw TypeError(".Message.DocumentMessage.contextInfo: object expected");
                message.contextInfo = $root.Message.ContextInfo.fromObject(object.contextInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a DocumentMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.DocumentMessage
         * @static
         * @param {Message.DocumentMessage} message DocumentMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DocumentMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.url = "";
                object.mimetype = "";
                object.title = "";
                if (options.bytes === String)
                    object.fileSha256 = "";
                else {
                    object.fileSha256 = [];
                    if (options.bytes !== Array)
                        object.fileSha256 = $util.newBuffer(object.fileSha256);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.fileLength = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fileLength = options.longs === String ? "0" : 0;
                object.pageCount = 0;
                if (options.bytes === String)
                    object.mediaKey = "";
                else {
                    object.mediaKey = [];
                    if (options.bytes !== Array)
                        object.mediaKey = $util.newBuffer(object.mediaKey);
                }
                object.fileName = "";
                if (options.bytes === String)
                    object.fileEncSha256 = "";
                else {
                    object.fileEncSha256 = [];
                    if (options.bytes !== Array)
                        object.fileEncSha256 = $util.newBuffer(object.fileEncSha256);
                }
                object.directPath = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.mediaKeyTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.mediaKeyTimestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.jpegThumbnail = "";
                else {
                    object.jpegThumbnail = [];
                    if (options.bytes !== Array)
                        object.jpegThumbnail = $util.newBuffer(object.jpegThumbnail);
                }
                object.contextInfo = null;
            }
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                object.mimetype = message.mimetype;
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                object.fileSha256 = options.bytes === String ? $util.base64.encode(message.fileSha256, 0, message.fileSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileSha256) : message.fileSha256;
            if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                if (typeof message.fileLength === "number")
                    object.fileLength = options.longs === String ? String(message.fileLength) : message.fileLength;
                else
                    object.fileLength = options.longs === String ? $util.Long.prototype.toString.call(message.fileLength) : options.longs === Number ? new $util.LongBits(message.fileLength.low >>> 0, message.fileLength.high >>> 0).toNumber(true) : message.fileLength;
            if (message.pageCount != null && message.hasOwnProperty("pageCount"))
                object.pageCount = message.pageCount;
            if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                object.mediaKey = options.bytes === String ? $util.base64.encode(message.mediaKey, 0, message.mediaKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.mediaKey) : message.mediaKey;
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                object.fileEncSha256 = options.bytes === String ? $util.base64.encode(message.fileEncSha256, 0, message.fileEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileEncSha256) : message.fileEncSha256;
            if (message.directPath != null && message.hasOwnProperty("directPath"))
                object.directPath = message.directPath;
            if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                if (typeof message.mediaKeyTimestamp === "number")
                    object.mediaKeyTimestamp = options.longs === String ? String(message.mediaKeyTimestamp) : message.mediaKeyTimestamp;
                else
                    object.mediaKeyTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.mediaKeyTimestamp) : options.longs === Number ? new $util.LongBits(message.mediaKeyTimestamp.low >>> 0, message.mediaKeyTimestamp.high >>> 0).toNumber() : message.mediaKeyTimestamp;
            if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                object.jpegThumbnail = options.bytes === String ? $util.base64.encode(message.jpegThumbnail, 0, message.jpegThumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.jpegThumbnail) : message.jpegThumbnail;
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                object.contextInfo = $root.Message.ContextInfo.toObject(message.contextInfo, options);
            return object;
        };

        /**
         * Converts this DocumentMessage to JSON.
         * @function toJSON
         * @memberof Message.DocumentMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DocumentMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DocumentMessage;
    })();

    Message.AudioMessage = (function() {

        /**
         * Properties of an AudioMessage.
         * @memberof Message
         * @interface IAudioMessage
         * @property {string|null} [url] AudioMessage url
         * @property {string|null} [mimetype] AudioMessage mimetype
         * @property {Uint8Array|null} [fileSha256] AudioMessage fileSha256
         * @property {number|Long|null} [fileLength] AudioMessage fileLength
         * @property {number|null} [seconds] AudioMessage seconds
         * @property {boolean|null} [ptt] AudioMessage ptt
         * @property {Uint8Array|null} [mediaKey] AudioMessage mediaKey
         * @property {Uint8Array|null} [fileEncSha256] AudioMessage fileEncSha256
         * @property {string|null} [directPath] AudioMessage directPath
         * @property {number|Long|null} [mediaKeyTimestamp] AudioMessage mediaKeyTimestamp
         * @property {Message.IContextInfo|null} [contextInfo] AudioMessage contextInfo
         * @property {Uint8Array|null} [streamingSidecar] AudioMessage streamingSidecar
         */

        /**
         * Constructs a new AudioMessage.
         * @memberof Message
         * @classdesc Represents an AudioMessage.
         * @implements IAudioMessage
         * @constructor
         * @param {Message.IAudioMessage=} [properties] Properties to set
         */
        function AudioMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AudioMessage url.
         * @member {string} url
         * @memberof Message.AudioMessage
         * @instance
         */
        AudioMessage.prototype.url = "";

        /**
         * AudioMessage mimetype.
         * @member {string} mimetype
         * @memberof Message.AudioMessage
         * @instance
         */
        AudioMessage.prototype.mimetype = "";

        /**
         * AudioMessage fileSha256.
         * @member {Uint8Array} fileSha256
         * @memberof Message.AudioMessage
         * @instance
         */
        AudioMessage.prototype.fileSha256 = $util.newBuffer([]);

        /**
         * AudioMessage fileLength.
         * @member {number|Long} fileLength
         * @memberof Message.AudioMessage
         * @instance
         */
        AudioMessage.prototype.fileLength = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AudioMessage seconds.
         * @member {number} seconds
         * @memberof Message.AudioMessage
         * @instance
         */
        AudioMessage.prototype.seconds = 0;

        /**
         * AudioMessage ptt.
         * @member {boolean} ptt
         * @memberof Message.AudioMessage
         * @instance
         */
        AudioMessage.prototype.ptt = false;

        /**
         * AudioMessage mediaKey.
         * @member {Uint8Array} mediaKey
         * @memberof Message.AudioMessage
         * @instance
         */
        AudioMessage.prototype.mediaKey = $util.newBuffer([]);

        /**
         * AudioMessage fileEncSha256.
         * @member {Uint8Array} fileEncSha256
         * @memberof Message.AudioMessage
         * @instance
         */
        AudioMessage.prototype.fileEncSha256 = $util.newBuffer([]);

        /**
         * AudioMessage directPath.
         * @member {string} directPath
         * @memberof Message.AudioMessage
         * @instance
         */
        AudioMessage.prototype.directPath = "";

        /**
         * AudioMessage mediaKeyTimestamp.
         * @member {number|Long} mediaKeyTimestamp
         * @memberof Message.AudioMessage
         * @instance
         */
        AudioMessage.prototype.mediaKeyTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AudioMessage contextInfo.
         * @member {Message.IContextInfo|null|undefined} contextInfo
         * @memberof Message.AudioMessage
         * @instance
         */
        AudioMessage.prototype.contextInfo = null;

        /**
         * AudioMessage streamingSidecar.
         * @member {Uint8Array} streamingSidecar
         * @memberof Message.AudioMessage
         * @instance
         */
        AudioMessage.prototype.streamingSidecar = $util.newBuffer([]);

        /**
         * Creates a new AudioMessage instance using the specified properties.
         * @function create
         * @memberof Message.AudioMessage
         * @static
         * @param {Message.IAudioMessage=} [properties] Properties to set
         * @returns {Message.AudioMessage} AudioMessage instance
         */
        AudioMessage.create = function create(properties) {
            return new AudioMessage(properties);
        };

        /**
         * Encodes the specified AudioMessage message. Does not implicitly {@link Message.AudioMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.AudioMessage
         * @static
         * @param {Message.IAudioMessage} message AudioMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AudioMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
            if (message.mimetype != null && Object.hasOwnProperty.call(message, "mimetype"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.mimetype);
            if (message.fileSha256 != null && Object.hasOwnProperty.call(message, "fileSha256"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.fileSha256);
            if (message.fileLength != null && Object.hasOwnProperty.call(message, "fileLength"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.fileLength);
            if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.seconds);
            if (message.ptt != null && Object.hasOwnProperty.call(message, "ptt"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.ptt);
            if (message.mediaKey != null && Object.hasOwnProperty.call(message, "mediaKey"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.mediaKey);
            if (message.fileEncSha256 != null && Object.hasOwnProperty.call(message, "fileEncSha256"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.fileEncSha256);
            if (message.directPath != null && Object.hasOwnProperty.call(message, "directPath"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.directPath);
            if (message.mediaKeyTimestamp != null && Object.hasOwnProperty.call(message, "mediaKeyTimestamp"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.mediaKeyTimestamp);
            if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                $root.Message.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.streamingSidecar != null && Object.hasOwnProperty.call(message, "streamingSidecar"))
                writer.uint32(/* id 18, wireType 2 =*/146).bytes(message.streamingSidecar);
            return writer;
        };

        /**
         * Encodes the specified AudioMessage message, length delimited. Does not implicitly {@link Message.AudioMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.AudioMessage
         * @static
         * @param {Message.IAudioMessage} message AudioMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AudioMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AudioMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.AudioMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.AudioMessage} AudioMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AudioMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.AudioMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.url = reader.string();
                    break;
                case 2:
                    message.mimetype = reader.string();
                    break;
                case 3:
                    message.fileSha256 = reader.bytes();
                    break;
                case 4:
                    message.fileLength = reader.uint64();
                    break;
                case 5:
                    message.seconds = reader.uint32();
                    break;
                case 6:
                    message.ptt = reader.bool();
                    break;
                case 7:
                    message.mediaKey = reader.bytes();
                    break;
                case 8:
                    message.fileEncSha256 = reader.bytes();
                    break;
                case 9:
                    message.directPath = reader.string();
                    break;
                case 10:
                    message.mediaKeyTimestamp = reader.int64();
                    break;
                case 17:
                    message.contextInfo = $root.Message.ContextInfo.decode(reader, reader.uint32());
                    break;
                case 18:
                    message.streamingSidecar = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AudioMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.AudioMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.AudioMessage} AudioMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AudioMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AudioMessage message.
         * @function verify
         * @memberof Message.AudioMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AudioMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                if (!$util.isString(message.mimetype))
                    return "mimetype: string expected";
            if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                if (!(message.fileSha256 && typeof message.fileSha256.length === "number" || $util.isString(message.fileSha256)))
                    return "fileSha256: buffer expected";
            if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                if (!$util.isInteger(message.fileLength) && !(message.fileLength && $util.isInteger(message.fileLength.low) && $util.isInteger(message.fileLength.high)))
                    return "fileLength: integer|Long expected";
            if (message.seconds != null && message.hasOwnProperty("seconds"))
                if (!$util.isInteger(message.seconds))
                    return "seconds: integer expected";
            if (message.ptt != null && message.hasOwnProperty("ptt"))
                if (typeof message.ptt !== "boolean")
                    return "ptt: boolean expected";
            if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                if (!(message.mediaKey && typeof message.mediaKey.length === "number" || $util.isString(message.mediaKey)))
                    return "mediaKey: buffer expected";
            if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                if (!(message.fileEncSha256 && typeof message.fileEncSha256.length === "number" || $util.isString(message.fileEncSha256)))
                    return "fileEncSha256: buffer expected";
            if (message.directPath != null && message.hasOwnProperty("directPath"))
                if (!$util.isString(message.directPath))
                    return "directPath: string expected";
            if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                if (!$util.isInteger(message.mediaKeyTimestamp) && !(message.mediaKeyTimestamp && $util.isInteger(message.mediaKeyTimestamp.low) && $util.isInteger(message.mediaKeyTimestamp.high)))
                    return "mediaKeyTimestamp: integer|Long expected";
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                var error = $root.Message.ContextInfo.verify(message.contextInfo);
                if (error)
                    return "contextInfo." + error;
            }
            if (message.streamingSidecar != null && message.hasOwnProperty("streamingSidecar"))
                if (!(message.streamingSidecar && typeof message.streamingSidecar.length === "number" || $util.isString(message.streamingSidecar)))
                    return "streamingSidecar: buffer expected";
            return null;
        };

        /**
         * Creates an AudioMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.AudioMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.AudioMessage} AudioMessage
         */
        AudioMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.AudioMessage)
                return object;
            var message = new $root.Message.AudioMessage();
            if (object.url != null)
                message.url = String(object.url);
            if (object.mimetype != null)
                message.mimetype = String(object.mimetype);
            if (object.fileSha256 != null)
                if (typeof object.fileSha256 === "string")
                    $util.base64.decode(object.fileSha256, message.fileSha256 = $util.newBuffer($util.base64.length(object.fileSha256)), 0);
                else if (object.fileSha256.length)
                    message.fileSha256 = object.fileSha256;
            if (object.fileLength != null)
                if ($util.Long)
                    (message.fileLength = $util.Long.fromValue(object.fileLength)).unsigned = true;
                else if (typeof object.fileLength === "string")
                    message.fileLength = parseInt(object.fileLength, 10);
                else if (typeof object.fileLength === "number")
                    message.fileLength = object.fileLength;
                else if (typeof object.fileLength === "object")
                    message.fileLength = new $util.LongBits(object.fileLength.low >>> 0, object.fileLength.high >>> 0).toNumber(true);
            if (object.seconds != null)
                message.seconds = object.seconds >>> 0;
            if (object.ptt != null)
                message.ptt = Boolean(object.ptt);
            if (object.mediaKey != null)
                if (typeof object.mediaKey === "string")
                    $util.base64.decode(object.mediaKey, message.mediaKey = $util.newBuffer($util.base64.length(object.mediaKey)), 0);
                else if (object.mediaKey.length)
                    message.mediaKey = object.mediaKey;
            if (object.fileEncSha256 != null)
                if (typeof object.fileEncSha256 === "string")
                    $util.base64.decode(object.fileEncSha256, message.fileEncSha256 = $util.newBuffer($util.base64.length(object.fileEncSha256)), 0);
                else if (object.fileEncSha256.length)
                    message.fileEncSha256 = object.fileEncSha256;
            if (object.directPath != null)
                message.directPath = String(object.directPath);
            if (object.mediaKeyTimestamp != null)
                if ($util.Long)
                    (message.mediaKeyTimestamp = $util.Long.fromValue(object.mediaKeyTimestamp)).unsigned = false;
                else if (typeof object.mediaKeyTimestamp === "string")
                    message.mediaKeyTimestamp = parseInt(object.mediaKeyTimestamp, 10);
                else if (typeof object.mediaKeyTimestamp === "number")
                    message.mediaKeyTimestamp = object.mediaKeyTimestamp;
                else if (typeof object.mediaKeyTimestamp === "object")
                    message.mediaKeyTimestamp = new $util.LongBits(object.mediaKeyTimestamp.low >>> 0, object.mediaKeyTimestamp.high >>> 0).toNumber();
            if (object.contextInfo != null) {
                if (typeof object.contextInfo !== "object")
                    throw TypeError(".Message.AudioMessage.contextInfo: object expected");
                message.contextInfo = $root.Message.ContextInfo.fromObject(object.contextInfo);
            }
            if (object.streamingSidecar != null)
                if (typeof object.streamingSidecar === "string")
                    $util.base64.decode(object.streamingSidecar, message.streamingSidecar = $util.newBuffer($util.base64.length(object.streamingSidecar)), 0);
                else if (object.streamingSidecar.length)
                    message.streamingSidecar = object.streamingSidecar;
            return message;
        };

        /**
         * Creates a plain object from an AudioMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.AudioMessage
         * @static
         * @param {Message.AudioMessage} message AudioMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AudioMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.url = "";
                object.mimetype = "";
                if (options.bytes === String)
                    object.fileSha256 = "";
                else {
                    object.fileSha256 = [];
                    if (options.bytes !== Array)
                        object.fileSha256 = $util.newBuffer(object.fileSha256);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.fileLength = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fileLength = options.longs === String ? "0" : 0;
                object.seconds = 0;
                object.ptt = false;
                if (options.bytes === String)
                    object.mediaKey = "";
                else {
                    object.mediaKey = [];
                    if (options.bytes !== Array)
                        object.mediaKey = $util.newBuffer(object.mediaKey);
                }
                if (options.bytes === String)
                    object.fileEncSha256 = "";
                else {
                    object.fileEncSha256 = [];
                    if (options.bytes !== Array)
                        object.fileEncSha256 = $util.newBuffer(object.fileEncSha256);
                }
                object.directPath = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.mediaKeyTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.mediaKeyTimestamp = options.longs === String ? "0" : 0;
                object.contextInfo = null;
                if (options.bytes === String)
                    object.streamingSidecar = "";
                else {
                    object.streamingSidecar = [];
                    if (options.bytes !== Array)
                        object.streamingSidecar = $util.newBuffer(object.streamingSidecar);
                }
            }
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                object.mimetype = message.mimetype;
            if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                object.fileSha256 = options.bytes === String ? $util.base64.encode(message.fileSha256, 0, message.fileSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileSha256) : message.fileSha256;
            if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                if (typeof message.fileLength === "number")
                    object.fileLength = options.longs === String ? String(message.fileLength) : message.fileLength;
                else
                    object.fileLength = options.longs === String ? $util.Long.prototype.toString.call(message.fileLength) : options.longs === Number ? new $util.LongBits(message.fileLength.low >>> 0, message.fileLength.high >>> 0).toNumber(true) : message.fileLength;
            if (message.seconds != null && message.hasOwnProperty("seconds"))
                object.seconds = message.seconds;
            if (message.ptt != null && message.hasOwnProperty("ptt"))
                object.ptt = message.ptt;
            if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                object.mediaKey = options.bytes === String ? $util.base64.encode(message.mediaKey, 0, message.mediaKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.mediaKey) : message.mediaKey;
            if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                object.fileEncSha256 = options.bytes === String ? $util.base64.encode(message.fileEncSha256, 0, message.fileEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileEncSha256) : message.fileEncSha256;
            if (message.directPath != null && message.hasOwnProperty("directPath"))
                object.directPath = message.directPath;
            if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                if (typeof message.mediaKeyTimestamp === "number")
                    object.mediaKeyTimestamp = options.longs === String ? String(message.mediaKeyTimestamp) : message.mediaKeyTimestamp;
                else
                    object.mediaKeyTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.mediaKeyTimestamp) : options.longs === Number ? new $util.LongBits(message.mediaKeyTimestamp.low >>> 0, message.mediaKeyTimestamp.high >>> 0).toNumber() : message.mediaKeyTimestamp;
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                object.contextInfo = $root.Message.ContextInfo.toObject(message.contextInfo, options);
            if (message.streamingSidecar != null && message.hasOwnProperty("streamingSidecar"))
                object.streamingSidecar = options.bytes === String ? $util.base64.encode(message.streamingSidecar, 0, message.streamingSidecar.length) : options.bytes === Array ? Array.prototype.slice.call(message.streamingSidecar) : message.streamingSidecar;
            return object;
        };

        /**
         * Converts this AudioMessage to JSON.
         * @function toJSON
         * @memberof Message.AudioMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AudioMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AudioMessage;
    })();

    Message.VideoMessage = (function() {

        /**
         * Properties of a VideoMessage.
         * @memberof Message
         * @interface IVideoMessage
         * @property {string|null} [url] VideoMessage url
         * @property {string|null} [mimetype] VideoMessage mimetype
         * @property {Uint8Array|null} [fileSha256] VideoMessage fileSha256
         * @property {number|Long|null} [fileLength] VideoMessage fileLength
         * @property {number|null} [seconds] VideoMessage seconds
         * @property {Uint8Array|null} [mediaKey] VideoMessage mediaKey
         * @property {string|null} [caption] VideoMessage caption
         * @property {boolean|null} [gifPlayback] VideoMessage gifPlayback
         * @property {number|null} [height] VideoMessage height
         * @property {number|null} [width] VideoMessage width
         * @property {Uint8Array|null} [fileEncSha256] VideoMessage fileEncSha256
         * @property {Array.<Message.IInteractiveAnnotation>|null} [interactiveAnnotations] VideoMessage interactiveAnnotations
         * @property {string|null} [directPath] VideoMessage directPath
         * @property {number|Long|null} [mediaKeyTimestamp] VideoMessage mediaKeyTimestamp
         * @property {Uint8Array|null} [jpegThumbnail] VideoMessage jpegThumbnail
         * @property {Message.IContextInfo|null} [contextInfo] VideoMessage contextInfo
         * @property {Uint8Array|null} [streamingSidecar] VideoMessage streamingSidecar
         * @property {Message.VideoMessage.VIDEO_MESSAGE_ATTRIBUTION|null} [gifAttribution] VideoMessage gifAttribution
         */

        /**
         * Constructs a new VideoMessage.
         * @memberof Message
         * @classdesc Represents a VideoMessage.
         * @implements IVideoMessage
         * @constructor
         * @param {Message.IVideoMessage=} [properties] Properties to set
         */
        function VideoMessage(properties) {
            this.interactiveAnnotations = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VideoMessage url.
         * @member {string} url
         * @memberof Message.VideoMessage
         * @instance
         */
        VideoMessage.prototype.url = "";

        /**
         * VideoMessage mimetype.
         * @member {string} mimetype
         * @memberof Message.VideoMessage
         * @instance
         */
        VideoMessage.prototype.mimetype = "";

        /**
         * VideoMessage fileSha256.
         * @member {Uint8Array} fileSha256
         * @memberof Message.VideoMessage
         * @instance
         */
        VideoMessage.prototype.fileSha256 = $util.newBuffer([]);

        /**
         * VideoMessage fileLength.
         * @member {number|Long} fileLength
         * @memberof Message.VideoMessage
         * @instance
         */
        VideoMessage.prototype.fileLength = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * VideoMessage seconds.
         * @member {number} seconds
         * @memberof Message.VideoMessage
         * @instance
         */
        VideoMessage.prototype.seconds = 0;

        /**
         * VideoMessage mediaKey.
         * @member {Uint8Array} mediaKey
         * @memberof Message.VideoMessage
         * @instance
         */
        VideoMessage.prototype.mediaKey = $util.newBuffer([]);

        /**
         * VideoMessage caption.
         * @member {string} caption
         * @memberof Message.VideoMessage
         * @instance
         */
        VideoMessage.prototype.caption = "";

        /**
         * VideoMessage gifPlayback.
         * @member {boolean} gifPlayback
         * @memberof Message.VideoMessage
         * @instance
         */
        VideoMessage.prototype.gifPlayback = false;

        /**
         * VideoMessage height.
         * @member {number} height
         * @memberof Message.VideoMessage
         * @instance
         */
        VideoMessage.prototype.height = 0;

        /**
         * VideoMessage width.
         * @member {number} width
         * @memberof Message.VideoMessage
         * @instance
         */
        VideoMessage.prototype.width = 0;

        /**
         * VideoMessage fileEncSha256.
         * @member {Uint8Array} fileEncSha256
         * @memberof Message.VideoMessage
         * @instance
         */
        VideoMessage.prototype.fileEncSha256 = $util.newBuffer([]);

        /**
         * VideoMessage interactiveAnnotations.
         * @member {Array.<Message.IInteractiveAnnotation>} interactiveAnnotations
         * @memberof Message.VideoMessage
         * @instance
         */
        VideoMessage.prototype.interactiveAnnotations = $util.emptyArray;

        /**
         * VideoMessage directPath.
         * @member {string} directPath
         * @memberof Message.VideoMessage
         * @instance
         */
        VideoMessage.prototype.directPath = "";

        /**
         * VideoMessage mediaKeyTimestamp.
         * @member {number|Long} mediaKeyTimestamp
         * @memberof Message.VideoMessage
         * @instance
         */
        VideoMessage.prototype.mediaKeyTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * VideoMessage jpegThumbnail.
         * @member {Uint8Array} jpegThumbnail
         * @memberof Message.VideoMessage
         * @instance
         */
        VideoMessage.prototype.jpegThumbnail = $util.newBuffer([]);

        /**
         * VideoMessage contextInfo.
         * @member {Message.IContextInfo|null|undefined} contextInfo
         * @memberof Message.VideoMessage
         * @instance
         */
        VideoMessage.prototype.contextInfo = null;

        /**
         * VideoMessage streamingSidecar.
         * @member {Uint8Array} streamingSidecar
         * @memberof Message.VideoMessage
         * @instance
         */
        VideoMessage.prototype.streamingSidecar = $util.newBuffer([]);

        /**
         * VideoMessage gifAttribution.
         * @member {Message.VideoMessage.VIDEO_MESSAGE_ATTRIBUTION} gifAttribution
         * @memberof Message.VideoMessage
         * @instance
         */
        VideoMessage.prototype.gifAttribution = 0;

        /**
         * Creates a new VideoMessage instance using the specified properties.
         * @function create
         * @memberof Message.VideoMessage
         * @static
         * @param {Message.IVideoMessage=} [properties] Properties to set
         * @returns {Message.VideoMessage} VideoMessage instance
         */
        VideoMessage.create = function create(properties) {
            return new VideoMessage(properties);
        };

        /**
         * Encodes the specified VideoMessage message. Does not implicitly {@link Message.VideoMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.VideoMessage
         * @static
         * @param {Message.IVideoMessage} message VideoMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VideoMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
            if (message.mimetype != null && Object.hasOwnProperty.call(message, "mimetype"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.mimetype);
            if (message.fileSha256 != null && Object.hasOwnProperty.call(message, "fileSha256"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.fileSha256);
            if (message.fileLength != null && Object.hasOwnProperty.call(message, "fileLength"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.fileLength);
            if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.seconds);
            if (message.mediaKey != null && Object.hasOwnProperty.call(message, "mediaKey"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.mediaKey);
            if (message.caption != null && Object.hasOwnProperty.call(message, "caption"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.caption);
            if (message.gifPlayback != null && Object.hasOwnProperty.call(message, "gifPlayback"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.gifPlayback);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.height);
            if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.width);
            if (message.fileEncSha256 != null && Object.hasOwnProperty.call(message, "fileEncSha256"))
                writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.fileEncSha256);
            if (message.interactiveAnnotations != null && message.interactiveAnnotations.length)
                for (var i = 0; i < message.interactiveAnnotations.length; ++i)
                    $root.Message.InteractiveAnnotation.encode(message.interactiveAnnotations[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.directPath != null && Object.hasOwnProperty.call(message, "directPath"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.directPath);
            if (message.mediaKeyTimestamp != null && Object.hasOwnProperty.call(message, "mediaKeyTimestamp"))
                writer.uint32(/* id 14, wireType 0 =*/112).int64(message.mediaKeyTimestamp);
            if (message.jpegThumbnail != null && Object.hasOwnProperty.call(message, "jpegThumbnail"))
                writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.jpegThumbnail);
            if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                $root.Message.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.streamingSidecar != null && Object.hasOwnProperty.call(message, "streamingSidecar"))
                writer.uint32(/* id 18, wireType 2 =*/146).bytes(message.streamingSidecar);
            if (message.gifAttribution != null && Object.hasOwnProperty.call(message, "gifAttribution"))
                writer.uint32(/* id 19, wireType 0 =*/152).int32(message.gifAttribution);
            return writer;
        };

        /**
         * Encodes the specified VideoMessage message, length delimited. Does not implicitly {@link Message.VideoMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.VideoMessage
         * @static
         * @param {Message.IVideoMessage} message VideoMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VideoMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VideoMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.VideoMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.VideoMessage} VideoMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.VideoMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.url = reader.string();
                    break;
                case 2:
                    message.mimetype = reader.string();
                    break;
                case 3:
                    message.fileSha256 = reader.bytes();
                    break;
                case 4:
                    message.fileLength = reader.uint64();
                    break;
                case 5:
                    message.seconds = reader.uint32();
                    break;
                case 6:
                    message.mediaKey = reader.bytes();
                    break;
                case 7:
                    message.caption = reader.string();
                    break;
                case 8:
                    message.gifPlayback = reader.bool();
                    break;
                case 9:
                    message.height = reader.uint32();
                    break;
                case 10:
                    message.width = reader.uint32();
                    break;
                case 11:
                    message.fileEncSha256 = reader.bytes();
                    break;
                case 12:
                    if (!(message.interactiveAnnotations && message.interactiveAnnotations.length))
                        message.interactiveAnnotations = [];
                    message.interactiveAnnotations.push($root.Message.InteractiveAnnotation.decode(reader, reader.uint32()));
                    break;
                case 13:
                    message.directPath = reader.string();
                    break;
                case 14:
                    message.mediaKeyTimestamp = reader.int64();
                    break;
                case 16:
                    message.jpegThumbnail = reader.bytes();
                    break;
                case 17:
                    message.contextInfo = $root.Message.ContextInfo.decode(reader, reader.uint32());
                    break;
                case 18:
                    message.streamingSidecar = reader.bytes();
                    break;
                case 19:
                    message.gifAttribution = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VideoMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.VideoMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.VideoMessage} VideoMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VideoMessage message.
         * @function verify
         * @memberof Message.VideoMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VideoMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                if (!$util.isString(message.mimetype))
                    return "mimetype: string expected";
            if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                if (!(message.fileSha256 && typeof message.fileSha256.length === "number" || $util.isString(message.fileSha256)))
                    return "fileSha256: buffer expected";
            if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                if (!$util.isInteger(message.fileLength) && !(message.fileLength && $util.isInteger(message.fileLength.low) && $util.isInteger(message.fileLength.high)))
                    return "fileLength: integer|Long expected";
            if (message.seconds != null && message.hasOwnProperty("seconds"))
                if (!$util.isInteger(message.seconds))
                    return "seconds: integer expected";
            if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                if (!(message.mediaKey && typeof message.mediaKey.length === "number" || $util.isString(message.mediaKey)))
                    return "mediaKey: buffer expected";
            if (message.caption != null && message.hasOwnProperty("caption"))
                if (!$util.isString(message.caption))
                    return "caption: string expected";
            if (message.gifPlayback != null && message.hasOwnProperty("gifPlayback"))
                if (typeof message.gifPlayback !== "boolean")
                    return "gifPlayback: boolean expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (!$util.isInteger(message.height))
                    return "height: integer expected";
            if (message.width != null && message.hasOwnProperty("width"))
                if (!$util.isInteger(message.width))
                    return "width: integer expected";
            if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                if (!(message.fileEncSha256 && typeof message.fileEncSha256.length === "number" || $util.isString(message.fileEncSha256)))
                    return "fileEncSha256: buffer expected";
            if (message.interactiveAnnotations != null && message.hasOwnProperty("interactiveAnnotations")) {
                if (!Array.isArray(message.interactiveAnnotations))
                    return "interactiveAnnotations: array expected";
                for (var i = 0; i < message.interactiveAnnotations.length; ++i) {
                    var error = $root.Message.InteractiveAnnotation.verify(message.interactiveAnnotations[i]);
                    if (error)
                        return "interactiveAnnotations." + error;
                }
            }
            if (message.directPath != null && message.hasOwnProperty("directPath"))
                if (!$util.isString(message.directPath))
                    return "directPath: string expected";
            if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                if (!$util.isInteger(message.mediaKeyTimestamp) && !(message.mediaKeyTimestamp && $util.isInteger(message.mediaKeyTimestamp.low) && $util.isInteger(message.mediaKeyTimestamp.high)))
                    return "mediaKeyTimestamp: integer|Long expected";
            if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                if (!(message.jpegThumbnail && typeof message.jpegThumbnail.length === "number" || $util.isString(message.jpegThumbnail)))
                    return "jpegThumbnail: buffer expected";
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                var error = $root.Message.ContextInfo.verify(message.contextInfo);
                if (error)
                    return "contextInfo." + error;
            }
            if (message.streamingSidecar != null && message.hasOwnProperty("streamingSidecar"))
                if (!(message.streamingSidecar && typeof message.streamingSidecar.length === "number" || $util.isString(message.streamingSidecar)))
                    return "streamingSidecar: buffer expected";
            if (message.gifAttribution != null && message.hasOwnProperty("gifAttribution"))
                switch (message.gifAttribution) {
                default:
                    return "gifAttribution: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a VideoMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.VideoMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.VideoMessage} VideoMessage
         */
        VideoMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.VideoMessage)
                return object;
            var message = new $root.Message.VideoMessage();
            if (object.url != null)
                message.url = String(object.url);
            if (object.mimetype != null)
                message.mimetype = String(object.mimetype);
            if (object.fileSha256 != null)
                if (typeof object.fileSha256 === "string")
                    $util.base64.decode(object.fileSha256, message.fileSha256 = $util.newBuffer($util.base64.length(object.fileSha256)), 0);
                else if (object.fileSha256.length)
                    message.fileSha256 = object.fileSha256;
            if (object.fileLength != null)
                if ($util.Long)
                    (message.fileLength = $util.Long.fromValue(object.fileLength)).unsigned = true;
                else if (typeof object.fileLength === "string")
                    message.fileLength = parseInt(object.fileLength, 10);
                else if (typeof object.fileLength === "number")
                    message.fileLength = object.fileLength;
                else if (typeof object.fileLength === "object")
                    message.fileLength = new $util.LongBits(object.fileLength.low >>> 0, object.fileLength.high >>> 0).toNumber(true);
            if (object.seconds != null)
                message.seconds = object.seconds >>> 0;
            if (object.mediaKey != null)
                if (typeof object.mediaKey === "string")
                    $util.base64.decode(object.mediaKey, message.mediaKey = $util.newBuffer($util.base64.length(object.mediaKey)), 0);
                else if (object.mediaKey.length)
                    message.mediaKey = object.mediaKey;
            if (object.caption != null)
                message.caption = String(object.caption);
            if (object.gifPlayback != null)
                message.gifPlayback = Boolean(object.gifPlayback);
            if (object.height != null)
                message.height = object.height >>> 0;
            if (object.width != null)
                message.width = object.width >>> 0;
            if (object.fileEncSha256 != null)
                if (typeof object.fileEncSha256 === "string")
                    $util.base64.decode(object.fileEncSha256, message.fileEncSha256 = $util.newBuffer($util.base64.length(object.fileEncSha256)), 0);
                else if (object.fileEncSha256.length)
                    message.fileEncSha256 = object.fileEncSha256;
            if (object.interactiveAnnotations) {
                if (!Array.isArray(object.interactiveAnnotations))
                    throw TypeError(".Message.VideoMessage.interactiveAnnotations: array expected");
                message.interactiveAnnotations = [];
                for (var i = 0; i < object.interactiveAnnotations.length; ++i) {
                    if (typeof object.interactiveAnnotations[i] !== "object")
                        throw TypeError(".Message.VideoMessage.interactiveAnnotations: object expected");
                    message.interactiveAnnotations[i] = $root.Message.InteractiveAnnotation.fromObject(object.interactiveAnnotations[i]);
                }
            }
            if (object.directPath != null)
                message.directPath = String(object.directPath);
            if (object.mediaKeyTimestamp != null)
                if ($util.Long)
                    (message.mediaKeyTimestamp = $util.Long.fromValue(object.mediaKeyTimestamp)).unsigned = false;
                else if (typeof object.mediaKeyTimestamp === "string")
                    message.mediaKeyTimestamp = parseInt(object.mediaKeyTimestamp, 10);
                else if (typeof object.mediaKeyTimestamp === "number")
                    message.mediaKeyTimestamp = object.mediaKeyTimestamp;
                else if (typeof object.mediaKeyTimestamp === "object")
                    message.mediaKeyTimestamp = new $util.LongBits(object.mediaKeyTimestamp.low >>> 0, object.mediaKeyTimestamp.high >>> 0).toNumber();
            if (object.jpegThumbnail != null)
                if (typeof object.jpegThumbnail === "string")
                    $util.base64.decode(object.jpegThumbnail, message.jpegThumbnail = $util.newBuffer($util.base64.length(object.jpegThumbnail)), 0);
                else if (object.jpegThumbnail.length)
                    message.jpegThumbnail = object.jpegThumbnail;
            if (object.contextInfo != null) {
                if (typeof object.contextInfo !== "object")
                    throw TypeError(".Message.VideoMessage.contextInfo: object expected");
                message.contextInfo = $root.Message.ContextInfo.fromObject(object.contextInfo);
            }
            if (object.streamingSidecar != null)
                if (typeof object.streamingSidecar === "string")
                    $util.base64.decode(object.streamingSidecar, message.streamingSidecar = $util.newBuffer($util.base64.length(object.streamingSidecar)), 0);
                else if (object.streamingSidecar.length)
                    message.streamingSidecar = object.streamingSidecar;
            switch (object.gifAttribution) {
            case "NONE":
            case 0:
                message.gifAttribution = 0;
                break;
            case "GIPHY":
            case 1:
                message.gifAttribution = 1;
                break;
            case "TENOR":
            case 2:
                message.gifAttribution = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a VideoMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.VideoMessage
         * @static
         * @param {Message.VideoMessage} message VideoMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VideoMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.interactiveAnnotations = [];
            if (options.defaults) {
                object.url = "";
                object.mimetype = "";
                if (options.bytes === String)
                    object.fileSha256 = "";
                else {
                    object.fileSha256 = [];
                    if (options.bytes !== Array)
                        object.fileSha256 = $util.newBuffer(object.fileSha256);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.fileLength = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fileLength = options.longs === String ? "0" : 0;
                object.seconds = 0;
                if (options.bytes === String)
                    object.mediaKey = "";
                else {
                    object.mediaKey = [];
                    if (options.bytes !== Array)
                        object.mediaKey = $util.newBuffer(object.mediaKey);
                }
                object.caption = "";
                object.gifPlayback = false;
                object.height = 0;
                object.width = 0;
                if (options.bytes === String)
                    object.fileEncSha256 = "";
                else {
                    object.fileEncSha256 = [];
                    if (options.bytes !== Array)
                        object.fileEncSha256 = $util.newBuffer(object.fileEncSha256);
                }
                object.directPath = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.mediaKeyTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.mediaKeyTimestamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.jpegThumbnail = "";
                else {
                    object.jpegThumbnail = [];
                    if (options.bytes !== Array)
                        object.jpegThumbnail = $util.newBuffer(object.jpegThumbnail);
                }
                object.contextInfo = null;
                if (options.bytes === String)
                    object.streamingSidecar = "";
                else {
                    object.streamingSidecar = [];
                    if (options.bytes !== Array)
                        object.streamingSidecar = $util.newBuffer(object.streamingSidecar);
                }
                object.gifAttribution = options.enums === String ? "NONE" : 0;
            }
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                object.mimetype = message.mimetype;
            if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                object.fileSha256 = options.bytes === String ? $util.base64.encode(message.fileSha256, 0, message.fileSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileSha256) : message.fileSha256;
            if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                if (typeof message.fileLength === "number")
                    object.fileLength = options.longs === String ? String(message.fileLength) : message.fileLength;
                else
                    object.fileLength = options.longs === String ? $util.Long.prototype.toString.call(message.fileLength) : options.longs === Number ? new $util.LongBits(message.fileLength.low >>> 0, message.fileLength.high >>> 0).toNumber(true) : message.fileLength;
            if (message.seconds != null && message.hasOwnProperty("seconds"))
                object.seconds = message.seconds;
            if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                object.mediaKey = options.bytes === String ? $util.base64.encode(message.mediaKey, 0, message.mediaKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.mediaKey) : message.mediaKey;
            if (message.caption != null && message.hasOwnProperty("caption"))
                object.caption = message.caption;
            if (message.gifPlayback != null && message.hasOwnProperty("gifPlayback"))
                object.gifPlayback = message.gifPlayback;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = message.height;
            if (message.width != null && message.hasOwnProperty("width"))
                object.width = message.width;
            if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                object.fileEncSha256 = options.bytes === String ? $util.base64.encode(message.fileEncSha256, 0, message.fileEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileEncSha256) : message.fileEncSha256;
            if (message.interactiveAnnotations && message.interactiveAnnotations.length) {
                object.interactiveAnnotations = [];
                for (var j = 0; j < message.interactiveAnnotations.length; ++j)
                    object.interactiveAnnotations[j] = $root.Message.InteractiveAnnotation.toObject(message.interactiveAnnotations[j], options);
            }
            if (message.directPath != null && message.hasOwnProperty("directPath"))
                object.directPath = message.directPath;
            if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                if (typeof message.mediaKeyTimestamp === "number")
                    object.mediaKeyTimestamp = options.longs === String ? String(message.mediaKeyTimestamp) : message.mediaKeyTimestamp;
                else
                    object.mediaKeyTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.mediaKeyTimestamp) : options.longs === Number ? new $util.LongBits(message.mediaKeyTimestamp.low >>> 0, message.mediaKeyTimestamp.high >>> 0).toNumber() : message.mediaKeyTimestamp;
            if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                object.jpegThumbnail = options.bytes === String ? $util.base64.encode(message.jpegThumbnail, 0, message.jpegThumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.jpegThumbnail) : message.jpegThumbnail;
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                object.contextInfo = $root.Message.ContextInfo.toObject(message.contextInfo, options);
            if (message.streamingSidecar != null && message.hasOwnProperty("streamingSidecar"))
                object.streamingSidecar = options.bytes === String ? $util.base64.encode(message.streamingSidecar, 0, message.streamingSidecar.length) : options.bytes === Array ? Array.prototype.slice.call(message.streamingSidecar) : message.streamingSidecar;
            if (message.gifAttribution != null && message.hasOwnProperty("gifAttribution"))
                object.gifAttribution = options.enums === String ? $root.Message.VideoMessage.VIDEO_MESSAGE_ATTRIBUTION[message.gifAttribution] : message.gifAttribution;
            return object;
        };

        /**
         * Converts this VideoMessage to JSON.
         * @function toJSON
         * @memberof Message.VideoMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VideoMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * VIDEO_MESSAGE_ATTRIBUTION enum.
         * @name Message.VideoMessage.VIDEO_MESSAGE_ATTRIBUTION
         * @enum {number}
         * @property {number} NONE=0 NONE value
         * @property {number} GIPHY=1 GIPHY value
         * @property {number} TENOR=2 TENOR value
         */
        VideoMessage.VIDEO_MESSAGE_ATTRIBUTION = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NONE"] = 0;
            values[valuesById[1] = "GIPHY"] = 1;
            values[valuesById[2] = "TENOR"] = 2;
            return values;
        })();

        return VideoMessage;
    })();

    Message.Call = (function() {

        /**
         * Properties of a Call.
         * @memberof Message
         * @interface ICall
         * @property {Uint8Array|null} [callKey] Call callKey
         */

        /**
         * Constructs a new Call.
         * @memberof Message
         * @classdesc Represents a Call.
         * @implements ICall
         * @constructor
         * @param {Message.ICall=} [properties] Properties to set
         */
        function Call(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Call callKey.
         * @member {Uint8Array} callKey
         * @memberof Message.Call
         * @instance
         */
        Call.prototype.callKey = $util.newBuffer([]);

        /**
         * Creates a new Call instance using the specified properties.
         * @function create
         * @memberof Message.Call
         * @static
         * @param {Message.ICall=} [properties] Properties to set
         * @returns {Message.Call} Call instance
         */
        Call.create = function create(properties) {
            return new Call(properties);
        };

        /**
         * Encodes the specified Call message. Does not implicitly {@link Message.Call.verify|verify} messages.
         * @function encode
         * @memberof Message.Call
         * @static
         * @param {Message.ICall} message Call message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Call.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.callKey != null && Object.hasOwnProperty.call(message, "callKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.callKey);
            return writer;
        };

        /**
         * Encodes the specified Call message, length delimited. Does not implicitly {@link Message.Call.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.Call
         * @static
         * @param {Message.ICall} message Call message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Call.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Call message from the specified reader or buffer.
         * @function decode
         * @memberof Message.Call
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.Call} Call
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Call.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.Call();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.callKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Call message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.Call
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.Call} Call
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Call.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Call message.
         * @function verify
         * @memberof Message.Call
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Call.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.callKey != null && message.hasOwnProperty("callKey"))
                if (!(message.callKey && typeof message.callKey.length === "number" || $util.isString(message.callKey)))
                    return "callKey: buffer expected";
            return null;
        };

        /**
         * Creates a Call message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.Call
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.Call} Call
         */
        Call.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.Call)
                return object;
            var message = new $root.Message.Call();
            if (object.callKey != null)
                if (typeof object.callKey === "string")
                    $util.base64.decode(object.callKey, message.callKey = $util.newBuffer($util.base64.length(object.callKey)), 0);
                else if (object.callKey.length)
                    message.callKey = object.callKey;
            return message;
        };

        /**
         * Creates a plain object from a Call message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.Call
         * @static
         * @param {Message.Call} message Call
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Call.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.callKey = "";
                else {
                    object.callKey = [];
                    if (options.bytes !== Array)
                        object.callKey = $util.newBuffer(object.callKey);
                }
            if (message.callKey != null && message.hasOwnProperty("callKey"))
                object.callKey = options.bytes === String ? $util.base64.encode(message.callKey, 0, message.callKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.callKey) : message.callKey;
            return object;
        };

        /**
         * Converts this Call to JSON.
         * @function toJSON
         * @memberof Message.Call
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Call.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Call;
    })();

    Message.Chat = (function() {

        /**
         * Properties of a Chat.
         * @memberof Message
         * @interface IChat
         * @property {string|null} [displayName] Chat displayName
         * @property {string|null} [id] Chat id
         */

        /**
         * Constructs a new Chat.
         * @memberof Message
         * @classdesc Represents a Chat.
         * @implements IChat
         * @constructor
         * @param {Message.IChat=} [properties] Properties to set
         */
        function Chat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Chat displayName.
         * @member {string} displayName
         * @memberof Message.Chat
         * @instance
         */
        Chat.prototype.displayName = "";

        /**
         * Chat id.
         * @member {string} id
         * @memberof Message.Chat
         * @instance
         */
        Chat.prototype.id = "";

        /**
         * Creates a new Chat instance using the specified properties.
         * @function create
         * @memberof Message.Chat
         * @static
         * @param {Message.IChat=} [properties] Properties to set
         * @returns {Message.Chat} Chat instance
         */
        Chat.create = function create(properties) {
            return new Chat(properties);
        };

        /**
         * Encodes the specified Chat message. Does not implicitly {@link Message.Chat.verify|verify} messages.
         * @function encode
         * @memberof Message.Chat
         * @static
         * @param {Message.IChat} message Chat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Chat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.displayName != null && Object.hasOwnProperty.call(message, "displayName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.displayName);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            return writer;
        };

        /**
         * Encodes the specified Chat message, length delimited. Does not implicitly {@link Message.Chat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.Chat
         * @static
         * @param {Message.IChat} message Chat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Chat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Chat message from the specified reader or buffer.
         * @function decode
         * @memberof Message.Chat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.Chat} Chat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Chat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.Chat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.displayName = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Chat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.Chat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.Chat} Chat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Chat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Chat message.
         * @function verify
         * @memberof Message.Chat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Chat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.displayName != null && message.hasOwnProperty("displayName"))
                if (!$util.isString(message.displayName))
                    return "displayName: string expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        /**
         * Creates a Chat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.Chat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.Chat} Chat
         */
        Chat.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.Chat)
                return object;
            var message = new $root.Message.Chat();
            if (object.displayName != null)
                message.displayName = String(object.displayName);
            if (object.id != null)
                message.id = String(object.id);
            return message;
        };

        /**
         * Creates a plain object from a Chat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.Chat
         * @static
         * @param {Message.Chat} message Chat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Chat.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.displayName = "";
                object.id = "";
            }
            if (message.displayName != null && message.hasOwnProperty("displayName"))
                object.displayName = message.displayName;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this Chat to JSON.
         * @function toJSON
         * @memberof Message.Chat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Chat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Chat;
    })();

    Message.ProtocolMessage = (function() {

        /**
         * Properties of a ProtocolMessage.
         * @memberof Message
         * @interface IProtocolMessage
         * @property {Message.IMessageKey|null} [key] ProtocolMessage key
         * @property {Message.ProtocolMessage.PROTOCOL_MESSAGE_TYPE|null} [type] ProtocolMessage type
         * @property {number|null} [ephemeralExpiration] ProtocolMessage ephemeralExpiration
         * @property {number|Long|null} [ephemeralSettingTimestamp] ProtocolMessage ephemeralSettingTimestamp
         * @property {Message.IHistorySyncNotification|null} [historySyncNotification] ProtocolMessage historySyncNotification
         */

        /**
         * Constructs a new ProtocolMessage.
         * @memberof Message
         * @classdesc Represents a ProtocolMessage.
         * @implements IProtocolMessage
         * @constructor
         * @param {Message.IProtocolMessage=} [properties] Properties to set
         */
        function ProtocolMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProtocolMessage key.
         * @member {Message.IMessageKey|null|undefined} key
         * @memberof Message.ProtocolMessage
         * @instance
         */
        ProtocolMessage.prototype.key = null;

        /**
         * ProtocolMessage type.
         * @member {Message.ProtocolMessage.PROTOCOL_MESSAGE_TYPE} type
         * @memberof Message.ProtocolMessage
         * @instance
         */
        ProtocolMessage.prototype.type = 0;

        /**
         * ProtocolMessage ephemeralExpiration.
         * @member {number} ephemeralExpiration
         * @memberof Message.ProtocolMessage
         * @instance
         */
        ProtocolMessage.prototype.ephemeralExpiration = 0;

        /**
         * ProtocolMessage ephemeralSettingTimestamp.
         * @member {number|Long} ephemeralSettingTimestamp
         * @memberof Message.ProtocolMessage
         * @instance
         */
        ProtocolMessage.prototype.ephemeralSettingTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ProtocolMessage historySyncNotification.
         * @member {Message.IHistorySyncNotification|null|undefined} historySyncNotification
         * @memberof Message.ProtocolMessage
         * @instance
         */
        ProtocolMessage.prototype.historySyncNotification = null;

        /**
         * Creates a new ProtocolMessage instance using the specified properties.
         * @function create
         * @memberof Message.ProtocolMessage
         * @static
         * @param {Message.IProtocolMessage=} [properties] Properties to set
         * @returns {Message.ProtocolMessage} ProtocolMessage instance
         */
        ProtocolMessage.create = function create(properties) {
            return new ProtocolMessage(properties);
        };

        /**
         * Encodes the specified ProtocolMessage message. Does not implicitly {@link Message.ProtocolMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.ProtocolMessage
         * @static
         * @param {Message.IProtocolMessage} message ProtocolMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtocolMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                $root.Message.MessageKey.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.ephemeralExpiration != null && Object.hasOwnProperty.call(message, "ephemeralExpiration"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.ephemeralExpiration);
            if (message.ephemeralSettingTimestamp != null && Object.hasOwnProperty.call(message, "ephemeralSettingTimestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.ephemeralSettingTimestamp);
            if (message.historySyncNotification != null && Object.hasOwnProperty.call(message, "historySyncNotification"))
                $root.Message.HistorySyncNotification.encode(message.historySyncNotification, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ProtocolMessage message, length delimited. Does not implicitly {@link Message.ProtocolMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.ProtocolMessage
         * @static
         * @param {Message.IProtocolMessage} message ProtocolMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProtocolMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProtocolMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.ProtocolMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.ProtocolMessage} ProtocolMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtocolMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.ProtocolMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = $root.Message.MessageKey.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 4:
                    message.ephemeralExpiration = reader.uint32();
                    break;
                case 5:
                    message.ephemeralSettingTimestamp = reader.int64();
                    break;
                case 6:
                    message.historySyncNotification = $root.Message.HistorySyncNotification.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProtocolMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.ProtocolMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.ProtocolMessage} ProtocolMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProtocolMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProtocolMessage message.
         * @function verify
         * @memberof Message.ProtocolMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProtocolMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key")) {
                var error = $root.Message.MessageKey.verify(message.key);
                if (error)
                    return "key." + error;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.ephemeralExpiration != null && message.hasOwnProperty("ephemeralExpiration"))
                if (!$util.isInteger(message.ephemeralExpiration))
                    return "ephemeralExpiration: integer expected";
            if (message.ephemeralSettingTimestamp != null && message.hasOwnProperty("ephemeralSettingTimestamp"))
                if (!$util.isInteger(message.ephemeralSettingTimestamp) && !(message.ephemeralSettingTimestamp && $util.isInteger(message.ephemeralSettingTimestamp.low) && $util.isInteger(message.ephemeralSettingTimestamp.high)))
                    return "ephemeralSettingTimestamp: integer|Long expected";
            if (message.historySyncNotification != null && message.hasOwnProperty("historySyncNotification")) {
                var error = $root.Message.HistorySyncNotification.verify(message.historySyncNotification);
                if (error)
                    return "historySyncNotification." + error;
            }
            return null;
        };

        /**
         * Creates a ProtocolMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.ProtocolMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.ProtocolMessage} ProtocolMessage
         */
        ProtocolMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.ProtocolMessage)
                return object;
            var message = new $root.Message.ProtocolMessage();
            if (object.key != null) {
                if (typeof object.key !== "object")
                    throw TypeError(".Message.ProtocolMessage.key: object expected");
                message.key = $root.Message.MessageKey.fromObject(object.key);
            }
            switch (object.type) {
            case "REVOKE":
            case 0:
                message.type = 0;
                break;
            case "EPHEMERAL_SETTING":
            case 3:
                message.type = 3;
                break;
            case "EPHEMERAL_SYNC_RESPONSE":
            case 4:
                message.type = 4;
                break;
            case "HISTORY_SYNC_NOTIFICATION":
            case 5:
                message.type = 5;
                break;
            }
            if (object.ephemeralExpiration != null)
                message.ephemeralExpiration = object.ephemeralExpiration >>> 0;
            if (object.ephemeralSettingTimestamp != null)
                if ($util.Long)
                    (message.ephemeralSettingTimestamp = $util.Long.fromValue(object.ephemeralSettingTimestamp)).unsigned = false;
                else if (typeof object.ephemeralSettingTimestamp === "string")
                    message.ephemeralSettingTimestamp = parseInt(object.ephemeralSettingTimestamp, 10);
                else if (typeof object.ephemeralSettingTimestamp === "number")
                    message.ephemeralSettingTimestamp = object.ephemeralSettingTimestamp;
                else if (typeof object.ephemeralSettingTimestamp === "object")
                    message.ephemeralSettingTimestamp = new $util.LongBits(object.ephemeralSettingTimestamp.low >>> 0, object.ephemeralSettingTimestamp.high >>> 0).toNumber();
            if (object.historySyncNotification != null) {
                if (typeof object.historySyncNotification !== "object")
                    throw TypeError(".Message.ProtocolMessage.historySyncNotification: object expected");
                message.historySyncNotification = $root.Message.HistorySyncNotification.fromObject(object.historySyncNotification);
            }
            return message;
        };

        /**
         * Creates a plain object from a ProtocolMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.ProtocolMessage
         * @static
         * @param {Message.ProtocolMessage} message ProtocolMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProtocolMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.key = null;
                object.type = options.enums === String ? "REVOKE" : 0;
                object.ephemeralExpiration = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.ephemeralSettingTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ephemeralSettingTimestamp = options.longs === String ? "0" : 0;
                object.historySyncNotification = null;
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = $root.Message.MessageKey.toObject(message.key, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.Message.ProtocolMessage.PROTOCOL_MESSAGE_TYPE[message.type] : message.type;
            if (message.ephemeralExpiration != null && message.hasOwnProperty("ephemeralExpiration"))
                object.ephemeralExpiration = message.ephemeralExpiration;
            if (message.ephemeralSettingTimestamp != null && message.hasOwnProperty("ephemeralSettingTimestamp"))
                if (typeof message.ephemeralSettingTimestamp === "number")
                    object.ephemeralSettingTimestamp = options.longs === String ? String(message.ephemeralSettingTimestamp) : message.ephemeralSettingTimestamp;
                else
                    object.ephemeralSettingTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.ephemeralSettingTimestamp) : options.longs === Number ? new $util.LongBits(message.ephemeralSettingTimestamp.low >>> 0, message.ephemeralSettingTimestamp.high >>> 0).toNumber() : message.ephemeralSettingTimestamp;
            if (message.historySyncNotification != null && message.hasOwnProperty("historySyncNotification"))
                object.historySyncNotification = $root.Message.HistorySyncNotification.toObject(message.historySyncNotification, options);
            return object;
        };

        /**
         * Converts this ProtocolMessage to JSON.
         * @function toJSON
         * @memberof Message.ProtocolMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProtocolMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * PROTOCOL_MESSAGE_TYPE enum.
         * @name Message.ProtocolMessage.PROTOCOL_MESSAGE_TYPE
         * @enum {number}
         * @property {number} REVOKE=0 REVOKE value
         * @property {number} EPHEMERAL_SETTING=3 EPHEMERAL_SETTING value
         * @property {number} EPHEMERAL_SYNC_RESPONSE=4 EPHEMERAL_SYNC_RESPONSE value
         * @property {number} HISTORY_SYNC_NOTIFICATION=5 HISTORY_SYNC_NOTIFICATION value
         */
        ProtocolMessage.PROTOCOL_MESSAGE_TYPE = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "REVOKE"] = 0;
            values[valuesById[3] = "EPHEMERAL_SETTING"] = 3;
            values[valuesById[4] = "EPHEMERAL_SYNC_RESPONSE"] = 4;
            values[valuesById[5] = "HISTORY_SYNC_NOTIFICATION"] = 5;
            return values;
        })();

        return ProtocolMessage;
    })();

    Message.HistorySyncNotification = (function() {

        /**
         * Properties of a HistorySyncNotification.
         * @memberof Message
         * @interface IHistorySyncNotification
         * @property {Uint8Array|null} [fileSha256] HistorySyncNotification fileSha256
         * @property {number|Long|null} [fileLength] HistorySyncNotification fileLength
         * @property {Uint8Array|null} [mediaKey] HistorySyncNotification mediaKey
         * @property {Uint8Array|null} [fileEncSha256] HistorySyncNotification fileEncSha256
         * @property {string|null} [directPath] HistorySyncNotification directPath
         * @property {Message.HistorySyncNotification.HISTORY_SYNC_NOTIFICATION_HISTORYSYNCTYPE|null} [syncType] HistorySyncNotification syncType
         * @property {number|null} [chunkOrder] HistorySyncNotification chunkOrder
         * @property {string|null} [originalMessageId] HistorySyncNotification originalMessageId
         */

        /**
         * Constructs a new HistorySyncNotification.
         * @memberof Message
         * @classdesc Represents a HistorySyncNotification.
         * @implements IHistorySyncNotification
         * @constructor
         * @param {Message.IHistorySyncNotification=} [properties] Properties to set
         */
        function HistorySyncNotification(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HistorySyncNotification fileSha256.
         * @member {Uint8Array} fileSha256
         * @memberof Message.HistorySyncNotification
         * @instance
         */
        HistorySyncNotification.prototype.fileSha256 = $util.newBuffer([]);

        /**
         * HistorySyncNotification fileLength.
         * @member {number|Long} fileLength
         * @memberof Message.HistorySyncNotification
         * @instance
         */
        HistorySyncNotification.prototype.fileLength = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * HistorySyncNotification mediaKey.
         * @member {Uint8Array} mediaKey
         * @memberof Message.HistorySyncNotification
         * @instance
         */
        HistorySyncNotification.prototype.mediaKey = $util.newBuffer([]);

        /**
         * HistorySyncNotification fileEncSha256.
         * @member {Uint8Array} fileEncSha256
         * @memberof Message.HistorySyncNotification
         * @instance
         */
        HistorySyncNotification.prototype.fileEncSha256 = $util.newBuffer([]);

        /**
         * HistorySyncNotification directPath.
         * @member {string} directPath
         * @memberof Message.HistorySyncNotification
         * @instance
         */
        HistorySyncNotification.prototype.directPath = "";

        /**
         * HistorySyncNotification syncType.
         * @member {Message.HistorySyncNotification.HISTORY_SYNC_NOTIFICATION_HISTORYSYNCTYPE} syncType
         * @memberof Message.HistorySyncNotification
         * @instance
         */
        HistorySyncNotification.prototype.syncType = 0;

        /**
         * HistorySyncNotification chunkOrder.
         * @member {number} chunkOrder
         * @memberof Message.HistorySyncNotification
         * @instance
         */
        HistorySyncNotification.prototype.chunkOrder = 0;

        /**
         * HistorySyncNotification originalMessageId.
         * @member {string} originalMessageId
         * @memberof Message.HistorySyncNotification
         * @instance
         */
        HistorySyncNotification.prototype.originalMessageId = "";

        /**
         * Creates a new HistorySyncNotification instance using the specified properties.
         * @function create
         * @memberof Message.HistorySyncNotification
         * @static
         * @param {Message.IHistorySyncNotification=} [properties] Properties to set
         * @returns {Message.HistorySyncNotification} HistorySyncNotification instance
         */
        HistorySyncNotification.create = function create(properties) {
            return new HistorySyncNotification(properties);
        };

        /**
         * Encodes the specified HistorySyncNotification message. Does not implicitly {@link Message.HistorySyncNotification.verify|verify} messages.
         * @function encode
         * @memberof Message.HistorySyncNotification
         * @static
         * @param {Message.IHistorySyncNotification} message HistorySyncNotification message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HistorySyncNotification.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fileSha256 != null && Object.hasOwnProperty.call(message, "fileSha256"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.fileSha256);
            if (message.fileLength != null && Object.hasOwnProperty.call(message, "fileLength"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.fileLength);
            if (message.mediaKey != null && Object.hasOwnProperty.call(message, "mediaKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.mediaKey);
            if (message.fileEncSha256 != null && Object.hasOwnProperty.call(message, "fileEncSha256"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.fileEncSha256);
            if (message.directPath != null && Object.hasOwnProperty.call(message, "directPath"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.directPath);
            if (message.syncType != null && Object.hasOwnProperty.call(message, "syncType"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.syncType);
            if (message.chunkOrder != null && Object.hasOwnProperty.call(message, "chunkOrder"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.chunkOrder);
            if (message.originalMessageId != null && Object.hasOwnProperty.call(message, "originalMessageId"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.originalMessageId);
            return writer;
        };

        /**
         * Encodes the specified HistorySyncNotification message, length delimited. Does not implicitly {@link Message.HistorySyncNotification.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.HistorySyncNotification
         * @static
         * @param {Message.IHistorySyncNotification} message HistorySyncNotification message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HistorySyncNotification.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HistorySyncNotification message from the specified reader or buffer.
         * @function decode
         * @memberof Message.HistorySyncNotification
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.HistorySyncNotification} HistorySyncNotification
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HistorySyncNotification.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.HistorySyncNotification();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fileSha256 = reader.bytes();
                    break;
                case 2:
                    message.fileLength = reader.uint64();
                    break;
                case 3:
                    message.mediaKey = reader.bytes();
                    break;
                case 4:
                    message.fileEncSha256 = reader.bytes();
                    break;
                case 5:
                    message.directPath = reader.string();
                    break;
                case 6:
                    message.syncType = reader.int32();
                    break;
                case 7:
                    message.chunkOrder = reader.uint32();
                    break;
                case 8:
                    message.originalMessageId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HistorySyncNotification message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.HistorySyncNotification
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.HistorySyncNotification} HistorySyncNotification
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HistorySyncNotification.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HistorySyncNotification message.
         * @function verify
         * @memberof Message.HistorySyncNotification
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HistorySyncNotification.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                if (!(message.fileSha256 && typeof message.fileSha256.length === "number" || $util.isString(message.fileSha256)))
                    return "fileSha256: buffer expected";
            if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                if (!$util.isInteger(message.fileLength) && !(message.fileLength && $util.isInteger(message.fileLength.low) && $util.isInteger(message.fileLength.high)))
                    return "fileLength: integer|Long expected";
            if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                if (!(message.mediaKey && typeof message.mediaKey.length === "number" || $util.isString(message.mediaKey)))
                    return "mediaKey: buffer expected";
            if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                if (!(message.fileEncSha256 && typeof message.fileEncSha256.length === "number" || $util.isString(message.fileEncSha256)))
                    return "fileEncSha256: buffer expected";
            if (message.directPath != null && message.hasOwnProperty("directPath"))
                if (!$util.isString(message.directPath))
                    return "directPath: string expected";
            if (message.syncType != null && message.hasOwnProperty("syncType"))
                switch (message.syncType) {
                default:
                    return "syncType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.chunkOrder != null && message.hasOwnProperty("chunkOrder"))
                if (!$util.isInteger(message.chunkOrder))
                    return "chunkOrder: integer expected";
            if (message.originalMessageId != null && message.hasOwnProperty("originalMessageId"))
                if (!$util.isString(message.originalMessageId))
                    return "originalMessageId: string expected";
            return null;
        };

        /**
         * Creates a HistorySyncNotification message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.HistorySyncNotification
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.HistorySyncNotification} HistorySyncNotification
         */
        HistorySyncNotification.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.HistorySyncNotification)
                return object;
            var message = new $root.Message.HistorySyncNotification();
            if (object.fileSha256 != null)
                if (typeof object.fileSha256 === "string")
                    $util.base64.decode(object.fileSha256, message.fileSha256 = $util.newBuffer($util.base64.length(object.fileSha256)), 0);
                else if (object.fileSha256.length)
                    message.fileSha256 = object.fileSha256;
            if (object.fileLength != null)
                if ($util.Long)
                    (message.fileLength = $util.Long.fromValue(object.fileLength)).unsigned = true;
                else if (typeof object.fileLength === "string")
                    message.fileLength = parseInt(object.fileLength, 10);
                else if (typeof object.fileLength === "number")
                    message.fileLength = object.fileLength;
                else if (typeof object.fileLength === "object")
                    message.fileLength = new $util.LongBits(object.fileLength.low >>> 0, object.fileLength.high >>> 0).toNumber(true);
            if (object.mediaKey != null)
                if (typeof object.mediaKey === "string")
                    $util.base64.decode(object.mediaKey, message.mediaKey = $util.newBuffer($util.base64.length(object.mediaKey)), 0);
                else if (object.mediaKey.length)
                    message.mediaKey = object.mediaKey;
            if (object.fileEncSha256 != null)
                if (typeof object.fileEncSha256 === "string")
                    $util.base64.decode(object.fileEncSha256, message.fileEncSha256 = $util.newBuffer($util.base64.length(object.fileEncSha256)), 0);
                else if (object.fileEncSha256.length)
                    message.fileEncSha256 = object.fileEncSha256;
            if (object.directPath != null)
                message.directPath = String(object.directPath);
            switch (object.syncType) {
            case "INITIAL_BOOTSTRAP":
            case 0:
                message.syncType = 0;
                break;
            case "INITIAL_STATUS_V3":
            case 1:
                message.syncType = 1;
                break;
            case "FULL":
            case 2:
                message.syncType = 2;
                break;
            case "RECENT":
            case 3:
                message.syncType = 3;
                break;
            case "RESEND":
            case 4:
                message.syncType = 4;
                break;
            }
            if (object.chunkOrder != null)
                message.chunkOrder = object.chunkOrder >>> 0;
            if (object.originalMessageId != null)
                message.originalMessageId = String(object.originalMessageId);
            return message;
        };

        /**
         * Creates a plain object from a HistorySyncNotification message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.HistorySyncNotification
         * @static
         * @param {Message.HistorySyncNotification} message HistorySyncNotification
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HistorySyncNotification.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.fileSha256 = "";
                else {
                    object.fileSha256 = [];
                    if (options.bytes !== Array)
                        object.fileSha256 = $util.newBuffer(object.fileSha256);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.fileLength = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fileLength = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.mediaKey = "";
                else {
                    object.mediaKey = [];
                    if (options.bytes !== Array)
                        object.mediaKey = $util.newBuffer(object.mediaKey);
                }
                if (options.bytes === String)
                    object.fileEncSha256 = "";
                else {
                    object.fileEncSha256 = [];
                    if (options.bytes !== Array)
                        object.fileEncSha256 = $util.newBuffer(object.fileEncSha256);
                }
                object.directPath = "";
                object.syncType = options.enums === String ? "INITIAL_BOOTSTRAP" : 0;
                object.chunkOrder = 0;
                object.originalMessageId = "";
            }
            if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                object.fileSha256 = options.bytes === String ? $util.base64.encode(message.fileSha256, 0, message.fileSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileSha256) : message.fileSha256;
            if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                if (typeof message.fileLength === "number")
                    object.fileLength = options.longs === String ? String(message.fileLength) : message.fileLength;
                else
                    object.fileLength = options.longs === String ? $util.Long.prototype.toString.call(message.fileLength) : options.longs === Number ? new $util.LongBits(message.fileLength.low >>> 0, message.fileLength.high >>> 0).toNumber(true) : message.fileLength;
            if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                object.mediaKey = options.bytes === String ? $util.base64.encode(message.mediaKey, 0, message.mediaKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.mediaKey) : message.mediaKey;
            if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                object.fileEncSha256 = options.bytes === String ? $util.base64.encode(message.fileEncSha256, 0, message.fileEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileEncSha256) : message.fileEncSha256;
            if (message.directPath != null && message.hasOwnProperty("directPath"))
                object.directPath = message.directPath;
            if (message.syncType != null && message.hasOwnProperty("syncType"))
                object.syncType = options.enums === String ? $root.Message.HistorySyncNotification.HISTORY_SYNC_NOTIFICATION_HISTORYSYNCTYPE[message.syncType] : message.syncType;
            if (message.chunkOrder != null && message.hasOwnProperty("chunkOrder"))
                object.chunkOrder = message.chunkOrder;
            if (message.originalMessageId != null && message.hasOwnProperty("originalMessageId"))
                object.originalMessageId = message.originalMessageId;
            return object;
        };

        /**
         * Converts this HistorySyncNotification to JSON.
         * @function toJSON
         * @memberof Message.HistorySyncNotification
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HistorySyncNotification.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * HISTORY_SYNC_NOTIFICATION_HISTORYSYNCTYPE enum.
         * @name Message.HistorySyncNotification.HISTORY_SYNC_NOTIFICATION_HISTORYSYNCTYPE
         * @enum {number}
         * @property {number} INITIAL_BOOTSTRAP=0 INITIAL_BOOTSTRAP value
         * @property {number} INITIAL_STATUS_V3=1 INITIAL_STATUS_V3 value
         * @property {number} FULL=2 FULL value
         * @property {number} RECENT=3 RECENT value
         * @property {number} RESEND=4 RESEND value
         */
        HistorySyncNotification.HISTORY_SYNC_NOTIFICATION_HISTORYSYNCTYPE = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "INITIAL_BOOTSTRAP"] = 0;
            values[valuesById[1] = "INITIAL_STATUS_V3"] = 1;
            values[valuesById[2] = "FULL"] = 2;
            values[valuesById[3] = "RECENT"] = 3;
            values[valuesById[4] = "RESEND"] = 4;
            return values;
        })();

        return HistorySyncNotification;
    })();

    Message.ContactsArrayMessage = (function() {

        /**
         * Properties of a ContactsArrayMessage.
         * @memberof Message
         * @interface IContactsArrayMessage
         * @property {string|null} [displayName] ContactsArrayMessage displayName
         * @property {Array.<Message.IContactMessage>|null} [contacts] ContactsArrayMessage contacts
         * @property {Message.IContextInfo|null} [contextInfo] ContactsArrayMessage contextInfo
         */

        /**
         * Constructs a new ContactsArrayMessage.
         * @memberof Message
         * @classdesc Represents a ContactsArrayMessage.
         * @implements IContactsArrayMessage
         * @constructor
         * @param {Message.IContactsArrayMessage=} [properties] Properties to set
         */
        function ContactsArrayMessage(properties) {
            this.contacts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContactsArrayMessage displayName.
         * @member {string} displayName
         * @memberof Message.ContactsArrayMessage
         * @instance
         */
        ContactsArrayMessage.prototype.displayName = "";

        /**
         * ContactsArrayMessage contacts.
         * @member {Array.<Message.IContactMessage>} contacts
         * @memberof Message.ContactsArrayMessage
         * @instance
         */
        ContactsArrayMessage.prototype.contacts = $util.emptyArray;

        /**
         * ContactsArrayMessage contextInfo.
         * @member {Message.IContextInfo|null|undefined} contextInfo
         * @memberof Message.ContactsArrayMessage
         * @instance
         */
        ContactsArrayMessage.prototype.contextInfo = null;

        /**
         * Creates a new ContactsArrayMessage instance using the specified properties.
         * @function create
         * @memberof Message.ContactsArrayMessage
         * @static
         * @param {Message.IContactsArrayMessage=} [properties] Properties to set
         * @returns {Message.ContactsArrayMessage} ContactsArrayMessage instance
         */
        ContactsArrayMessage.create = function create(properties) {
            return new ContactsArrayMessage(properties);
        };

        /**
         * Encodes the specified ContactsArrayMessage message. Does not implicitly {@link Message.ContactsArrayMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.ContactsArrayMessage
         * @static
         * @param {Message.IContactsArrayMessage} message ContactsArrayMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContactsArrayMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.displayName != null && Object.hasOwnProperty.call(message, "displayName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.displayName);
            if (message.contacts != null && message.contacts.length)
                for (var i = 0; i < message.contacts.length; ++i)
                    $root.Message.ContactMessage.encode(message.contacts[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                $root.Message.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ContactsArrayMessage message, length delimited. Does not implicitly {@link Message.ContactsArrayMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.ContactsArrayMessage
         * @static
         * @param {Message.IContactsArrayMessage} message ContactsArrayMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContactsArrayMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContactsArrayMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.ContactsArrayMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.ContactsArrayMessage} ContactsArrayMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContactsArrayMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.ContactsArrayMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.displayName = reader.string();
                    break;
                case 2:
                    if (!(message.contacts && message.contacts.length))
                        message.contacts = [];
                    message.contacts.push($root.Message.ContactMessage.decode(reader, reader.uint32()));
                    break;
                case 17:
                    message.contextInfo = $root.Message.ContextInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContactsArrayMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.ContactsArrayMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.ContactsArrayMessage} ContactsArrayMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContactsArrayMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContactsArrayMessage message.
         * @function verify
         * @memberof Message.ContactsArrayMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContactsArrayMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.displayName != null && message.hasOwnProperty("displayName"))
                if (!$util.isString(message.displayName))
                    return "displayName: string expected";
            if (message.contacts != null && message.hasOwnProperty("contacts")) {
                if (!Array.isArray(message.contacts))
                    return "contacts: array expected";
                for (var i = 0; i < message.contacts.length; ++i) {
                    var error = $root.Message.ContactMessage.verify(message.contacts[i]);
                    if (error)
                        return "contacts." + error;
                }
            }
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                var error = $root.Message.ContextInfo.verify(message.contextInfo);
                if (error)
                    return "contextInfo." + error;
            }
            return null;
        };

        /**
         * Creates a ContactsArrayMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.ContactsArrayMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.ContactsArrayMessage} ContactsArrayMessage
         */
        ContactsArrayMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.ContactsArrayMessage)
                return object;
            var message = new $root.Message.ContactsArrayMessage();
            if (object.displayName != null)
                message.displayName = String(object.displayName);
            if (object.contacts) {
                if (!Array.isArray(object.contacts))
                    throw TypeError(".Message.ContactsArrayMessage.contacts: array expected");
                message.contacts = [];
                for (var i = 0; i < object.contacts.length; ++i) {
                    if (typeof object.contacts[i] !== "object")
                        throw TypeError(".Message.ContactsArrayMessage.contacts: object expected");
                    message.contacts[i] = $root.Message.ContactMessage.fromObject(object.contacts[i]);
                }
            }
            if (object.contextInfo != null) {
                if (typeof object.contextInfo !== "object")
                    throw TypeError(".Message.ContactsArrayMessage.contextInfo: object expected");
                message.contextInfo = $root.Message.ContextInfo.fromObject(object.contextInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a ContactsArrayMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.ContactsArrayMessage
         * @static
         * @param {Message.ContactsArrayMessage} message ContactsArrayMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContactsArrayMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.contacts = [];
            if (options.defaults) {
                object.displayName = "";
                object.contextInfo = null;
            }
            if (message.displayName != null && message.hasOwnProperty("displayName"))
                object.displayName = message.displayName;
            if (message.contacts && message.contacts.length) {
                object.contacts = [];
                for (var j = 0; j < message.contacts.length; ++j)
                    object.contacts[j] = $root.Message.ContactMessage.toObject(message.contacts[j], options);
            }
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                object.contextInfo = $root.Message.ContextInfo.toObject(message.contextInfo, options);
            return object;
        };

        /**
         * Converts this ContactsArrayMessage to JSON.
         * @function toJSON
         * @memberof Message.ContactsArrayMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContactsArrayMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ContactsArrayMessage;
    })();

    Message.HSMCurrency = (function() {

        /**
         * Properties of a HSMCurrency.
         * @memberof Message
         * @interface IHSMCurrency
         * @property {string|null} [currencyCode] HSMCurrency currencyCode
         * @property {number|Long|null} [amount1000] HSMCurrency amount1000
         */

        /**
         * Constructs a new HSMCurrency.
         * @memberof Message
         * @classdesc Represents a HSMCurrency.
         * @implements IHSMCurrency
         * @constructor
         * @param {Message.IHSMCurrency=} [properties] Properties to set
         */
        function HSMCurrency(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HSMCurrency currencyCode.
         * @member {string} currencyCode
         * @memberof Message.HSMCurrency
         * @instance
         */
        HSMCurrency.prototype.currencyCode = "";

        /**
         * HSMCurrency amount1000.
         * @member {number|Long} amount1000
         * @memberof Message.HSMCurrency
         * @instance
         */
        HSMCurrency.prototype.amount1000 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new HSMCurrency instance using the specified properties.
         * @function create
         * @memberof Message.HSMCurrency
         * @static
         * @param {Message.IHSMCurrency=} [properties] Properties to set
         * @returns {Message.HSMCurrency} HSMCurrency instance
         */
        HSMCurrency.create = function create(properties) {
            return new HSMCurrency(properties);
        };

        /**
         * Encodes the specified HSMCurrency message. Does not implicitly {@link Message.HSMCurrency.verify|verify} messages.
         * @function encode
         * @memberof Message.HSMCurrency
         * @static
         * @param {Message.IHSMCurrency} message HSMCurrency message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HSMCurrency.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currencyCode != null && Object.hasOwnProperty.call(message, "currencyCode"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.currencyCode);
            if (message.amount1000 != null && Object.hasOwnProperty.call(message, "amount1000"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount1000);
            return writer;
        };

        /**
         * Encodes the specified HSMCurrency message, length delimited. Does not implicitly {@link Message.HSMCurrency.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.HSMCurrency
         * @static
         * @param {Message.IHSMCurrency} message HSMCurrency message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HSMCurrency.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HSMCurrency message from the specified reader or buffer.
         * @function decode
         * @memberof Message.HSMCurrency
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.HSMCurrency} HSMCurrency
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HSMCurrency.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.HSMCurrency();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.currencyCode = reader.string();
                    break;
                case 2:
                    message.amount1000 = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HSMCurrency message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.HSMCurrency
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.HSMCurrency} HSMCurrency
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HSMCurrency.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HSMCurrency message.
         * @function verify
         * @memberof Message.HSMCurrency
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HSMCurrency.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
                if (!$util.isString(message.currencyCode))
                    return "currencyCode: string expected";
            if (message.amount1000 != null && message.hasOwnProperty("amount1000"))
                if (!$util.isInteger(message.amount1000) && !(message.amount1000 && $util.isInteger(message.amount1000.low) && $util.isInteger(message.amount1000.high)))
                    return "amount1000: integer|Long expected";
            return null;
        };

        /**
         * Creates a HSMCurrency message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.HSMCurrency
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.HSMCurrency} HSMCurrency
         */
        HSMCurrency.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.HSMCurrency)
                return object;
            var message = new $root.Message.HSMCurrency();
            if (object.currencyCode != null)
                message.currencyCode = String(object.currencyCode);
            if (object.amount1000 != null)
                if ($util.Long)
                    (message.amount1000 = $util.Long.fromValue(object.amount1000)).unsigned = false;
                else if (typeof object.amount1000 === "string")
                    message.amount1000 = parseInt(object.amount1000, 10);
                else if (typeof object.amount1000 === "number")
                    message.amount1000 = object.amount1000;
                else if (typeof object.amount1000 === "object")
                    message.amount1000 = new $util.LongBits(object.amount1000.low >>> 0, object.amount1000.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a HSMCurrency message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.HSMCurrency
         * @static
         * @param {Message.HSMCurrency} message HSMCurrency
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HSMCurrency.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.currencyCode = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amount1000 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount1000 = options.longs === String ? "0" : 0;
            }
            if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
                object.currencyCode = message.currencyCode;
            if (message.amount1000 != null && message.hasOwnProperty("amount1000"))
                if (typeof message.amount1000 === "number")
                    object.amount1000 = options.longs === String ? String(message.amount1000) : message.amount1000;
                else
                    object.amount1000 = options.longs === String ? $util.Long.prototype.toString.call(message.amount1000) : options.longs === Number ? new $util.LongBits(message.amount1000.low >>> 0, message.amount1000.high >>> 0).toNumber() : message.amount1000;
            return object;
        };

        /**
         * Converts this HSMCurrency to JSON.
         * @function toJSON
         * @memberof Message.HSMCurrency
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HSMCurrency.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HSMCurrency;
    })();

    Message.HSMDateTimeComponent = (function() {

        /**
         * Properties of a HSMDateTimeComponent.
         * @memberof Message
         * @interface IHSMDateTimeComponent
         * @property {Message.HSMDateTimeComponent.HSM_DATE_TIME_COMPONENT_DAYOFWEEKTYPE|null} [dayOfWeek] HSMDateTimeComponent dayOfWeek
         * @property {number|null} [year] HSMDateTimeComponent year
         * @property {number|null} [month] HSMDateTimeComponent month
         * @property {number|null} [dayOfMonth] HSMDateTimeComponent dayOfMonth
         * @property {number|null} [hour] HSMDateTimeComponent hour
         * @property {number|null} [minute] HSMDateTimeComponent minute
         * @property {Message.HSMDateTimeComponent.HSM_DATE_TIME_COMPONENT_CALENDARTYPE|null} [calendar] HSMDateTimeComponent calendar
         */

        /**
         * Constructs a new HSMDateTimeComponent.
         * @memberof Message
         * @classdesc Represents a HSMDateTimeComponent.
         * @implements IHSMDateTimeComponent
         * @constructor
         * @param {Message.IHSMDateTimeComponent=} [properties] Properties to set
         */
        function HSMDateTimeComponent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HSMDateTimeComponent dayOfWeek.
         * @member {Message.HSMDateTimeComponent.HSM_DATE_TIME_COMPONENT_DAYOFWEEKTYPE} dayOfWeek
         * @memberof Message.HSMDateTimeComponent
         * @instance
         */
        HSMDateTimeComponent.prototype.dayOfWeek = 1;

        /**
         * HSMDateTimeComponent year.
         * @member {number} year
         * @memberof Message.HSMDateTimeComponent
         * @instance
         */
        HSMDateTimeComponent.prototype.year = 0;

        /**
         * HSMDateTimeComponent month.
         * @member {number} month
         * @memberof Message.HSMDateTimeComponent
         * @instance
         */
        HSMDateTimeComponent.prototype.month = 0;

        /**
         * HSMDateTimeComponent dayOfMonth.
         * @member {number} dayOfMonth
         * @memberof Message.HSMDateTimeComponent
         * @instance
         */
        HSMDateTimeComponent.prototype.dayOfMonth = 0;

        /**
         * HSMDateTimeComponent hour.
         * @member {number} hour
         * @memberof Message.HSMDateTimeComponent
         * @instance
         */
        HSMDateTimeComponent.prototype.hour = 0;

        /**
         * HSMDateTimeComponent minute.
         * @member {number} minute
         * @memberof Message.HSMDateTimeComponent
         * @instance
         */
        HSMDateTimeComponent.prototype.minute = 0;

        /**
         * HSMDateTimeComponent calendar.
         * @member {Message.HSMDateTimeComponent.HSM_DATE_TIME_COMPONENT_CALENDARTYPE} calendar
         * @memberof Message.HSMDateTimeComponent
         * @instance
         */
        HSMDateTimeComponent.prototype.calendar = 1;

        /**
         * Creates a new HSMDateTimeComponent instance using the specified properties.
         * @function create
         * @memberof Message.HSMDateTimeComponent
         * @static
         * @param {Message.IHSMDateTimeComponent=} [properties] Properties to set
         * @returns {Message.HSMDateTimeComponent} HSMDateTimeComponent instance
         */
        HSMDateTimeComponent.create = function create(properties) {
            return new HSMDateTimeComponent(properties);
        };

        /**
         * Encodes the specified HSMDateTimeComponent message. Does not implicitly {@link Message.HSMDateTimeComponent.verify|verify} messages.
         * @function encode
         * @memberof Message.HSMDateTimeComponent
         * @static
         * @param {Message.IHSMDateTimeComponent} message HSMDateTimeComponent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HSMDateTimeComponent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dayOfWeek != null && Object.hasOwnProperty.call(message, "dayOfWeek"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.dayOfWeek);
            if (message.year != null && Object.hasOwnProperty.call(message, "year"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.year);
            if (message.month != null && Object.hasOwnProperty.call(message, "month"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.month);
            if (message.dayOfMonth != null && Object.hasOwnProperty.call(message, "dayOfMonth"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.dayOfMonth);
            if (message.hour != null && Object.hasOwnProperty.call(message, "hour"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.hour);
            if (message.minute != null && Object.hasOwnProperty.call(message, "minute"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.minute);
            if (message.calendar != null && Object.hasOwnProperty.call(message, "calendar"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.calendar);
            return writer;
        };

        /**
         * Encodes the specified HSMDateTimeComponent message, length delimited. Does not implicitly {@link Message.HSMDateTimeComponent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.HSMDateTimeComponent
         * @static
         * @param {Message.IHSMDateTimeComponent} message HSMDateTimeComponent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HSMDateTimeComponent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HSMDateTimeComponent message from the specified reader or buffer.
         * @function decode
         * @memberof Message.HSMDateTimeComponent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.HSMDateTimeComponent} HSMDateTimeComponent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HSMDateTimeComponent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.HSMDateTimeComponent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dayOfWeek = reader.int32();
                    break;
                case 2:
                    message.year = reader.uint32();
                    break;
                case 3:
                    message.month = reader.uint32();
                    break;
                case 4:
                    message.dayOfMonth = reader.uint32();
                    break;
                case 5:
                    message.hour = reader.uint32();
                    break;
                case 6:
                    message.minute = reader.uint32();
                    break;
                case 7:
                    message.calendar = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HSMDateTimeComponent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.HSMDateTimeComponent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.HSMDateTimeComponent} HSMDateTimeComponent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HSMDateTimeComponent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HSMDateTimeComponent message.
         * @function verify
         * @memberof Message.HSMDateTimeComponent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HSMDateTimeComponent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dayOfWeek != null && message.hasOwnProperty("dayOfWeek"))
                switch (message.dayOfWeek) {
                default:
                    return "dayOfWeek: enum value expected";
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            if (message.year != null && message.hasOwnProperty("year"))
                if (!$util.isInteger(message.year))
                    return "year: integer expected";
            if (message.month != null && message.hasOwnProperty("month"))
                if (!$util.isInteger(message.month))
                    return "month: integer expected";
            if (message.dayOfMonth != null && message.hasOwnProperty("dayOfMonth"))
                if (!$util.isInteger(message.dayOfMonth))
                    return "dayOfMonth: integer expected";
            if (message.hour != null && message.hasOwnProperty("hour"))
                if (!$util.isInteger(message.hour))
                    return "hour: integer expected";
            if (message.minute != null && message.hasOwnProperty("minute"))
                if (!$util.isInteger(message.minute))
                    return "minute: integer expected";
            if (message.calendar != null && message.hasOwnProperty("calendar"))
                switch (message.calendar) {
                default:
                    return "calendar: enum value expected";
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a HSMDateTimeComponent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.HSMDateTimeComponent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.HSMDateTimeComponent} HSMDateTimeComponent
         */
        HSMDateTimeComponent.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.HSMDateTimeComponent)
                return object;
            var message = new $root.Message.HSMDateTimeComponent();
            switch (object.dayOfWeek) {
            case "MONDAY":
            case 1:
                message.dayOfWeek = 1;
                break;
            case "TUESDAY":
            case 2:
                message.dayOfWeek = 2;
                break;
            case "WEDNESDAY":
            case 3:
                message.dayOfWeek = 3;
                break;
            case "THURSDAY":
            case 4:
                message.dayOfWeek = 4;
                break;
            case "FRIDAY":
            case 5:
                message.dayOfWeek = 5;
                break;
            case "SATURDAY":
            case 6:
                message.dayOfWeek = 6;
                break;
            case "SUNDAY":
            case 7:
                message.dayOfWeek = 7;
                break;
            }
            if (object.year != null)
                message.year = object.year >>> 0;
            if (object.month != null)
                message.month = object.month >>> 0;
            if (object.dayOfMonth != null)
                message.dayOfMonth = object.dayOfMonth >>> 0;
            if (object.hour != null)
                message.hour = object.hour >>> 0;
            if (object.minute != null)
                message.minute = object.minute >>> 0;
            switch (object.calendar) {
            case "GREGORIAN":
            case 1:
                message.calendar = 1;
                break;
            case "SOLAR_HIJRI":
            case 2:
                message.calendar = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a HSMDateTimeComponent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.HSMDateTimeComponent
         * @static
         * @param {Message.HSMDateTimeComponent} message HSMDateTimeComponent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HSMDateTimeComponent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.dayOfWeek = options.enums === String ? "MONDAY" : 1;
                object.year = 0;
                object.month = 0;
                object.dayOfMonth = 0;
                object.hour = 0;
                object.minute = 0;
                object.calendar = options.enums === String ? "GREGORIAN" : 1;
            }
            if (message.dayOfWeek != null && message.hasOwnProperty("dayOfWeek"))
                object.dayOfWeek = options.enums === String ? $root.Message.HSMDateTimeComponent.HSM_DATE_TIME_COMPONENT_DAYOFWEEKTYPE[message.dayOfWeek] : message.dayOfWeek;
            if (message.year != null && message.hasOwnProperty("year"))
                object.year = message.year;
            if (message.month != null && message.hasOwnProperty("month"))
                object.month = message.month;
            if (message.dayOfMonth != null && message.hasOwnProperty("dayOfMonth"))
                object.dayOfMonth = message.dayOfMonth;
            if (message.hour != null && message.hasOwnProperty("hour"))
                object.hour = message.hour;
            if (message.minute != null && message.hasOwnProperty("minute"))
                object.minute = message.minute;
            if (message.calendar != null && message.hasOwnProperty("calendar"))
                object.calendar = options.enums === String ? $root.Message.HSMDateTimeComponent.HSM_DATE_TIME_COMPONENT_CALENDARTYPE[message.calendar] : message.calendar;
            return object;
        };

        /**
         * Converts this HSMDateTimeComponent to JSON.
         * @function toJSON
         * @memberof Message.HSMDateTimeComponent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HSMDateTimeComponent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * HSM_DATE_TIME_COMPONENT_DAYOFWEEKTYPE enum.
         * @name Message.HSMDateTimeComponent.HSM_DATE_TIME_COMPONENT_DAYOFWEEKTYPE
         * @enum {number}
         * @property {number} MONDAY=1 MONDAY value
         * @property {number} TUESDAY=2 TUESDAY value
         * @property {number} WEDNESDAY=3 WEDNESDAY value
         * @property {number} THURSDAY=4 THURSDAY value
         * @property {number} FRIDAY=5 FRIDAY value
         * @property {number} SATURDAY=6 SATURDAY value
         * @property {number} SUNDAY=7 SUNDAY value
         */
        HSMDateTimeComponent.HSM_DATE_TIME_COMPONENT_DAYOFWEEKTYPE = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "MONDAY"] = 1;
            values[valuesById[2] = "TUESDAY"] = 2;
            values[valuesById[3] = "WEDNESDAY"] = 3;
            values[valuesById[4] = "THURSDAY"] = 4;
            values[valuesById[5] = "FRIDAY"] = 5;
            values[valuesById[6] = "SATURDAY"] = 6;
            values[valuesById[7] = "SUNDAY"] = 7;
            return values;
        })();

        /**
         * HSM_DATE_TIME_COMPONENT_CALENDARTYPE enum.
         * @name Message.HSMDateTimeComponent.HSM_DATE_TIME_COMPONENT_CALENDARTYPE
         * @enum {number}
         * @property {number} GREGORIAN=1 GREGORIAN value
         * @property {number} SOLAR_HIJRI=2 SOLAR_HIJRI value
         */
        HSMDateTimeComponent.HSM_DATE_TIME_COMPONENT_CALENDARTYPE = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "GREGORIAN"] = 1;
            values[valuesById[2] = "SOLAR_HIJRI"] = 2;
            return values;
        })();

        return HSMDateTimeComponent;
    })();

    Message.HSMDateTimeUnixEpoch = (function() {

        /**
         * Properties of a HSMDateTimeUnixEpoch.
         * @memberof Message
         * @interface IHSMDateTimeUnixEpoch
         * @property {number|Long|null} [timestamp] HSMDateTimeUnixEpoch timestamp
         */

        /**
         * Constructs a new HSMDateTimeUnixEpoch.
         * @memberof Message
         * @classdesc Represents a HSMDateTimeUnixEpoch.
         * @implements IHSMDateTimeUnixEpoch
         * @constructor
         * @param {Message.IHSMDateTimeUnixEpoch=} [properties] Properties to set
         */
        function HSMDateTimeUnixEpoch(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HSMDateTimeUnixEpoch timestamp.
         * @member {number|Long} timestamp
         * @memberof Message.HSMDateTimeUnixEpoch
         * @instance
         */
        HSMDateTimeUnixEpoch.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new HSMDateTimeUnixEpoch instance using the specified properties.
         * @function create
         * @memberof Message.HSMDateTimeUnixEpoch
         * @static
         * @param {Message.IHSMDateTimeUnixEpoch=} [properties] Properties to set
         * @returns {Message.HSMDateTimeUnixEpoch} HSMDateTimeUnixEpoch instance
         */
        HSMDateTimeUnixEpoch.create = function create(properties) {
            return new HSMDateTimeUnixEpoch(properties);
        };

        /**
         * Encodes the specified HSMDateTimeUnixEpoch message. Does not implicitly {@link Message.HSMDateTimeUnixEpoch.verify|verify} messages.
         * @function encode
         * @memberof Message.HSMDateTimeUnixEpoch
         * @static
         * @param {Message.IHSMDateTimeUnixEpoch} message HSMDateTimeUnixEpoch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HSMDateTimeUnixEpoch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified HSMDateTimeUnixEpoch message, length delimited. Does not implicitly {@link Message.HSMDateTimeUnixEpoch.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.HSMDateTimeUnixEpoch
         * @static
         * @param {Message.IHSMDateTimeUnixEpoch} message HSMDateTimeUnixEpoch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HSMDateTimeUnixEpoch.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HSMDateTimeUnixEpoch message from the specified reader or buffer.
         * @function decode
         * @memberof Message.HSMDateTimeUnixEpoch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.HSMDateTimeUnixEpoch} HSMDateTimeUnixEpoch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HSMDateTimeUnixEpoch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.HSMDateTimeUnixEpoch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HSMDateTimeUnixEpoch message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.HSMDateTimeUnixEpoch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.HSMDateTimeUnixEpoch} HSMDateTimeUnixEpoch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HSMDateTimeUnixEpoch.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HSMDateTimeUnixEpoch message.
         * @function verify
         * @memberof Message.HSMDateTimeUnixEpoch
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HSMDateTimeUnixEpoch.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a HSMDateTimeUnixEpoch message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.HSMDateTimeUnixEpoch
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.HSMDateTimeUnixEpoch} HSMDateTimeUnixEpoch
         */
        HSMDateTimeUnixEpoch.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.HSMDateTimeUnixEpoch)
                return object;
            var message = new $root.Message.HSMDateTimeUnixEpoch();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a HSMDateTimeUnixEpoch message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.HSMDateTimeUnixEpoch
         * @static
         * @param {Message.HSMDateTimeUnixEpoch} message HSMDateTimeUnixEpoch
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HSMDateTimeUnixEpoch.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this HSMDateTimeUnixEpoch to JSON.
         * @function toJSON
         * @memberof Message.HSMDateTimeUnixEpoch
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HSMDateTimeUnixEpoch.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HSMDateTimeUnixEpoch;
    })();

    Message.HSMDateTime = (function() {

        /**
         * Properties of a HSMDateTime.
         * @memberof Message
         * @interface IHSMDateTime
         * @property {Message.IHSMDateTimeComponent|null} [component] HSMDateTime component
         * @property {Message.IHSMDateTimeUnixEpoch|null} [unixEpoch] HSMDateTime unixEpoch
         */

        /**
         * Constructs a new HSMDateTime.
         * @memberof Message
         * @classdesc Represents a HSMDateTime.
         * @implements IHSMDateTime
         * @constructor
         * @param {Message.IHSMDateTime=} [properties] Properties to set
         */
        function HSMDateTime(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HSMDateTime component.
         * @member {Message.IHSMDateTimeComponent|null|undefined} component
         * @memberof Message.HSMDateTime
         * @instance
         */
        HSMDateTime.prototype.component = null;

        /**
         * HSMDateTime unixEpoch.
         * @member {Message.IHSMDateTimeUnixEpoch|null|undefined} unixEpoch
         * @memberof Message.HSMDateTime
         * @instance
         */
        HSMDateTime.prototype.unixEpoch = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * HSMDateTime datetimeOneof.
         * @member {"component"|"unixEpoch"|undefined} datetimeOneof
         * @memberof Message.HSMDateTime
         * @instance
         */
        Object.defineProperty(HSMDateTime.prototype, "datetimeOneof", {
            get: $util.oneOfGetter($oneOfFields = ["component", "unixEpoch"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new HSMDateTime instance using the specified properties.
         * @function create
         * @memberof Message.HSMDateTime
         * @static
         * @param {Message.IHSMDateTime=} [properties] Properties to set
         * @returns {Message.HSMDateTime} HSMDateTime instance
         */
        HSMDateTime.create = function create(properties) {
            return new HSMDateTime(properties);
        };

        /**
         * Encodes the specified HSMDateTime message. Does not implicitly {@link Message.HSMDateTime.verify|verify} messages.
         * @function encode
         * @memberof Message.HSMDateTime
         * @static
         * @param {Message.IHSMDateTime} message HSMDateTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HSMDateTime.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.component != null && Object.hasOwnProperty.call(message, "component"))
                $root.Message.HSMDateTimeComponent.encode(message.component, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.unixEpoch != null && Object.hasOwnProperty.call(message, "unixEpoch"))
                $root.Message.HSMDateTimeUnixEpoch.encode(message.unixEpoch, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified HSMDateTime message, length delimited. Does not implicitly {@link Message.HSMDateTime.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.HSMDateTime
         * @static
         * @param {Message.IHSMDateTime} message HSMDateTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HSMDateTime.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HSMDateTime message from the specified reader or buffer.
         * @function decode
         * @memberof Message.HSMDateTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.HSMDateTime} HSMDateTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HSMDateTime.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.HSMDateTime();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.component = $root.Message.HSMDateTimeComponent.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.unixEpoch = $root.Message.HSMDateTimeUnixEpoch.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HSMDateTime message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.HSMDateTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.HSMDateTime} HSMDateTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HSMDateTime.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HSMDateTime message.
         * @function verify
         * @memberof Message.HSMDateTime
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HSMDateTime.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.component != null && message.hasOwnProperty("component")) {
                properties.datetimeOneof = 1;
                {
                    var error = $root.Message.HSMDateTimeComponent.verify(message.component);
                    if (error)
                        return "component." + error;
                }
            }
            if (message.unixEpoch != null && message.hasOwnProperty("unixEpoch")) {
                if (properties.datetimeOneof === 1)
                    return "datetimeOneof: multiple values";
                properties.datetimeOneof = 1;
                {
                    var error = $root.Message.HSMDateTimeUnixEpoch.verify(message.unixEpoch);
                    if (error)
                        return "unixEpoch." + error;
                }
            }
            return null;
        };

        /**
         * Creates a HSMDateTime message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.HSMDateTime
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.HSMDateTime} HSMDateTime
         */
        HSMDateTime.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.HSMDateTime)
                return object;
            var message = new $root.Message.HSMDateTime();
            if (object.component != null) {
                if (typeof object.component !== "object")
                    throw TypeError(".Message.HSMDateTime.component: object expected");
                message.component = $root.Message.HSMDateTimeComponent.fromObject(object.component);
            }
            if (object.unixEpoch != null) {
                if (typeof object.unixEpoch !== "object")
                    throw TypeError(".Message.HSMDateTime.unixEpoch: object expected");
                message.unixEpoch = $root.Message.HSMDateTimeUnixEpoch.fromObject(object.unixEpoch);
            }
            return message;
        };

        /**
         * Creates a plain object from a HSMDateTime message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.HSMDateTime
         * @static
         * @param {Message.HSMDateTime} message HSMDateTime
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HSMDateTime.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.component != null && message.hasOwnProperty("component")) {
                object.component = $root.Message.HSMDateTimeComponent.toObject(message.component, options);
                if (options.oneofs)
                    object.datetimeOneof = "component";
            }
            if (message.unixEpoch != null && message.hasOwnProperty("unixEpoch")) {
                object.unixEpoch = $root.Message.HSMDateTimeUnixEpoch.toObject(message.unixEpoch, options);
                if (options.oneofs)
                    object.datetimeOneof = "unixEpoch";
            }
            return object;
        };

        /**
         * Converts this HSMDateTime to JSON.
         * @function toJSON
         * @memberof Message.HSMDateTime
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HSMDateTime.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HSMDateTime;
    })();

    Message.HSMLocalizableParameter = (function() {

        /**
         * Properties of a HSMLocalizableParameter.
         * @memberof Message
         * @interface IHSMLocalizableParameter
         * @property {string|null} ["default"] HSMLocalizableParameter default
         * @property {Message.IHSMCurrency|null} [currency] HSMLocalizableParameter currency
         * @property {Message.IHSMDateTime|null} [dateTime] HSMLocalizableParameter dateTime
         */

        /**
         * Constructs a new HSMLocalizableParameter.
         * @memberof Message
         * @classdesc Represents a HSMLocalizableParameter.
         * @implements IHSMLocalizableParameter
         * @constructor
         * @param {Message.IHSMLocalizableParameter=} [properties] Properties to set
         */
        function HSMLocalizableParameter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HSMLocalizableParameter default.
         * @member {string} default
         * @memberof Message.HSMLocalizableParameter
         * @instance
         */
        HSMLocalizableParameter.prototype["default"] = "";

        /**
         * HSMLocalizableParameter currency.
         * @member {Message.IHSMCurrency|null|undefined} currency
         * @memberof Message.HSMLocalizableParameter
         * @instance
         */
        HSMLocalizableParameter.prototype.currency = null;

        /**
         * HSMLocalizableParameter dateTime.
         * @member {Message.IHSMDateTime|null|undefined} dateTime
         * @memberof Message.HSMLocalizableParameter
         * @instance
         */
        HSMLocalizableParameter.prototype.dateTime = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * HSMLocalizableParameter paramOneof.
         * @member {"currency"|"dateTime"|undefined} paramOneof
         * @memberof Message.HSMLocalizableParameter
         * @instance
         */
        Object.defineProperty(HSMLocalizableParameter.prototype, "paramOneof", {
            get: $util.oneOfGetter($oneOfFields = ["currency", "dateTime"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new HSMLocalizableParameter instance using the specified properties.
         * @function create
         * @memberof Message.HSMLocalizableParameter
         * @static
         * @param {Message.IHSMLocalizableParameter=} [properties] Properties to set
         * @returns {Message.HSMLocalizableParameter} HSMLocalizableParameter instance
         */
        HSMLocalizableParameter.create = function create(properties) {
            return new HSMLocalizableParameter(properties);
        };

        /**
         * Encodes the specified HSMLocalizableParameter message. Does not implicitly {@link Message.HSMLocalizableParameter.verify|verify} messages.
         * @function encode
         * @memberof Message.HSMLocalizableParameter
         * @static
         * @param {Message.IHSMLocalizableParameter} message HSMLocalizableParameter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HSMLocalizableParameter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message["default"] != null && Object.hasOwnProperty.call(message, "default"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message["default"]);
            if (message.currency != null && Object.hasOwnProperty.call(message, "currency"))
                $root.Message.HSMCurrency.encode(message.currency, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.dateTime != null && Object.hasOwnProperty.call(message, "dateTime"))
                $root.Message.HSMDateTime.encode(message.dateTime, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified HSMLocalizableParameter message, length delimited. Does not implicitly {@link Message.HSMLocalizableParameter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.HSMLocalizableParameter
         * @static
         * @param {Message.IHSMLocalizableParameter} message HSMLocalizableParameter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HSMLocalizableParameter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HSMLocalizableParameter message from the specified reader or buffer.
         * @function decode
         * @memberof Message.HSMLocalizableParameter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.HSMLocalizableParameter} HSMLocalizableParameter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HSMLocalizableParameter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.HSMLocalizableParameter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message["default"] = reader.string();
                    break;
                case 2:
                    message.currency = $root.Message.HSMCurrency.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.dateTime = $root.Message.HSMDateTime.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HSMLocalizableParameter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.HSMLocalizableParameter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.HSMLocalizableParameter} HSMLocalizableParameter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HSMLocalizableParameter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HSMLocalizableParameter message.
         * @function verify
         * @memberof Message.HSMLocalizableParameter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HSMLocalizableParameter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message["default"] != null && message.hasOwnProperty("default"))
                if (!$util.isString(message["default"]))
                    return "default: string expected";
            if (message.currency != null && message.hasOwnProperty("currency")) {
                properties.paramOneof = 1;
                {
                    var error = $root.Message.HSMCurrency.verify(message.currency);
                    if (error)
                        return "currency." + error;
                }
            }
            if (message.dateTime != null && message.hasOwnProperty("dateTime")) {
                if (properties.paramOneof === 1)
                    return "paramOneof: multiple values";
                properties.paramOneof = 1;
                {
                    var error = $root.Message.HSMDateTime.verify(message.dateTime);
                    if (error)
                        return "dateTime." + error;
                }
            }
            return null;
        };

        /**
         * Creates a HSMLocalizableParameter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.HSMLocalizableParameter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.HSMLocalizableParameter} HSMLocalizableParameter
         */
        HSMLocalizableParameter.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.HSMLocalizableParameter)
                return object;
            var message = new $root.Message.HSMLocalizableParameter();
            if (object["default"] != null)
                message["default"] = String(object["default"]);
            if (object.currency != null) {
                if (typeof object.currency !== "object")
                    throw TypeError(".Message.HSMLocalizableParameter.currency: object expected");
                message.currency = $root.Message.HSMCurrency.fromObject(object.currency);
            }
            if (object.dateTime != null) {
                if (typeof object.dateTime !== "object")
                    throw TypeError(".Message.HSMLocalizableParameter.dateTime: object expected");
                message.dateTime = $root.Message.HSMDateTime.fromObject(object.dateTime);
            }
            return message;
        };

        /**
         * Creates a plain object from a HSMLocalizableParameter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.HSMLocalizableParameter
         * @static
         * @param {Message.HSMLocalizableParameter} message HSMLocalizableParameter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HSMLocalizableParameter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object["default"] = "";
            if (message["default"] != null && message.hasOwnProperty("default"))
                object["default"] = message["default"];
            if (message.currency != null && message.hasOwnProperty("currency")) {
                object.currency = $root.Message.HSMCurrency.toObject(message.currency, options);
                if (options.oneofs)
                    object.paramOneof = "currency";
            }
            if (message.dateTime != null && message.hasOwnProperty("dateTime")) {
                object.dateTime = $root.Message.HSMDateTime.toObject(message.dateTime, options);
                if (options.oneofs)
                    object.paramOneof = "dateTime";
            }
            return object;
        };

        /**
         * Converts this HSMLocalizableParameter to JSON.
         * @function toJSON
         * @memberof Message.HSMLocalizableParameter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HSMLocalizableParameter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HSMLocalizableParameter;
    })();

    Message.HighlyStructuredMessage = (function() {

        /**
         * Properties of a HighlyStructuredMessage.
         * @memberof Message
         * @interface IHighlyStructuredMessage
         * @property {string|null} [namespace] HighlyStructuredMessage namespace
         * @property {string|null} [elementName] HighlyStructuredMessage elementName
         * @property {Array.<string>|null} [params] HighlyStructuredMessage params
         * @property {string|null} [fallbackLg] HighlyStructuredMessage fallbackLg
         * @property {string|null} [fallbackLc] HighlyStructuredMessage fallbackLc
         * @property {Array.<Message.IHSMLocalizableParameter>|null} [localizableParams] HighlyStructuredMessage localizableParams
         * @property {string|null} [deterministicLg] HighlyStructuredMessage deterministicLg
         * @property {string|null} [deterministicLc] HighlyStructuredMessage deterministicLc
         * @property {Message.ITemplateMessage|null} [hydratedHsm] HighlyStructuredMessage hydratedHsm
         */

        /**
         * Constructs a new HighlyStructuredMessage.
         * @memberof Message
         * @classdesc Represents a HighlyStructuredMessage.
         * @implements IHighlyStructuredMessage
         * @constructor
         * @param {Message.IHighlyStructuredMessage=} [properties] Properties to set
         */
        function HighlyStructuredMessage(properties) {
            this.params = [];
            this.localizableParams = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HighlyStructuredMessage namespace.
         * @member {string} namespace
         * @memberof Message.HighlyStructuredMessage
         * @instance
         */
        HighlyStructuredMessage.prototype.namespace = "";

        /**
         * HighlyStructuredMessage elementName.
         * @member {string} elementName
         * @memberof Message.HighlyStructuredMessage
         * @instance
         */
        HighlyStructuredMessage.prototype.elementName = "";

        /**
         * HighlyStructuredMessage params.
         * @member {Array.<string>} params
         * @memberof Message.HighlyStructuredMessage
         * @instance
         */
        HighlyStructuredMessage.prototype.params = $util.emptyArray;

        /**
         * HighlyStructuredMessage fallbackLg.
         * @member {string} fallbackLg
         * @memberof Message.HighlyStructuredMessage
         * @instance
         */
        HighlyStructuredMessage.prototype.fallbackLg = "";

        /**
         * HighlyStructuredMessage fallbackLc.
         * @member {string} fallbackLc
         * @memberof Message.HighlyStructuredMessage
         * @instance
         */
        HighlyStructuredMessage.prototype.fallbackLc = "";

        /**
         * HighlyStructuredMessage localizableParams.
         * @member {Array.<Message.IHSMLocalizableParameter>} localizableParams
         * @memberof Message.HighlyStructuredMessage
         * @instance
         */
        HighlyStructuredMessage.prototype.localizableParams = $util.emptyArray;

        /**
         * HighlyStructuredMessage deterministicLg.
         * @member {string} deterministicLg
         * @memberof Message.HighlyStructuredMessage
         * @instance
         */
        HighlyStructuredMessage.prototype.deterministicLg = "";

        /**
         * HighlyStructuredMessage deterministicLc.
         * @member {string} deterministicLc
         * @memberof Message.HighlyStructuredMessage
         * @instance
         */
        HighlyStructuredMessage.prototype.deterministicLc = "";

        /**
         * HighlyStructuredMessage hydratedHsm.
         * @member {Message.ITemplateMessage|null|undefined} hydratedHsm
         * @memberof Message.HighlyStructuredMessage
         * @instance
         */
        HighlyStructuredMessage.prototype.hydratedHsm = null;

        /**
         * Creates a new HighlyStructuredMessage instance using the specified properties.
         * @function create
         * @memberof Message.HighlyStructuredMessage
         * @static
         * @param {Message.IHighlyStructuredMessage=} [properties] Properties to set
         * @returns {Message.HighlyStructuredMessage} HighlyStructuredMessage instance
         */
        HighlyStructuredMessage.create = function create(properties) {
            return new HighlyStructuredMessage(properties);
        };

        /**
         * Encodes the specified HighlyStructuredMessage message. Does not implicitly {@link Message.HighlyStructuredMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.HighlyStructuredMessage
         * @static
         * @param {Message.IHighlyStructuredMessage} message HighlyStructuredMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HighlyStructuredMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.namespace != null && Object.hasOwnProperty.call(message, "namespace"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.namespace);
            if (message.elementName != null && Object.hasOwnProperty.call(message, "elementName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.elementName);
            if (message.params != null && message.params.length)
                for (var i = 0; i < message.params.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.params[i]);
            if (message.fallbackLg != null && Object.hasOwnProperty.call(message, "fallbackLg"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.fallbackLg);
            if (message.fallbackLc != null && Object.hasOwnProperty.call(message, "fallbackLc"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.fallbackLc);
            if (message.localizableParams != null && message.localizableParams.length)
                for (var i = 0; i < message.localizableParams.length; ++i)
                    $root.Message.HSMLocalizableParameter.encode(message.localizableParams[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.deterministicLg != null && Object.hasOwnProperty.call(message, "deterministicLg"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.deterministicLg);
            if (message.deterministicLc != null && Object.hasOwnProperty.call(message, "deterministicLc"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.deterministicLc);
            if (message.hydratedHsm != null && Object.hasOwnProperty.call(message, "hydratedHsm"))
                $root.Message.TemplateMessage.encode(message.hydratedHsm, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified HighlyStructuredMessage message, length delimited. Does not implicitly {@link Message.HighlyStructuredMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.HighlyStructuredMessage
         * @static
         * @param {Message.IHighlyStructuredMessage} message HighlyStructuredMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HighlyStructuredMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HighlyStructuredMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.HighlyStructuredMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.HighlyStructuredMessage} HighlyStructuredMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HighlyStructuredMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.HighlyStructuredMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.namespace = reader.string();
                    break;
                case 2:
                    message.elementName = reader.string();
                    break;
                case 3:
                    if (!(message.params && message.params.length))
                        message.params = [];
                    message.params.push(reader.string());
                    break;
                case 4:
                    message.fallbackLg = reader.string();
                    break;
                case 5:
                    message.fallbackLc = reader.string();
                    break;
                case 6:
                    if (!(message.localizableParams && message.localizableParams.length))
                        message.localizableParams = [];
                    message.localizableParams.push($root.Message.HSMLocalizableParameter.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.deterministicLg = reader.string();
                    break;
                case 8:
                    message.deterministicLc = reader.string();
                    break;
                case 9:
                    message.hydratedHsm = $root.Message.TemplateMessage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HighlyStructuredMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.HighlyStructuredMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.HighlyStructuredMessage} HighlyStructuredMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HighlyStructuredMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HighlyStructuredMessage message.
         * @function verify
         * @memberof Message.HighlyStructuredMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HighlyStructuredMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.namespace != null && message.hasOwnProperty("namespace"))
                if (!$util.isString(message.namespace))
                    return "namespace: string expected";
            if (message.elementName != null && message.hasOwnProperty("elementName"))
                if (!$util.isString(message.elementName))
                    return "elementName: string expected";
            if (message.params != null && message.hasOwnProperty("params")) {
                if (!Array.isArray(message.params))
                    return "params: array expected";
                for (var i = 0; i < message.params.length; ++i)
                    if (!$util.isString(message.params[i]))
                        return "params: string[] expected";
            }
            if (message.fallbackLg != null && message.hasOwnProperty("fallbackLg"))
                if (!$util.isString(message.fallbackLg))
                    return "fallbackLg: string expected";
            if (message.fallbackLc != null && message.hasOwnProperty("fallbackLc"))
                if (!$util.isString(message.fallbackLc))
                    return "fallbackLc: string expected";
            if (message.localizableParams != null && message.hasOwnProperty("localizableParams")) {
                if (!Array.isArray(message.localizableParams))
                    return "localizableParams: array expected";
                for (var i = 0; i < message.localizableParams.length; ++i) {
                    var error = $root.Message.HSMLocalizableParameter.verify(message.localizableParams[i]);
                    if (error)
                        return "localizableParams." + error;
                }
            }
            if (message.deterministicLg != null && message.hasOwnProperty("deterministicLg"))
                if (!$util.isString(message.deterministicLg))
                    return "deterministicLg: string expected";
            if (message.deterministicLc != null && message.hasOwnProperty("deterministicLc"))
                if (!$util.isString(message.deterministicLc))
                    return "deterministicLc: string expected";
            if (message.hydratedHsm != null && message.hasOwnProperty("hydratedHsm")) {
                var error = $root.Message.TemplateMessage.verify(message.hydratedHsm);
                if (error)
                    return "hydratedHsm." + error;
            }
            return null;
        };

        /**
         * Creates a HighlyStructuredMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.HighlyStructuredMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.HighlyStructuredMessage} HighlyStructuredMessage
         */
        HighlyStructuredMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.HighlyStructuredMessage)
                return object;
            var message = new $root.Message.HighlyStructuredMessage();
            if (object.namespace != null)
                message.namespace = String(object.namespace);
            if (object.elementName != null)
                message.elementName = String(object.elementName);
            if (object.params) {
                if (!Array.isArray(object.params))
                    throw TypeError(".Message.HighlyStructuredMessage.params: array expected");
                message.params = [];
                for (var i = 0; i < object.params.length; ++i)
                    message.params[i] = String(object.params[i]);
            }
            if (object.fallbackLg != null)
                message.fallbackLg = String(object.fallbackLg);
            if (object.fallbackLc != null)
                message.fallbackLc = String(object.fallbackLc);
            if (object.localizableParams) {
                if (!Array.isArray(object.localizableParams))
                    throw TypeError(".Message.HighlyStructuredMessage.localizableParams: array expected");
                message.localizableParams = [];
                for (var i = 0; i < object.localizableParams.length; ++i) {
                    if (typeof object.localizableParams[i] !== "object")
                        throw TypeError(".Message.HighlyStructuredMessage.localizableParams: object expected");
                    message.localizableParams[i] = $root.Message.HSMLocalizableParameter.fromObject(object.localizableParams[i]);
                }
            }
            if (object.deterministicLg != null)
                message.deterministicLg = String(object.deterministicLg);
            if (object.deterministicLc != null)
                message.deterministicLc = String(object.deterministicLc);
            if (object.hydratedHsm != null) {
                if (typeof object.hydratedHsm !== "object")
                    throw TypeError(".Message.HighlyStructuredMessage.hydratedHsm: object expected");
                message.hydratedHsm = $root.Message.TemplateMessage.fromObject(object.hydratedHsm);
            }
            return message;
        };

        /**
         * Creates a plain object from a HighlyStructuredMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.HighlyStructuredMessage
         * @static
         * @param {Message.HighlyStructuredMessage} message HighlyStructuredMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HighlyStructuredMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.params = [];
                object.localizableParams = [];
            }
            if (options.defaults) {
                object.namespace = "";
                object.elementName = "";
                object.fallbackLg = "";
                object.fallbackLc = "";
                object.deterministicLg = "";
                object.deterministicLc = "";
                object.hydratedHsm = null;
            }
            if (message.namespace != null && message.hasOwnProperty("namespace"))
                object.namespace = message.namespace;
            if (message.elementName != null && message.hasOwnProperty("elementName"))
                object.elementName = message.elementName;
            if (message.params && message.params.length) {
                object.params = [];
                for (var j = 0; j < message.params.length; ++j)
                    object.params[j] = message.params[j];
            }
            if (message.fallbackLg != null && message.hasOwnProperty("fallbackLg"))
                object.fallbackLg = message.fallbackLg;
            if (message.fallbackLc != null && message.hasOwnProperty("fallbackLc"))
                object.fallbackLc = message.fallbackLc;
            if (message.localizableParams && message.localizableParams.length) {
                object.localizableParams = [];
                for (var j = 0; j < message.localizableParams.length; ++j)
                    object.localizableParams[j] = $root.Message.HSMLocalizableParameter.toObject(message.localizableParams[j], options);
            }
            if (message.deterministicLg != null && message.hasOwnProperty("deterministicLg"))
                object.deterministicLg = message.deterministicLg;
            if (message.deterministicLc != null && message.hasOwnProperty("deterministicLc"))
                object.deterministicLc = message.deterministicLc;
            if (message.hydratedHsm != null && message.hasOwnProperty("hydratedHsm"))
                object.hydratedHsm = $root.Message.TemplateMessage.toObject(message.hydratedHsm, options);
            return object;
        };

        /**
         * Converts this HighlyStructuredMessage to JSON.
         * @function toJSON
         * @memberof Message.HighlyStructuredMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HighlyStructuredMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HighlyStructuredMessage;
    })();

    Message.SendPaymentMessage = (function() {

        /**
         * Properties of a SendPaymentMessage.
         * @memberof Message
         * @interface ISendPaymentMessage
         * @property {Message.IMessage|null} [noteMessage] SendPaymentMessage noteMessage
         * @property {Message.IMessageKey|null} [requestMessageKey] SendPaymentMessage requestMessageKey
         */

        /**
         * Constructs a new SendPaymentMessage.
         * @memberof Message
         * @classdesc Represents a SendPaymentMessage.
         * @implements ISendPaymentMessage
         * @constructor
         * @param {Message.ISendPaymentMessage=} [properties] Properties to set
         */
        function SendPaymentMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendPaymentMessage noteMessage.
         * @member {Message.IMessage|null|undefined} noteMessage
         * @memberof Message.SendPaymentMessage
         * @instance
         */
        SendPaymentMessage.prototype.noteMessage = null;

        /**
         * SendPaymentMessage requestMessageKey.
         * @member {Message.IMessageKey|null|undefined} requestMessageKey
         * @memberof Message.SendPaymentMessage
         * @instance
         */
        SendPaymentMessage.prototype.requestMessageKey = null;

        /**
         * Creates a new SendPaymentMessage instance using the specified properties.
         * @function create
         * @memberof Message.SendPaymentMessage
         * @static
         * @param {Message.ISendPaymentMessage=} [properties] Properties to set
         * @returns {Message.SendPaymentMessage} SendPaymentMessage instance
         */
        SendPaymentMessage.create = function create(properties) {
            return new SendPaymentMessage(properties);
        };

        /**
         * Encodes the specified SendPaymentMessage message. Does not implicitly {@link Message.SendPaymentMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.SendPaymentMessage
         * @static
         * @param {Message.ISendPaymentMessage} message SendPaymentMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendPaymentMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.noteMessage != null && Object.hasOwnProperty.call(message, "noteMessage"))
                $root.Message.Message.encode(message.noteMessage, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.requestMessageKey != null && Object.hasOwnProperty.call(message, "requestMessageKey"))
                $root.Message.MessageKey.encode(message.requestMessageKey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SendPaymentMessage message, length delimited. Does not implicitly {@link Message.SendPaymentMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.SendPaymentMessage
         * @static
         * @param {Message.ISendPaymentMessage} message SendPaymentMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendPaymentMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendPaymentMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.SendPaymentMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.SendPaymentMessage} SendPaymentMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendPaymentMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.SendPaymentMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.noteMessage = $root.Message.Message.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.requestMessageKey = $root.Message.MessageKey.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendPaymentMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.SendPaymentMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.SendPaymentMessage} SendPaymentMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendPaymentMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendPaymentMessage message.
         * @function verify
         * @memberof Message.SendPaymentMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendPaymentMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.noteMessage != null && message.hasOwnProperty("noteMessage")) {
                var error = $root.Message.Message.verify(message.noteMessage);
                if (error)
                    return "noteMessage." + error;
            }
            if (message.requestMessageKey != null && message.hasOwnProperty("requestMessageKey")) {
                var error = $root.Message.MessageKey.verify(message.requestMessageKey);
                if (error)
                    return "requestMessageKey." + error;
            }
            return null;
        };

        /**
         * Creates a SendPaymentMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.SendPaymentMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.SendPaymentMessage} SendPaymentMessage
         */
        SendPaymentMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.SendPaymentMessage)
                return object;
            var message = new $root.Message.SendPaymentMessage();
            if (object.noteMessage != null) {
                if (typeof object.noteMessage !== "object")
                    throw TypeError(".Message.SendPaymentMessage.noteMessage: object expected");
                message.noteMessage = $root.Message.Message.fromObject(object.noteMessage);
            }
            if (object.requestMessageKey != null) {
                if (typeof object.requestMessageKey !== "object")
                    throw TypeError(".Message.SendPaymentMessage.requestMessageKey: object expected");
                message.requestMessageKey = $root.Message.MessageKey.fromObject(object.requestMessageKey);
            }
            return message;
        };

        /**
         * Creates a plain object from a SendPaymentMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.SendPaymentMessage
         * @static
         * @param {Message.SendPaymentMessage} message SendPaymentMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendPaymentMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.noteMessage = null;
                object.requestMessageKey = null;
            }
            if (message.noteMessage != null && message.hasOwnProperty("noteMessage"))
                object.noteMessage = $root.Message.Message.toObject(message.noteMessage, options);
            if (message.requestMessageKey != null && message.hasOwnProperty("requestMessageKey"))
                object.requestMessageKey = $root.Message.MessageKey.toObject(message.requestMessageKey, options);
            return object;
        };

        /**
         * Converts this SendPaymentMessage to JSON.
         * @function toJSON
         * @memberof Message.SendPaymentMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendPaymentMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendPaymentMessage;
    })();

    Message.RequestPaymentMessage = (function() {

        /**
         * Properties of a RequestPaymentMessage.
         * @memberof Message
         * @interface IRequestPaymentMessage
         * @property {Message.IMessage|null} [noteMessage] RequestPaymentMessage noteMessage
         * @property {string|null} [currencyCodeIso4217] RequestPaymentMessage currencyCodeIso4217
         * @property {number|Long|null} [amount1000] RequestPaymentMessage amount1000
         * @property {string|null} [requestFrom] RequestPaymentMessage requestFrom
         * @property {number|Long|null} [expiryTimestamp] RequestPaymentMessage expiryTimestamp
         */

        /**
         * Constructs a new RequestPaymentMessage.
         * @memberof Message
         * @classdesc Represents a RequestPaymentMessage.
         * @implements IRequestPaymentMessage
         * @constructor
         * @param {Message.IRequestPaymentMessage=} [properties] Properties to set
         */
        function RequestPaymentMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RequestPaymentMessage noteMessage.
         * @member {Message.IMessage|null|undefined} noteMessage
         * @memberof Message.RequestPaymentMessage
         * @instance
         */
        RequestPaymentMessage.prototype.noteMessage = null;

        /**
         * RequestPaymentMessage currencyCodeIso4217.
         * @member {string} currencyCodeIso4217
         * @memberof Message.RequestPaymentMessage
         * @instance
         */
        RequestPaymentMessage.prototype.currencyCodeIso4217 = "";

        /**
         * RequestPaymentMessage amount1000.
         * @member {number|Long} amount1000
         * @memberof Message.RequestPaymentMessage
         * @instance
         */
        RequestPaymentMessage.prototype.amount1000 = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * RequestPaymentMessage requestFrom.
         * @member {string} requestFrom
         * @memberof Message.RequestPaymentMessage
         * @instance
         */
        RequestPaymentMessage.prototype.requestFrom = "";

        /**
         * RequestPaymentMessage expiryTimestamp.
         * @member {number|Long} expiryTimestamp
         * @memberof Message.RequestPaymentMessage
         * @instance
         */
        RequestPaymentMessage.prototype.expiryTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new RequestPaymentMessage instance using the specified properties.
         * @function create
         * @memberof Message.RequestPaymentMessage
         * @static
         * @param {Message.IRequestPaymentMessage=} [properties] Properties to set
         * @returns {Message.RequestPaymentMessage} RequestPaymentMessage instance
         */
        RequestPaymentMessage.create = function create(properties) {
            return new RequestPaymentMessage(properties);
        };

        /**
         * Encodes the specified RequestPaymentMessage message. Does not implicitly {@link Message.RequestPaymentMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.RequestPaymentMessage
         * @static
         * @param {Message.IRequestPaymentMessage} message RequestPaymentMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestPaymentMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currencyCodeIso4217 != null && Object.hasOwnProperty.call(message, "currencyCodeIso4217"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.currencyCodeIso4217);
            if (message.amount1000 != null && Object.hasOwnProperty.call(message, "amount1000"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.amount1000);
            if (message.requestFrom != null && Object.hasOwnProperty.call(message, "requestFrom"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.requestFrom);
            if (message.noteMessage != null && Object.hasOwnProperty.call(message, "noteMessage"))
                $root.Message.Message.encode(message.noteMessage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.expiryTimestamp != null && Object.hasOwnProperty.call(message, "expiryTimestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.expiryTimestamp);
            return writer;
        };

        /**
         * Encodes the specified RequestPaymentMessage message, length delimited. Does not implicitly {@link Message.RequestPaymentMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.RequestPaymentMessage
         * @static
         * @param {Message.IRequestPaymentMessage} message RequestPaymentMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RequestPaymentMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RequestPaymentMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.RequestPaymentMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.RequestPaymentMessage} RequestPaymentMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestPaymentMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.RequestPaymentMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 4:
                    message.noteMessage = $root.Message.Message.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.currencyCodeIso4217 = reader.string();
                    break;
                case 2:
                    message.amount1000 = reader.uint64();
                    break;
                case 3:
                    message.requestFrom = reader.string();
                    break;
                case 5:
                    message.expiryTimestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RequestPaymentMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.RequestPaymentMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.RequestPaymentMessage} RequestPaymentMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestPaymentMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RequestPaymentMessage message.
         * @function verify
         * @memberof Message.RequestPaymentMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RequestPaymentMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.noteMessage != null && message.hasOwnProperty("noteMessage")) {
                var error = $root.Message.Message.verify(message.noteMessage);
                if (error)
                    return "noteMessage." + error;
            }
            if (message.currencyCodeIso4217 != null && message.hasOwnProperty("currencyCodeIso4217"))
                if (!$util.isString(message.currencyCodeIso4217))
                    return "currencyCodeIso4217: string expected";
            if (message.amount1000 != null && message.hasOwnProperty("amount1000"))
                if (!$util.isInteger(message.amount1000) && !(message.amount1000 && $util.isInteger(message.amount1000.low) && $util.isInteger(message.amount1000.high)))
                    return "amount1000: integer|Long expected";
            if (message.requestFrom != null && message.hasOwnProperty("requestFrom"))
                if (!$util.isString(message.requestFrom))
                    return "requestFrom: string expected";
            if (message.expiryTimestamp != null && message.hasOwnProperty("expiryTimestamp"))
                if (!$util.isInteger(message.expiryTimestamp) && !(message.expiryTimestamp && $util.isInteger(message.expiryTimestamp.low) && $util.isInteger(message.expiryTimestamp.high)))
                    return "expiryTimestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a RequestPaymentMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.RequestPaymentMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.RequestPaymentMessage} RequestPaymentMessage
         */
        RequestPaymentMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.RequestPaymentMessage)
                return object;
            var message = new $root.Message.RequestPaymentMessage();
            if (object.noteMessage != null) {
                if (typeof object.noteMessage !== "object")
                    throw TypeError(".Message.RequestPaymentMessage.noteMessage: object expected");
                message.noteMessage = $root.Message.Message.fromObject(object.noteMessage);
            }
            if (object.currencyCodeIso4217 != null)
                message.currencyCodeIso4217 = String(object.currencyCodeIso4217);
            if (object.amount1000 != null)
                if ($util.Long)
                    (message.amount1000 = $util.Long.fromValue(object.amount1000)).unsigned = true;
                else if (typeof object.amount1000 === "string")
                    message.amount1000 = parseInt(object.amount1000, 10);
                else if (typeof object.amount1000 === "number")
                    message.amount1000 = object.amount1000;
                else if (typeof object.amount1000 === "object")
                    message.amount1000 = new $util.LongBits(object.amount1000.low >>> 0, object.amount1000.high >>> 0).toNumber(true);
            if (object.requestFrom != null)
                message.requestFrom = String(object.requestFrom);
            if (object.expiryTimestamp != null)
                if ($util.Long)
                    (message.expiryTimestamp = $util.Long.fromValue(object.expiryTimestamp)).unsigned = false;
                else if (typeof object.expiryTimestamp === "string")
                    message.expiryTimestamp = parseInt(object.expiryTimestamp, 10);
                else if (typeof object.expiryTimestamp === "number")
                    message.expiryTimestamp = object.expiryTimestamp;
                else if (typeof object.expiryTimestamp === "object")
                    message.expiryTimestamp = new $util.LongBits(object.expiryTimestamp.low >>> 0, object.expiryTimestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a RequestPaymentMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.RequestPaymentMessage
         * @static
         * @param {Message.RequestPaymentMessage} message RequestPaymentMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RequestPaymentMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.currencyCodeIso4217 = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.amount1000 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount1000 = options.longs === String ? "0" : 0;
                object.requestFrom = "";
                object.noteMessage = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expiryTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiryTimestamp = options.longs === String ? "0" : 0;
            }
            if (message.currencyCodeIso4217 != null && message.hasOwnProperty("currencyCodeIso4217"))
                object.currencyCodeIso4217 = message.currencyCodeIso4217;
            if (message.amount1000 != null && message.hasOwnProperty("amount1000"))
                if (typeof message.amount1000 === "number")
                    object.amount1000 = options.longs === String ? String(message.amount1000) : message.amount1000;
                else
                    object.amount1000 = options.longs === String ? $util.Long.prototype.toString.call(message.amount1000) : options.longs === Number ? new $util.LongBits(message.amount1000.low >>> 0, message.amount1000.high >>> 0).toNumber(true) : message.amount1000;
            if (message.requestFrom != null && message.hasOwnProperty("requestFrom"))
                object.requestFrom = message.requestFrom;
            if (message.noteMessage != null && message.hasOwnProperty("noteMessage"))
                object.noteMessage = $root.Message.Message.toObject(message.noteMessage, options);
            if (message.expiryTimestamp != null && message.hasOwnProperty("expiryTimestamp"))
                if (typeof message.expiryTimestamp === "number")
                    object.expiryTimestamp = options.longs === String ? String(message.expiryTimestamp) : message.expiryTimestamp;
                else
                    object.expiryTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.expiryTimestamp) : options.longs === Number ? new $util.LongBits(message.expiryTimestamp.low >>> 0, message.expiryTimestamp.high >>> 0).toNumber() : message.expiryTimestamp;
            return object;
        };

        /**
         * Converts this RequestPaymentMessage to JSON.
         * @function toJSON
         * @memberof Message.RequestPaymentMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RequestPaymentMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RequestPaymentMessage;
    })();

    Message.DeclinePaymentRequestMessage = (function() {

        /**
         * Properties of a DeclinePaymentRequestMessage.
         * @memberof Message
         * @interface IDeclinePaymentRequestMessage
         * @property {Message.IMessageKey|null} [key] DeclinePaymentRequestMessage key
         */

        /**
         * Constructs a new DeclinePaymentRequestMessage.
         * @memberof Message
         * @classdesc Represents a DeclinePaymentRequestMessage.
         * @implements IDeclinePaymentRequestMessage
         * @constructor
         * @param {Message.IDeclinePaymentRequestMessage=} [properties] Properties to set
         */
        function DeclinePaymentRequestMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeclinePaymentRequestMessage key.
         * @member {Message.IMessageKey|null|undefined} key
         * @memberof Message.DeclinePaymentRequestMessage
         * @instance
         */
        DeclinePaymentRequestMessage.prototype.key = null;

        /**
         * Creates a new DeclinePaymentRequestMessage instance using the specified properties.
         * @function create
         * @memberof Message.DeclinePaymentRequestMessage
         * @static
         * @param {Message.IDeclinePaymentRequestMessage=} [properties] Properties to set
         * @returns {Message.DeclinePaymentRequestMessage} DeclinePaymentRequestMessage instance
         */
        DeclinePaymentRequestMessage.create = function create(properties) {
            return new DeclinePaymentRequestMessage(properties);
        };

        /**
         * Encodes the specified DeclinePaymentRequestMessage message. Does not implicitly {@link Message.DeclinePaymentRequestMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.DeclinePaymentRequestMessage
         * @static
         * @param {Message.IDeclinePaymentRequestMessage} message DeclinePaymentRequestMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeclinePaymentRequestMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                $root.Message.MessageKey.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DeclinePaymentRequestMessage message, length delimited. Does not implicitly {@link Message.DeclinePaymentRequestMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.DeclinePaymentRequestMessage
         * @static
         * @param {Message.IDeclinePaymentRequestMessage} message DeclinePaymentRequestMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeclinePaymentRequestMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeclinePaymentRequestMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.DeclinePaymentRequestMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.DeclinePaymentRequestMessage} DeclinePaymentRequestMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeclinePaymentRequestMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.DeclinePaymentRequestMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = $root.Message.MessageKey.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeclinePaymentRequestMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.DeclinePaymentRequestMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.DeclinePaymentRequestMessage} DeclinePaymentRequestMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeclinePaymentRequestMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeclinePaymentRequestMessage message.
         * @function verify
         * @memberof Message.DeclinePaymentRequestMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeclinePaymentRequestMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key")) {
                var error = $root.Message.MessageKey.verify(message.key);
                if (error)
                    return "key." + error;
            }
            return null;
        };

        /**
         * Creates a DeclinePaymentRequestMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.DeclinePaymentRequestMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.DeclinePaymentRequestMessage} DeclinePaymentRequestMessage
         */
        DeclinePaymentRequestMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.DeclinePaymentRequestMessage)
                return object;
            var message = new $root.Message.DeclinePaymentRequestMessage();
            if (object.key != null) {
                if (typeof object.key !== "object")
                    throw TypeError(".Message.DeclinePaymentRequestMessage.key: object expected");
                message.key = $root.Message.MessageKey.fromObject(object.key);
            }
            return message;
        };

        /**
         * Creates a plain object from a DeclinePaymentRequestMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.DeclinePaymentRequestMessage
         * @static
         * @param {Message.DeclinePaymentRequestMessage} message DeclinePaymentRequestMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeclinePaymentRequestMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.key = null;
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = $root.Message.MessageKey.toObject(message.key, options);
            return object;
        };

        /**
         * Converts this DeclinePaymentRequestMessage to JSON.
         * @function toJSON
         * @memberof Message.DeclinePaymentRequestMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeclinePaymentRequestMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeclinePaymentRequestMessage;
    })();

    Message.CancelPaymentRequestMessage = (function() {

        /**
         * Properties of a CancelPaymentRequestMessage.
         * @memberof Message
         * @interface ICancelPaymentRequestMessage
         * @property {Message.IMessageKey|null} [key] CancelPaymentRequestMessage key
         */

        /**
         * Constructs a new CancelPaymentRequestMessage.
         * @memberof Message
         * @classdesc Represents a CancelPaymentRequestMessage.
         * @implements ICancelPaymentRequestMessage
         * @constructor
         * @param {Message.ICancelPaymentRequestMessage=} [properties] Properties to set
         */
        function CancelPaymentRequestMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CancelPaymentRequestMessage key.
         * @member {Message.IMessageKey|null|undefined} key
         * @memberof Message.CancelPaymentRequestMessage
         * @instance
         */
        CancelPaymentRequestMessage.prototype.key = null;

        /**
         * Creates a new CancelPaymentRequestMessage instance using the specified properties.
         * @function create
         * @memberof Message.CancelPaymentRequestMessage
         * @static
         * @param {Message.ICancelPaymentRequestMessage=} [properties] Properties to set
         * @returns {Message.CancelPaymentRequestMessage} CancelPaymentRequestMessage instance
         */
        CancelPaymentRequestMessage.create = function create(properties) {
            return new CancelPaymentRequestMessage(properties);
        };

        /**
         * Encodes the specified CancelPaymentRequestMessage message. Does not implicitly {@link Message.CancelPaymentRequestMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.CancelPaymentRequestMessage
         * @static
         * @param {Message.ICancelPaymentRequestMessage} message CancelPaymentRequestMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelPaymentRequestMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                $root.Message.MessageKey.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CancelPaymentRequestMessage message, length delimited. Does not implicitly {@link Message.CancelPaymentRequestMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.CancelPaymentRequestMessage
         * @static
         * @param {Message.ICancelPaymentRequestMessage} message CancelPaymentRequestMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelPaymentRequestMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CancelPaymentRequestMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.CancelPaymentRequestMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.CancelPaymentRequestMessage} CancelPaymentRequestMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelPaymentRequestMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.CancelPaymentRequestMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = $root.Message.MessageKey.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CancelPaymentRequestMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.CancelPaymentRequestMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.CancelPaymentRequestMessage} CancelPaymentRequestMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelPaymentRequestMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CancelPaymentRequestMessage message.
         * @function verify
         * @memberof Message.CancelPaymentRequestMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CancelPaymentRequestMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key")) {
                var error = $root.Message.MessageKey.verify(message.key);
                if (error)
                    return "key." + error;
            }
            return null;
        };

        /**
         * Creates a CancelPaymentRequestMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.CancelPaymentRequestMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.CancelPaymentRequestMessage} CancelPaymentRequestMessage
         */
        CancelPaymentRequestMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.CancelPaymentRequestMessage)
                return object;
            var message = new $root.Message.CancelPaymentRequestMessage();
            if (object.key != null) {
                if (typeof object.key !== "object")
                    throw TypeError(".Message.CancelPaymentRequestMessage.key: object expected");
                message.key = $root.Message.MessageKey.fromObject(object.key);
            }
            return message;
        };

        /**
         * Creates a plain object from a CancelPaymentRequestMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.CancelPaymentRequestMessage
         * @static
         * @param {Message.CancelPaymentRequestMessage} message CancelPaymentRequestMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CancelPaymentRequestMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.key = null;
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = $root.Message.MessageKey.toObject(message.key, options);
            return object;
        };

        /**
         * Converts this CancelPaymentRequestMessage to JSON.
         * @function toJSON
         * @memberof Message.CancelPaymentRequestMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CancelPaymentRequestMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CancelPaymentRequestMessage;
    })();

    Message.LiveLocationMessage = (function() {

        /**
         * Properties of a LiveLocationMessage.
         * @memberof Message
         * @interface ILiveLocationMessage
         * @property {number|null} [degreesLatitude] LiveLocationMessage degreesLatitude
         * @property {number|null} [degreesLongitude] LiveLocationMessage degreesLongitude
         * @property {number|null} [accuracyInMeters] LiveLocationMessage accuracyInMeters
         * @property {number|null} [speedInMps] LiveLocationMessage speedInMps
         * @property {number|null} [degreesClockwiseFromMagneticNorth] LiveLocationMessage degreesClockwiseFromMagneticNorth
         * @property {string|null} [caption] LiveLocationMessage caption
         * @property {number|Long|null} [sequenceNumber] LiveLocationMessage sequenceNumber
         * @property {number|null} [timeOffset] LiveLocationMessage timeOffset
         * @property {Uint8Array|null} [jpegThumbnail] LiveLocationMessage jpegThumbnail
         * @property {Message.IContextInfo|null} [contextInfo] LiveLocationMessage contextInfo
         */

        /**
         * Constructs a new LiveLocationMessage.
         * @memberof Message
         * @classdesc Represents a LiveLocationMessage.
         * @implements ILiveLocationMessage
         * @constructor
         * @param {Message.ILiveLocationMessage=} [properties] Properties to set
         */
        function LiveLocationMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LiveLocationMessage degreesLatitude.
         * @member {number} degreesLatitude
         * @memberof Message.LiveLocationMessage
         * @instance
         */
        LiveLocationMessage.prototype.degreesLatitude = 0;

        /**
         * LiveLocationMessage degreesLongitude.
         * @member {number} degreesLongitude
         * @memberof Message.LiveLocationMessage
         * @instance
         */
        LiveLocationMessage.prototype.degreesLongitude = 0;

        /**
         * LiveLocationMessage accuracyInMeters.
         * @member {number} accuracyInMeters
         * @memberof Message.LiveLocationMessage
         * @instance
         */
        LiveLocationMessage.prototype.accuracyInMeters = 0;

        /**
         * LiveLocationMessage speedInMps.
         * @member {number} speedInMps
         * @memberof Message.LiveLocationMessage
         * @instance
         */
        LiveLocationMessage.prototype.speedInMps = 0;

        /**
         * LiveLocationMessage degreesClockwiseFromMagneticNorth.
         * @member {number} degreesClockwiseFromMagneticNorth
         * @memberof Message.LiveLocationMessage
         * @instance
         */
        LiveLocationMessage.prototype.degreesClockwiseFromMagneticNorth = 0;

        /**
         * LiveLocationMessage caption.
         * @member {string} caption
         * @memberof Message.LiveLocationMessage
         * @instance
         */
        LiveLocationMessage.prototype.caption = "";

        /**
         * LiveLocationMessage sequenceNumber.
         * @member {number|Long} sequenceNumber
         * @memberof Message.LiveLocationMessage
         * @instance
         */
        LiveLocationMessage.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LiveLocationMessage timeOffset.
         * @member {number} timeOffset
         * @memberof Message.LiveLocationMessage
         * @instance
         */
        LiveLocationMessage.prototype.timeOffset = 0;

        /**
         * LiveLocationMessage jpegThumbnail.
         * @member {Uint8Array} jpegThumbnail
         * @memberof Message.LiveLocationMessage
         * @instance
         */
        LiveLocationMessage.prototype.jpegThumbnail = $util.newBuffer([]);

        /**
         * LiveLocationMessage contextInfo.
         * @member {Message.IContextInfo|null|undefined} contextInfo
         * @memberof Message.LiveLocationMessage
         * @instance
         */
        LiveLocationMessage.prototype.contextInfo = null;

        /**
         * Creates a new LiveLocationMessage instance using the specified properties.
         * @function create
         * @memberof Message.LiveLocationMessage
         * @static
         * @param {Message.ILiveLocationMessage=} [properties] Properties to set
         * @returns {Message.LiveLocationMessage} LiveLocationMessage instance
         */
        LiveLocationMessage.create = function create(properties) {
            return new LiveLocationMessage(properties);
        };

        /**
         * Encodes the specified LiveLocationMessage message. Does not implicitly {@link Message.LiveLocationMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.LiveLocationMessage
         * @static
         * @param {Message.ILiveLocationMessage} message LiveLocationMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LiveLocationMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.degreesLatitude != null && Object.hasOwnProperty.call(message, "degreesLatitude"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.degreesLatitude);
            if (message.degreesLongitude != null && Object.hasOwnProperty.call(message, "degreesLongitude"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.degreesLongitude);
            if (message.accuracyInMeters != null && Object.hasOwnProperty.call(message, "accuracyInMeters"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.accuracyInMeters);
            if (message.speedInMps != null && Object.hasOwnProperty.call(message, "speedInMps"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.speedInMps);
            if (message.degreesClockwiseFromMagneticNorth != null && Object.hasOwnProperty.call(message, "degreesClockwiseFromMagneticNorth"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.degreesClockwiseFromMagneticNorth);
            if (message.caption != null && Object.hasOwnProperty.call(message, "caption"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.caption);
            if (message.sequenceNumber != null && Object.hasOwnProperty.call(message, "sequenceNumber"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.sequenceNumber);
            if (message.timeOffset != null && Object.hasOwnProperty.call(message, "timeOffset"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.timeOffset);
            if (message.jpegThumbnail != null && Object.hasOwnProperty.call(message, "jpegThumbnail"))
                writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.jpegThumbnail);
            if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                $root.Message.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LiveLocationMessage message, length delimited. Does not implicitly {@link Message.LiveLocationMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.LiveLocationMessage
         * @static
         * @param {Message.ILiveLocationMessage} message LiveLocationMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LiveLocationMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LiveLocationMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.LiveLocationMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.LiveLocationMessage} LiveLocationMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveLocationMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.LiveLocationMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.degreesLatitude = reader.double();
                    break;
                case 2:
                    message.degreesLongitude = reader.double();
                    break;
                case 3:
                    message.accuracyInMeters = reader.uint32();
                    break;
                case 4:
                    message.speedInMps = reader.float();
                    break;
                case 5:
                    message.degreesClockwiseFromMagneticNorth = reader.uint32();
                    break;
                case 6:
                    message.caption = reader.string();
                    break;
                case 7:
                    message.sequenceNumber = reader.int64();
                    break;
                case 8:
                    message.timeOffset = reader.uint32();
                    break;
                case 16:
                    message.jpegThumbnail = reader.bytes();
                    break;
                case 17:
                    message.contextInfo = $root.Message.ContextInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LiveLocationMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.LiveLocationMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.LiveLocationMessage} LiveLocationMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveLocationMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LiveLocationMessage message.
         * @function verify
         * @memberof Message.LiveLocationMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LiveLocationMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.degreesLatitude != null && message.hasOwnProperty("degreesLatitude"))
                if (typeof message.degreesLatitude !== "number")
                    return "degreesLatitude: number expected";
            if (message.degreesLongitude != null && message.hasOwnProperty("degreesLongitude"))
                if (typeof message.degreesLongitude !== "number")
                    return "degreesLongitude: number expected";
            if (message.accuracyInMeters != null && message.hasOwnProperty("accuracyInMeters"))
                if (!$util.isInteger(message.accuracyInMeters))
                    return "accuracyInMeters: integer expected";
            if (message.speedInMps != null && message.hasOwnProperty("speedInMps"))
                if (typeof message.speedInMps !== "number")
                    return "speedInMps: number expected";
            if (message.degreesClockwiseFromMagneticNorth != null && message.hasOwnProperty("degreesClockwiseFromMagneticNorth"))
                if (!$util.isInteger(message.degreesClockwiseFromMagneticNorth))
                    return "degreesClockwiseFromMagneticNorth: integer expected";
            if (message.caption != null && message.hasOwnProperty("caption"))
                if (!$util.isString(message.caption))
                    return "caption: string expected";
            if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                if (!$util.isInteger(message.sequenceNumber) && !(message.sequenceNumber && $util.isInteger(message.sequenceNumber.low) && $util.isInteger(message.sequenceNumber.high)))
                    return "sequenceNumber: integer|Long expected";
            if (message.timeOffset != null && message.hasOwnProperty("timeOffset"))
                if (!$util.isInteger(message.timeOffset))
                    return "timeOffset: integer expected";
            if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                if (!(message.jpegThumbnail && typeof message.jpegThumbnail.length === "number" || $util.isString(message.jpegThumbnail)))
                    return "jpegThumbnail: buffer expected";
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                var error = $root.Message.ContextInfo.verify(message.contextInfo);
                if (error)
                    return "contextInfo." + error;
            }
            return null;
        };

        /**
         * Creates a LiveLocationMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.LiveLocationMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.LiveLocationMessage} LiveLocationMessage
         */
        LiveLocationMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.LiveLocationMessage)
                return object;
            var message = new $root.Message.LiveLocationMessage();
            if (object.degreesLatitude != null)
                message.degreesLatitude = Number(object.degreesLatitude);
            if (object.degreesLongitude != null)
                message.degreesLongitude = Number(object.degreesLongitude);
            if (object.accuracyInMeters != null)
                message.accuracyInMeters = object.accuracyInMeters >>> 0;
            if (object.speedInMps != null)
                message.speedInMps = Number(object.speedInMps);
            if (object.degreesClockwiseFromMagneticNorth != null)
                message.degreesClockwiseFromMagneticNorth = object.degreesClockwiseFromMagneticNorth >>> 0;
            if (object.caption != null)
                message.caption = String(object.caption);
            if (object.sequenceNumber != null)
                if ($util.Long)
                    (message.sequenceNumber = $util.Long.fromValue(object.sequenceNumber)).unsigned = false;
                else if (typeof object.sequenceNumber === "string")
                    message.sequenceNumber = parseInt(object.sequenceNumber, 10);
                else if (typeof object.sequenceNumber === "number")
                    message.sequenceNumber = object.sequenceNumber;
                else if (typeof object.sequenceNumber === "object")
                    message.sequenceNumber = new $util.LongBits(object.sequenceNumber.low >>> 0, object.sequenceNumber.high >>> 0).toNumber();
            if (object.timeOffset != null)
                message.timeOffset = object.timeOffset >>> 0;
            if (object.jpegThumbnail != null)
                if (typeof object.jpegThumbnail === "string")
                    $util.base64.decode(object.jpegThumbnail, message.jpegThumbnail = $util.newBuffer($util.base64.length(object.jpegThumbnail)), 0);
                else if (object.jpegThumbnail.length)
                    message.jpegThumbnail = object.jpegThumbnail;
            if (object.contextInfo != null) {
                if (typeof object.contextInfo !== "object")
                    throw TypeError(".Message.LiveLocationMessage.contextInfo: object expected");
                message.contextInfo = $root.Message.ContextInfo.fromObject(object.contextInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a LiveLocationMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.LiveLocationMessage
         * @static
         * @param {Message.LiveLocationMessage} message LiveLocationMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LiveLocationMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.degreesLatitude = 0;
                object.degreesLongitude = 0;
                object.accuracyInMeters = 0;
                object.speedInMps = 0;
                object.degreesClockwiseFromMagneticNorth = 0;
                object.caption = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.sequenceNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sequenceNumber = options.longs === String ? "0" : 0;
                object.timeOffset = 0;
                if (options.bytes === String)
                    object.jpegThumbnail = "";
                else {
                    object.jpegThumbnail = [];
                    if (options.bytes !== Array)
                        object.jpegThumbnail = $util.newBuffer(object.jpegThumbnail);
                }
                object.contextInfo = null;
            }
            if (message.degreesLatitude != null && message.hasOwnProperty("degreesLatitude"))
                object.degreesLatitude = options.json && !isFinite(message.degreesLatitude) ? String(message.degreesLatitude) : message.degreesLatitude;
            if (message.degreesLongitude != null && message.hasOwnProperty("degreesLongitude"))
                object.degreesLongitude = options.json && !isFinite(message.degreesLongitude) ? String(message.degreesLongitude) : message.degreesLongitude;
            if (message.accuracyInMeters != null && message.hasOwnProperty("accuracyInMeters"))
                object.accuracyInMeters = message.accuracyInMeters;
            if (message.speedInMps != null && message.hasOwnProperty("speedInMps"))
                object.speedInMps = options.json && !isFinite(message.speedInMps) ? String(message.speedInMps) : message.speedInMps;
            if (message.degreesClockwiseFromMagneticNorth != null && message.hasOwnProperty("degreesClockwiseFromMagneticNorth"))
                object.degreesClockwiseFromMagneticNorth = message.degreesClockwiseFromMagneticNorth;
            if (message.caption != null && message.hasOwnProperty("caption"))
                object.caption = message.caption;
            if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                if (typeof message.sequenceNumber === "number")
                    object.sequenceNumber = options.longs === String ? String(message.sequenceNumber) : message.sequenceNumber;
                else
                    object.sequenceNumber = options.longs === String ? $util.Long.prototype.toString.call(message.sequenceNumber) : options.longs === Number ? new $util.LongBits(message.sequenceNumber.low >>> 0, message.sequenceNumber.high >>> 0).toNumber() : message.sequenceNumber;
            if (message.timeOffset != null && message.hasOwnProperty("timeOffset"))
                object.timeOffset = message.timeOffset;
            if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                object.jpegThumbnail = options.bytes === String ? $util.base64.encode(message.jpegThumbnail, 0, message.jpegThumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.jpegThumbnail) : message.jpegThumbnail;
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                object.contextInfo = $root.Message.ContextInfo.toObject(message.contextInfo, options);
            return object;
        };

        /**
         * Converts this LiveLocationMessage to JSON.
         * @function toJSON
         * @memberof Message.LiveLocationMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LiveLocationMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LiveLocationMessage;
    })();

    Message.StickerMessage = (function() {

        /**
         * Properties of a StickerMessage.
         * @memberof Message
         * @interface IStickerMessage
         * @property {string|null} [url] StickerMessage url
         * @property {Uint8Array|null} [fileSha256] StickerMessage fileSha256
         * @property {Uint8Array|null} [fileEncSha256] StickerMessage fileEncSha256
         * @property {Uint8Array|null} [mediaKey] StickerMessage mediaKey
         * @property {string|null} [mimetype] StickerMessage mimetype
         * @property {number|null} [height] StickerMessage height
         * @property {number|null} [width] StickerMessage width
         * @property {string|null} [directPath] StickerMessage directPath
         * @property {number|Long|null} [fileLength] StickerMessage fileLength
         * @property {number|Long|null} [mediaKeyTimestamp] StickerMessage mediaKeyTimestamp
         * @property {number|null} [firstFrameLength] StickerMessage firstFrameLength
         * @property {Uint8Array|null} [firstFrameSidecar] StickerMessage firstFrameSidecar
         * @property {boolean|null} [isAnimated] StickerMessage isAnimated
         * @property {Uint8Array|null} [pngThumbnail] StickerMessage pngThumbnail
         * @property {Message.IContextInfo|null} [contextInfo] StickerMessage contextInfo
         */

        /**
         * Constructs a new StickerMessage.
         * @memberof Message
         * @classdesc Represents a StickerMessage.
         * @implements IStickerMessage
         * @constructor
         * @param {Message.IStickerMessage=} [properties] Properties to set
         */
        function StickerMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StickerMessage url.
         * @member {string} url
         * @memberof Message.StickerMessage
         * @instance
         */
        StickerMessage.prototype.url = "";

        /**
         * StickerMessage fileSha256.
         * @member {Uint8Array} fileSha256
         * @memberof Message.StickerMessage
         * @instance
         */
        StickerMessage.prototype.fileSha256 = $util.newBuffer([]);

        /**
         * StickerMessage fileEncSha256.
         * @member {Uint8Array} fileEncSha256
         * @memberof Message.StickerMessage
         * @instance
         */
        StickerMessage.prototype.fileEncSha256 = $util.newBuffer([]);

        /**
         * StickerMessage mediaKey.
         * @member {Uint8Array} mediaKey
         * @memberof Message.StickerMessage
         * @instance
         */
        StickerMessage.prototype.mediaKey = $util.newBuffer([]);

        /**
         * StickerMessage mimetype.
         * @member {string} mimetype
         * @memberof Message.StickerMessage
         * @instance
         */
        StickerMessage.prototype.mimetype = "";

        /**
         * StickerMessage height.
         * @member {number} height
         * @memberof Message.StickerMessage
         * @instance
         */
        StickerMessage.prototype.height = 0;

        /**
         * StickerMessage width.
         * @member {number} width
         * @memberof Message.StickerMessage
         * @instance
         */
        StickerMessage.prototype.width = 0;

        /**
         * StickerMessage directPath.
         * @member {string} directPath
         * @memberof Message.StickerMessage
         * @instance
         */
        StickerMessage.prototype.directPath = "";

        /**
         * StickerMessage fileLength.
         * @member {number|Long} fileLength
         * @memberof Message.StickerMessage
         * @instance
         */
        StickerMessage.prototype.fileLength = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StickerMessage mediaKeyTimestamp.
         * @member {number|Long} mediaKeyTimestamp
         * @memberof Message.StickerMessage
         * @instance
         */
        StickerMessage.prototype.mediaKeyTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * StickerMessage firstFrameLength.
         * @member {number} firstFrameLength
         * @memberof Message.StickerMessage
         * @instance
         */
        StickerMessage.prototype.firstFrameLength = 0;

        /**
         * StickerMessage firstFrameSidecar.
         * @member {Uint8Array} firstFrameSidecar
         * @memberof Message.StickerMessage
         * @instance
         */
        StickerMessage.prototype.firstFrameSidecar = $util.newBuffer([]);

        /**
         * StickerMessage isAnimated.
         * @member {boolean} isAnimated
         * @memberof Message.StickerMessage
         * @instance
         */
        StickerMessage.prototype.isAnimated = false;

        /**
         * StickerMessage pngThumbnail.
         * @member {Uint8Array} pngThumbnail
         * @memberof Message.StickerMessage
         * @instance
         */
        StickerMessage.prototype.pngThumbnail = $util.newBuffer([]);

        /**
         * StickerMessage contextInfo.
         * @member {Message.IContextInfo|null|undefined} contextInfo
         * @memberof Message.StickerMessage
         * @instance
         */
        StickerMessage.prototype.contextInfo = null;

        /**
         * Creates a new StickerMessage instance using the specified properties.
         * @function create
         * @memberof Message.StickerMessage
         * @static
         * @param {Message.IStickerMessage=} [properties] Properties to set
         * @returns {Message.StickerMessage} StickerMessage instance
         */
        StickerMessage.create = function create(properties) {
            return new StickerMessage(properties);
        };

        /**
         * Encodes the specified StickerMessage message. Does not implicitly {@link Message.StickerMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.StickerMessage
         * @static
         * @param {Message.IStickerMessage} message StickerMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StickerMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
            if (message.fileSha256 != null && Object.hasOwnProperty.call(message, "fileSha256"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.fileSha256);
            if (message.fileEncSha256 != null && Object.hasOwnProperty.call(message, "fileEncSha256"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.fileEncSha256);
            if (message.mediaKey != null && Object.hasOwnProperty.call(message, "mediaKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.mediaKey);
            if (message.mimetype != null && Object.hasOwnProperty.call(message, "mimetype"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.mimetype);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.height);
            if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.width);
            if (message.directPath != null && Object.hasOwnProperty.call(message, "directPath"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.directPath);
            if (message.fileLength != null && Object.hasOwnProperty.call(message, "fileLength"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.fileLength);
            if (message.mediaKeyTimestamp != null && Object.hasOwnProperty.call(message, "mediaKeyTimestamp"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.mediaKeyTimestamp);
            if (message.firstFrameLength != null && Object.hasOwnProperty.call(message, "firstFrameLength"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.firstFrameLength);
            if (message.firstFrameSidecar != null && Object.hasOwnProperty.call(message, "firstFrameSidecar"))
                writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.firstFrameSidecar);
            if (message.isAnimated != null && Object.hasOwnProperty.call(message, "isAnimated"))
                writer.uint32(/* id 13, wireType 0 =*/104).bool(message.isAnimated);
            if (message.pngThumbnail != null && Object.hasOwnProperty.call(message, "pngThumbnail"))
                writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.pngThumbnail);
            if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                $root.Message.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StickerMessage message, length delimited. Does not implicitly {@link Message.StickerMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.StickerMessage
         * @static
         * @param {Message.IStickerMessage} message StickerMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StickerMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StickerMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.StickerMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.StickerMessage} StickerMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StickerMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.StickerMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.url = reader.string();
                    break;
                case 2:
                    message.fileSha256 = reader.bytes();
                    break;
                case 3:
                    message.fileEncSha256 = reader.bytes();
                    break;
                case 4:
                    message.mediaKey = reader.bytes();
                    break;
                case 5:
                    message.mimetype = reader.string();
                    break;
                case 6:
                    message.height = reader.uint32();
                    break;
                case 7:
                    message.width = reader.uint32();
                    break;
                case 8:
                    message.directPath = reader.string();
                    break;
                case 9:
                    message.fileLength = reader.uint64();
                    break;
                case 10:
                    message.mediaKeyTimestamp = reader.int64();
                    break;
                case 11:
                    message.firstFrameLength = reader.uint32();
                    break;
                case 12:
                    message.firstFrameSidecar = reader.bytes();
                    break;
                case 13:
                    message.isAnimated = reader.bool();
                    break;
                case 16:
                    message.pngThumbnail = reader.bytes();
                    break;
                case 17:
                    message.contextInfo = $root.Message.ContextInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StickerMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.StickerMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.StickerMessage} StickerMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StickerMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StickerMessage message.
         * @function verify
         * @memberof Message.StickerMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StickerMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                if (!(message.fileSha256 && typeof message.fileSha256.length === "number" || $util.isString(message.fileSha256)))
                    return "fileSha256: buffer expected";
            if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                if (!(message.fileEncSha256 && typeof message.fileEncSha256.length === "number" || $util.isString(message.fileEncSha256)))
                    return "fileEncSha256: buffer expected";
            if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                if (!(message.mediaKey && typeof message.mediaKey.length === "number" || $util.isString(message.mediaKey)))
                    return "mediaKey: buffer expected";
            if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                if (!$util.isString(message.mimetype))
                    return "mimetype: string expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (!$util.isInteger(message.height))
                    return "height: integer expected";
            if (message.width != null && message.hasOwnProperty("width"))
                if (!$util.isInteger(message.width))
                    return "width: integer expected";
            if (message.directPath != null && message.hasOwnProperty("directPath"))
                if (!$util.isString(message.directPath))
                    return "directPath: string expected";
            if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                if (!$util.isInteger(message.fileLength) && !(message.fileLength && $util.isInteger(message.fileLength.low) && $util.isInteger(message.fileLength.high)))
                    return "fileLength: integer|Long expected";
            if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                if (!$util.isInteger(message.mediaKeyTimestamp) && !(message.mediaKeyTimestamp && $util.isInteger(message.mediaKeyTimestamp.low) && $util.isInteger(message.mediaKeyTimestamp.high)))
                    return "mediaKeyTimestamp: integer|Long expected";
            if (message.firstFrameLength != null && message.hasOwnProperty("firstFrameLength"))
                if (!$util.isInteger(message.firstFrameLength))
                    return "firstFrameLength: integer expected";
            if (message.firstFrameSidecar != null && message.hasOwnProperty("firstFrameSidecar"))
                if (!(message.firstFrameSidecar && typeof message.firstFrameSidecar.length === "number" || $util.isString(message.firstFrameSidecar)))
                    return "firstFrameSidecar: buffer expected";
            if (message.isAnimated != null && message.hasOwnProperty("isAnimated"))
                if (typeof message.isAnimated !== "boolean")
                    return "isAnimated: boolean expected";
            if (message.pngThumbnail != null && message.hasOwnProperty("pngThumbnail"))
                if (!(message.pngThumbnail && typeof message.pngThumbnail.length === "number" || $util.isString(message.pngThumbnail)))
                    return "pngThumbnail: buffer expected";
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                var error = $root.Message.ContextInfo.verify(message.contextInfo);
                if (error)
                    return "contextInfo." + error;
            }
            return null;
        };

        /**
         * Creates a StickerMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.StickerMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.StickerMessage} StickerMessage
         */
        StickerMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.StickerMessage)
                return object;
            var message = new $root.Message.StickerMessage();
            if (object.url != null)
                message.url = String(object.url);
            if (object.fileSha256 != null)
                if (typeof object.fileSha256 === "string")
                    $util.base64.decode(object.fileSha256, message.fileSha256 = $util.newBuffer($util.base64.length(object.fileSha256)), 0);
                else if (object.fileSha256.length)
                    message.fileSha256 = object.fileSha256;
            if (object.fileEncSha256 != null)
                if (typeof object.fileEncSha256 === "string")
                    $util.base64.decode(object.fileEncSha256, message.fileEncSha256 = $util.newBuffer($util.base64.length(object.fileEncSha256)), 0);
                else if (object.fileEncSha256.length)
                    message.fileEncSha256 = object.fileEncSha256;
            if (object.mediaKey != null)
                if (typeof object.mediaKey === "string")
                    $util.base64.decode(object.mediaKey, message.mediaKey = $util.newBuffer($util.base64.length(object.mediaKey)), 0);
                else if (object.mediaKey.length)
                    message.mediaKey = object.mediaKey;
            if (object.mimetype != null)
                message.mimetype = String(object.mimetype);
            if (object.height != null)
                message.height = object.height >>> 0;
            if (object.width != null)
                message.width = object.width >>> 0;
            if (object.directPath != null)
                message.directPath = String(object.directPath);
            if (object.fileLength != null)
                if ($util.Long)
                    (message.fileLength = $util.Long.fromValue(object.fileLength)).unsigned = true;
                else if (typeof object.fileLength === "string")
                    message.fileLength = parseInt(object.fileLength, 10);
                else if (typeof object.fileLength === "number")
                    message.fileLength = object.fileLength;
                else if (typeof object.fileLength === "object")
                    message.fileLength = new $util.LongBits(object.fileLength.low >>> 0, object.fileLength.high >>> 0).toNumber(true);
            if (object.mediaKeyTimestamp != null)
                if ($util.Long)
                    (message.mediaKeyTimestamp = $util.Long.fromValue(object.mediaKeyTimestamp)).unsigned = false;
                else if (typeof object.mediaKeyTimestamp === "string")
                    message.mediaKeyTimestamp = parseInt(object.mediaKeyTimestamp, 10);
                else if (typeof object.mediaKeyTimestamp === "number")
                    message.mediaKeyTimestamp = object.mediaKeyTimestamp;
                else if (typeof object.mediaKeyTimestamp === "object")
                    message.mediaKeyTimestamp = new $util.LongBits(object.mediaKeyTimestamp.low >>> 0, object.mediaKeyTimestamp.high >>> 0).toNumber();
            if (object.firstFrameLength != null)
                message.firstFrameLength = object.firstFrameLength >>> 0;
            if (object.firstFrameSidecar != null)
                if (typeof object.firstFrameSidecar === "string")
                    $util.base64.decode(object.firstFrameSidecar, message.firstFrameSidecar = $util.newBuffer($util.base64.length(object.firstFrameSidecar)), 0);
                else if (object.firstFrameSidecar.length)
                    message.firstFrameSidecar = object.firstFrameSidecar;
            if (object.isAnimated != null)
                message.isAnimated = Boolean(object.isAnimated);
            if (object.pngThumbnail != null)
                if (typeof object.pngThumbnail === "string")
                    $util.base64.decode(object.pngThumbnail, message.pngThumbnail = $util.newBuffer($util.base64.length(object.pngThumbnail)), 0);
                else if (object.pngThumbnail.length)
                    message.pngThumbnail = object.pngThumbnail;
            if (object.contextInfo != null) {
                if (typeof object.contextInfo !== "object")
                    throw TypeError(".Message.StickerMessage.contextInfo: object expected");
                message.contextInfo = $root.Message.ContextInfo.fromObject(object.contextInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a StickerMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.StickerMessage
         * @static
         * @param {Message.StickerMessage} message StickerMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StickerMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.url = "";
                if (options.bytes === String)
                    object.fileSha256 = "";
                else {
                    object.fileSha256 = [];
                    if (options.bytes !== Array)
                        object.fileSha256 = $util.newBuffer(object.fileSha256);
                }
                if (options.bytes === String)
                    object.fileEncSha256 = "";
                else {
                    object.fileEncSha256 = [];
                    if (options.bytes !== Array)
                        object.fileEncSha256 = $util.newBuffer(object.fileEncSha256);
                }
                if (options.bytes === String)
                    object.mediaKey = "";
                else {
                    object.mediaKey = [];
                    if (options.bytes !== Array)
                        object.mediaKey = $util.newBuffer(object.mediaKey);
                }
                object.mimetype = "";
                object.height = 0;
                object.width = 0;
                object.directPath = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.fileLength = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fileLength = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.mediaKeyTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.mediaKeyTimestamp = options.longs === String ? "0" : 0;
                object.firstFrameLength = 0;
                if (options.bytes === String)
                    object.firstFrameSidecar = "";
                else {
                    object.firstFrameSidecar = [];
                    if (options.bytes !== Array)
                        object.firstFrameSidecar = $util.newBuffer(object.firstFrameSidecar);
                }
                object.isAnimated = false;
                if (options.bytes === String)
                    object.pngThumbnail = "";
                else {
                    object.pngThumbnail = [];
                    if (options.bytes !== Array)
                        object.pngThumbnail = $util.newBuffer(object.pngThumbnail);
                }
                object.contextInfo = null;
            }
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.fileSha256 != null && message.hasOwnProperty("fileSha256"))
                object.fileSha256 = options.bytes === String ? $util.base64.encode(message.fileSha256, 0, message.fileSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileSha256) : message.fileSha256;
            if (message.fileEncSha256 != null && message.hasOwnProperty("fileEncSha256"))
                object.fileEncSha256 = options.bytes === String ? $util.base64.encode(message.fileEncSha256, 0, message.fileEncSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.fileEncSha256) : message.fileEncSha256;
            if (message.mediaKey != null && message.hasOwnProperty("mediaKey"))
                object.mediaKey = options.bytes === String ? $util.base64.encode(message.mediaKey, 0, message.mediaKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.mediaKey) : message.mediaKey;
            if (message.mimetype != null && message.hasOwnProperty("mimetype"))
                object.mimetype = message.mimetype;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = message.height;
            if (message.width != null && message.hasOwnProperty("width"))
                object.width = message.width;
            if (message.directPath != null && message.hasOwnProperty("directPath"))
                object.directPath = message.directPath;
            if (message.fileLength != null && message.hasOwnProperty("fileLength"))
                if (typeof message.fileLength === "number")
                    object.fileLength = options.longs === String ? String(message.fileLength) : message.fileLength;
                else
                    object.fileLength = options.longs === String ? $util.Long.prototype.toString.call(message.fileLength) : options.longs === Number ? new $util.LongBits(message.fileLength.low >>> 0, message.fileLength.high >>> 0).toNumber(true) : message.fileLength;
            if (message.mediaKeyTimestamp != null && message.hasOwnProperty("mediaKeyTimestamp"))
                if (typeof message.mediaKeyTimestamp === "number")
                    object.mediaKeyTimestamp = options.longs === String ? String(message.mediaKeyTimestamp) : message.mediaKeyTimestamp;
                else
                    object.mediaKeyTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.mediaKeyTimestamp) : options.longs === Number ? new $util.LongBits(message.mediaKeyTimestamp.low >>> 0, message.mediaKeyTimestamp.high >>> 0).toNumber() : message.mediaKeyTimestamp;
            if (message.firstFrameLength != null && message.hasOwnProperty("firstFrameLength"))
                object.firstFrameLength = message.firstFrameLength;
            if (message.firstFrameSidecar != null && message.hasOwnProperty("firstFrameSidecar"))
                object.firstFrameSidecar = options.bytes === String ? $util.base64.encode(message.firstFrameSidecar, 0, message.firstFrameSidecar.length) : options.bytes === Array ? Array.prototype.slice.call(message.firstFrameSidecar) : message.firstFrameSidecar;
            if (message.isAnimated != null && message.hasOwnProperty("isAnimated"))
                object.isAnimated = message.isAnimated;
            if (message.pngThumbnail != null && message.hasOwnProperty("pngThumbnail"))
                object.pngThumbnail = options.bytes === String ? $util.base64.encode(message.pngThumbnail, 0, message.pngThumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.pngThumbnail) : message.pngThumbnail;
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                object.contextInfo = $root.Message.ContextInfo.toObject(message.contextInfo, options);
            return object;
        };

        /**
         * Converts this StickerMessage to JSON.
         * @function toJSON
         * @memberof Message.StickerMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StickerMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StickerMessage;
    })();

    Message.FourRowTemplate = (function() {

        /**
         * Properties of a FourRowTemplate.
         * @memberof Message
         * @interface IFourRowTemplate
         * @property {Message.IHighlyStructuredMessage|null} [content] FourRowTemplate content
         * @property {Message.IHighlyStructuredMessage|null} [footer] FourRowTemplate footer
         * @property {Array.<Message.ITemplateButton>|null} [buttons] FourRowTemplate buttons
         * @property {Message.IDocumentMessage|null} [documentMessage] FourRowTemplate documentMessage
         * @property {Message.IHighlyStructuredMessage|null} [highlyStructuredMessage] FourRowTemplate highlyStructuredMessage
         * @property {Message.IImageMessage|null} [imageMessage] FourRowTemplate imageMessage
         * @property {Message.IVideoMessage|null} [videoMessage] FourRowTemplate videoMessage
         * @property {Message.ILocationMessage|null} [locationMessage] FourRowTemplate locationMessage
         */

        /**
         * Constructs a new FourRowTemplate.
         * @memberof Message
         * @classdesc Represents a FourRowTemplate.
         * @implements IFourRowTemplate
         * @constructor
         * @param {Message.IFourRowTemplate=} [properties] Properties to set
         */
        function FourRowTemplate(properties) {
            this.buttons = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FourRowTemplate content.
         * @member {Message.IHighlyStructuredMessage|null|undefined} content
         * @memberof Message.FourRowTemplate
         * @instance
         */
        FourRowTemplate.prototype.content = null;

        /**
         * FourRowTemplate footer.
         * @member {Message.IHighlyStructuredMessage|null|undefined} footer
         * @memberof Message.FourRowTemplate
         * @instance
         */
        FourRowTemplate.prototype.footer = null;

        /**
         * FourRowTemplate buttons.
         * @member {Array.<Message.ITemplateButton>} buttons
         * @memberof Message.FourRowTemplate
         * @instance
         */
        FourRowTemplate.prototype.buttons = $util.emptyArray;

        /**
         * FourRowTemplate documentMessage.
         * @member {Message.IDocumentMessage|null|undefined} documentMessage
         * @memberof Message.FourRowTemplate
         * @instance
         */
        FourRowTemplate.prototype.documentMessage = null;

        /**
         * FourRowTemplate highlyStructuredMessage.
         * @member {Message.IHighlyStructuredMessage|null|undefined} highlyStructuredMessage
         * @memberof Message.FourRowTemplate
         * @instance
         */
        FourRowTemplate.prototype.highlyStructuredMessage = null;

        /**
         * FourRowTemplate imageMessage.
         * @member {Message.IImageMessage|null|undefined} imageMessage
         * @memberof Message.FourRowTemplate
         * @instance
         */
        FourRowTemplate.prototype.imageMessage = null;

        /**
         * FourRowTemplate videoMessage.
         * @member {Message.IVideoMessage|null|undefined} videoMessage
         * @memberof Message.FourRowTemplate
         * @instance
         */
        FourRowTemplate.prototype.videoMessage = null;

        /**
         * FourRowTemplate locationMessage.
         * @member {Message.ILocationMessage|null|undefined} locationMessage
         * @memberof Message.FourRowTemplate
         * @instance
         */
        FourRowTemplate.prototype.locationMessage = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * FourRowTemplate title.
         * @member {"documentMessage"|"highlyStructuredMessage"|"imageMessage"|"videoMessage"|"locationMessage"|undefined} title
         * @memberof Message.FourRowTemplate
         * @instance
         */
        Object.defineProperty(FourRowTemplate.prototype, "title", {
            get: $util.oneOfGetter($oneOfFields = ["documentMessage", "highlyStructuredMessage", "imageMessage", "videoMessage", "locationMessage"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new FourRowTemplate instance using the specified properties.
         * @function create
         * @memberof Message.FourRowTemplate
         * @static
         * @param {Message.IFourRowTemplate=} [properties] Properties to set
         * @returns {Message.FourRowTemplate} FourRowTemplate instance
         */
        FourRowTemplate.create = function create(properties) {
            return new FourRowTemplate(properties);
        };

        /**
         * Encodes the specified FourRowTemplate message. Does not implicitly {@link Message.FourRowTemplate.verify|verify} messages.
         * @function encode
         * @memberof Message.FourRowTemplate
         * @static
         * @param {Message.IFourRowTemplate} message FourRowTemplate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FourRowTemplate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.documentMessage != null && Object.hasOwnProperty.call(message, "documentMessage"))
                $root.Message.DocumentMessage.encode(message.documentMessage, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.highlyStructuredMessage != null && Object.hasOwnProperty.call(message, "highlyStructuredMessage"))
                $root.Message.HighlyStructuredMessage.encode(message.highlyStructuredMessage, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.imageMessage != null && Object.hasOwnProperty.call(message, "imageMessage"))
                $root.Message.ImageMessage.encode(message.imageMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.videoMessage != null && Object.hasOwnProperty.call(message, "videoMessage"))
                $root.Message.VideoMessage.encode(message.videoMessage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.locationMessage != null && Object.hasOwnProperty.call(message, "locationMessage"))
                $root.Message.LocationMessage.encode(message.locationMessage, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                $root.Message.HighlyStructuredMessage.encode(message.content, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.footer != null && Object.hasOwnProperty.call(message, "footer"))
                $root.Message.HighlyStructuredMessage.encode(message.footer, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.buttons != null && message.buttons.length)
                for (var i = 0; i < message.buttons.length; ++i)
                    $root.Message.TemplateButton.encode(message.buttons[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FourRowTemplate message, length delimited. Does not implicitly {@link Message.FourRowTemplate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.FourRowTemplate
         * @static
         * @param {Message.IFourRowTemplate} message FourRowTemplate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FourRowTemplate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FourRowTemplate message from the specified reader or buffer.
         * @function decode
         * @memberof Message.FourRowTemplate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.FourRowTemplate} FourRowTemplate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FourRowTemplate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.FourRowTemplate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 6:
                    message.content = $root.Message.HighlyStructuredMessage.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.footer = $root.Message.HighlyStructuredMessage.decode(reader, reader.uint32());
                    break;
                case 8:
                    if (!(message.buttons && message.buttons.length))
                        message.buttons = [];
                    message.buttons.push($root.Message.TemplateButton.decode(reader, reader.uint32()));
                    break;
                case 1:
                    message.documentMessage = $root.Message.DocumentMessage.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.highlyStructuredMessage = $root.Message.HighlyStructuredMessage.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.imageMessage = $root.Message.ImageMessage.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.videoMessage = $root.Message.VideoMessage.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.locationMessage = $root.Message.LocationMessage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FourRowTemplate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.FourRowTemplate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.FourRowTemplate} FourRowTemplate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FourRowTemplate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FourRowTemplate message.
         * @function verify
         * @memberof Message.FourRowTemplate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FourRowTemplate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.content != null && message.hasOwnProperty("content")) {
                var error = $root.Message.HighlyStructuredMessage.verify(message.content);
                if (error)
                    return "content." + error;
            }
            if (message.footer != null && message.hasOwnProperty("footer")) {
                var error = $root.Message.HighlyStructuredMessage.verify(message.footer);
                if (error)
                    return "footer." + error;
            }
            if (message.buttons != null && message.hasOwnProperty("buttons")) {
                if (!Array.isArray(message.buttons))
                    return "buttons: array expected";
                for (var i = 0; i < message.buttons.length; ++i) {
                    var error = $root.Message.TemplateButton.verify(message.buttons[i]);
                    if (error)
                        return "buttons." + error;
                }
            }
            if (message.documentMessage != null && message.hasOwnProperty("documentMessage")) {
                properties.title = 1;
                {
                    var error = $root.Message.DocumentMessage.verify(message.documentMessage);
                    if (error)
                        return "documentMessage." + error;
                }
            }
            if (message.highlyStructuredMessage != null && message.hasOwnProperty("highlyStructuredMessage")) {
                if (properties.title === 1)
                    return "title: multiple values";
                properties.title = 1;
                {
                    var error = $root.Message.HighlyStructuredMessage.verify(message.highlyStructuredMessage);
                    if (error)
                        return "highlyStructuredMessage." + error;
                }
            }
            if (message.imageMessage != null && message.hasOwnProperty("imageMessage")) {
                if (properties.title === 1)
                    return "title: multiple values";
                properties.title = 1;
                {
                    var error = $root.Message.ImageMessage.verify(message.imageMessage);
                    if (error)
                        return "imageMessage." + error;
                }
            }
            if (message.videoMessage != null && message.hasOwnProperty("videoMessage")) {
                if (properties.title === 1)
                    return "title: multiple values";
                properties.title = 1;
                {
                    var error = $root.Message.VideoMessage.verify(message.videoMessage);
                    if (error)
                        return "videoMessage." + error;
                }
            }
            if (message.locationMessage != null && message.hasOwnProperty("locationMessage")) {
                if (properties.title === 1)
                    return "title: multiple values";
                properties.title = 1;
                {
                    var error = $root.Message.LocationMessage.verify(message.locationMessage);
                    if (error)
                        return "locationMessage." + error;
                }
            }
            return null;
        };

        /**
         * Creates a FourRowTemplate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.FourRowTemplate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.FourRowTemplate} FourRowTemplate
         */
        FourRowTemplate.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.FourRowTemplate)
                return object;
            var message = new $root.Message.FourRowTemplate();
            if (object.content != null) {
                if (typeof object.content !== "object")
                    throw TypeError(".Message.FourRowTemplate.content: object expected");
                message.content = $root.Message.HighlyStructuredMessage.fromObject(object.content);
            }
            if (object.footer != null) {
                if (typeof object.footer !== "object")
                    throw TypeError(".Message.FourRowTemplate.footer: object expected");
                message.footer = $root.Message.HighlyStructuredMessage.fromObject(object.footer);
            }
            if (object.buttons) {
                if (!Array.isArray(object.buttons))
                    throw TypeError(".Message.FourRowTemplate.buttons: array expected");
                message.buttons = [];
                for (var i = 0; i < object.buttons.length; ++i) {
                    if (typeof object.buttons[i] !== "object")
                        throw TypeError(".Message.FourRowTemplate.buttons: object expected");
                    message.buttons[i] = $root.Message.TemplateButton.fromObject(object.buttons[i]);
                }
            }
            if (object.documentMessage != null) {
                if (typeof object.documentMessage !== "object")
                    throw TypeError(".Message.FourRowTemplate.documentMessage: object expected");
                message.documentMessage = $root.Message.DocumentMessage.fromObject(object.documentMessage);
            }
            if (object.highlyStructuredMessage != null) {
                if (typeof object.highlyStructuredMessage !== "object")
                    throw TypeError(".Message.FourRowTemplate.highlyStructuredMessage: object expected");
                message.highlyStructuredMessage = $root.Message.HighlyStructuredMessage.fromObject(object.highlyStructuredMessage);
            }
            if (object.imageMessage != null) {
                if (typeof object.imageMessage !== "object")
                    throw TypeError(".Message.FourRowTemplate.imageMessage: object expected");
                message.imageMessage = $root.Message.ImageMessage.fromObject(object.imageMessage);
            }
            if (object.videoMessage != null) {
                if (typeof object.videoMessage !== "object")
                    throw TypeError(".Message.FourRowTemplate.videoMessage: object expected");
                message.videoMessage = $root.Message.VideoMessage.fromObject(object.videoMessage);
            }
            if (object.locationMessage != null) {
                if (typeof object.locationMessage !== "object")
                    throw TypeError(".Message.FourRowTemplate.locationMessage: object expected");
                message.locationMessage = $root.Message.LocationMessage.fromObject(object.locationMessage);
            }
            return message;
        };

        /**
         * Creates a plain object from a FourRowTemplate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.FourRowTemplate
         * @static
         * @param {Message.FourRowTemplate} message FourRowTemplate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FourRowTemplate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.buttons = [];
            if (options.defaults) {
                object.content = null;
                object.footer = null;
            }
            if (message.documentMessage != null && message.hasOwnProperty("documentMessage")) {
                object.documentMessage = $root.Message.DocumentMessage.toObject(message.documentMessage, options);
                if (options.oneofs)
                    object.title = "documentMessage";
            }
            if (message.highlyStructuredMessage != null && message.hasOwnProperty("highlyStructuredMessage")) {
                object.highlyStructuredMessage = $root.Message.HighlyStructuredMessage.toObject(message.highlyStructuredMessage, options);
                if (options.oneofs)
                    object.title = "highlyStructuredMessage";
            }
            if (message.imageMessage != null && message.hasOwnProperty("imageMessage")) {
                object.imageMessage = $root.Message.ImageMessage.toObject(message.imageMessage, options);
                if (options.oneofs)
                    object.title = "imageMessage";
            }
            if (message.videoMessage != null && message.hasOwnProperty("videoMessage")) {
                object.videoMessage = $root.Message.VideoMessage.toObject(message.videoMessage, options);
                if (options.oneofs)
                    object.title = "videoMessage";
            }
            if (message.locationMessage != null && message.hasOwnProperty("locationMessage")) {
                object.locationMessage = $root.Message.LocationMessage.toObject(message.locationMessage, options);
                if (options.oneofs)
                    object.title = "locationMessage";
            }
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = $root.Message.HighlyStructuredMessage.toObject(message.content, options);
            if (message.footer != null && message.hasOwnProperty("footer"))
                object.footer = $root.Message.HighlyStructuredMessage.toObject(message.footer, options);
            if (message.buttons && message.buttons.length) {
                object.buttons = [];
                for (var j = 0; j < message.buttons.length; ++j)
                    object.buttons[j] = $root.Message.TemplateButton.toObject(message.buttons[j], options);
            }
            return object;
        };

        /**
         * Converts this FourRowTemplate to JSON.
         * @function toJSON
         * @memberof Message.FourRowTemplate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FourRowTemplate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FourRowTemplate;
    })();

    Message.HydratedFourRowTemplate = (function() {

        /**
         * Properties of a HydratedFourRowTemplate.
         * @memberof Message
         * @interface IHydratedFourRowTemplate
         * @property {string|null} [hydratedContentText] HydratedFourRowTemplate hydratedContentText
         * @property {string|null} [hydratedFooterText] HydratedFourRowTemplate hydratedFooterText
         * @property {Array.<Message.IHydratedTemplateButton>|null} [hydratedButtons] HydratedFourRowTemplate hydratedButtons
         * @property {string|null} [templateId] HydratedFourRowTemplate templateId
         * @property {Message.IDocumentMessage|null} [documentMessage] HydratedFourRowTemplate documentMessage
         * @property {string|null} [hydratedTitleText] HydratedFourRowTemplate hydratedTitleText
         * @property {Message.IImageMessage|null} [imageMessage] HydratedFourRowTemplate imageMessage
         * @property {Message.IVideoMessage|null} [videoMessage] HydratedFourRowTemplate videoMessage
         * @property {Message.ILocationMessage|null} [locationMessage] HydratedFourRowTemplate locationMessage
         */

        /**
         * Constructs a new HydratedFourRowTemplate.
         * @memberof Message
         * @classdesc Represents a HydratedFourRowTemplate.
         * @implements IHydratedFourRowTemplate
         * @constructor
         * @param {Message.IHydratedFourRowTemplate=} [properties] Properties to set
         */
        function HydratedFourRowTemplate(properties) {
            this.hydratedButtons = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HydratedFourRowTemplate hydratedContentText.
         * @member {string} hydratedContentText
         * @memberof Message.HydratedFourRowTemplate
         * @instance
         */
        HydratedFourRowTemplate.prototype.hydratedContentText = "";

        /**
         * HydratedFourRowTemplate hydratedFooterText.
         * @member {string} hydratedFooterText
         * @memberof Message.HydratedFourRowTemplate
         * @instance
         */
        HydratedFourRowTemplate.prototype.hydratedFooterText = "";

        /**
         * HydratedFourRowTemplate hydratedButtons.
         * @member {Array.<Message.IHydratedTemplateButton>} hydratedButtons
         * @memberof Message.HydratedFourRowTemplate
         * @instance
         */
        HydratedFourRowTemplate.prototype.hydratedButtons = $util.emptyArray;

        /**
         * HydratedFourRowTemplate templateId.
         * @member {string} templateId
         * @memberof Message.HydratedFourRowTemplate
         * @instance
         */
        HydratedFourRowTemplate.prototype.templateId = "";

        /**
         * HydratedFourRowTemplate documentMessage.
         * @member {Message.IDocumentMessage|null|undefined} documentMessage
         * @memberof Message.HydratedFourRowTemplate
         * @instance
         */
        HydratedFourRowTemplate.prototype.documentMessage = null;

        /**
         * HydratedFourRowTemplate hydratedTitleText.
         * @member {string|null|undefined} hydratedTitleText
         * @memberof Message.HydratedFourRowTemplate
         * @instance
         */
        HydratedFourRowTemplate.prototype.hydratedTitleText = null;

        /**
         * HydratedFourRowTemplate imageMessage.
         * @member {Message.IImageMessage|null|undefined} imageMessage
         * @memberof Message.HydratedFourRowTemplate
         * @instance
         */
        HydratedFourRowTemplate.prototype.imageMessage = null;

        /**
         * HydratedFourRowTemplate videoMessage.
         * @member {Message.IVideoMessage|null|undefined} videoMessage
         * @memberof Message.HydratedFourRowTemplate
         * @instance
         */
        HydratedFourRowTemplate.prototype.videoMessage = null;

        /**
         * HydratedFourRowTemplate locationMessage.
         * @member {Message.ILocationMessage|null|undefined} locationMessage
         * @memberof Message.HydratedFourRowTemplate
         * @instance
         */
        HydratedFourRowTemplate.prototype.locationMessage = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * HydratedFourRowTemplate title.
         * @member {"documentMessage"|"hydratedTitleText"|"imageMessage"|"videoMessage"|"locationMessage"|undefined} title
         * @memberof Message.HydratedFourRowTemplate
         * @instance
         */
        Object.defineProperty(HydratedFourRowTemplate.prototype, "title", {
            get: $util.oneOfGetter($oneOfFields = ["documentMessage", "hydratedTitleText", "imageMessage", "videoMessage", "locationMessage"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new HydratedFourRowTemplate instance using the specified properties.
         * @function create
         * @memberof Message.HydratedFourRowTemplate
         * @static
         * @param {Message.IHydratedFourRowTemplate=} [properties] Properties to set
         * @returns {Message.HydratedFourRowTemplate} HydratedFourRowTemplate instance
         */
        HydratedFourRowTemplate.create = function create(properties) {
            return new HydratedFourRowTemplate(properties);
        };

        /**
         * Encodes the specified HydratedFourRowTemplate message. Does not implicitly {@link Message.HydratedFourRowTemplate.verify|verify} messages.
         * @function encode
         * @memberof Message.HydratedFourRowTemplate
         * @static
         * @param {Message.IHydratedFourRowTemplate} message HydratedFourRowTemplate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HydratedFourRowTemplate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.documentMessage != null && Object.hasOwnProperty.call(message, "documentMessage"))
                $root.Message.DocumentMessage.encode(message.documentMessage, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.hydratedTitleText != null && Object.hasOwnProperty.call(message, "hydratedTitleText"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.hydratedTitleText);
            if (message.imageMessage != null && Object.hasOwnProperty.call(message, "imageMessage"))
                $root.Message.ImageMessage.encode(message.imageMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.videoMessage != null && Object.hasOwnProperty.call(message, "videoMessage"))
                $root.Message.VideoMessage.encode(message.videoMessage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.locationMessage != null && Object.hasOwnProperty.call(message, "locationMessage"))
                $root.Message.LocationMessage.encode(message.locationMessage, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.hydratedContentText != null && Object.hasOwnProperty.call(message, "hydratedContentText"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.hydratedContentText);
            if (message.hydratedFooterText != null && Object.hasOwnProperty.call(message, "hydratedFooterText"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.hydratedFooterText);
            if (message.hydratedButtons != null && message.hydratedButtons.length)
                for (var i = 0; i < message.hydratedButtons.length; ++i)
                    $root.Message.HydratedTemplateButton.encode(message.hydratedButtons[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.templateId != null && Object.hasOwnProperty.call(message, "templateId"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.templateId);
            return writer;
        };

        /**
         * Encodes the specified HydratedFourRowTemplate message, length delimited. Does not implicitly {@link Message.HydratedFourRowTemplate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.HydratedFourRowTemplate
         * @static
         * @param {Message.IHydratedFourRowTemplate} message HydratedFourRowTemplate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HydratedFourRowTemplate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HydratedFourRowTemplate message from the specified reader or buffer.
         * @function decode
         * @memberof Message.HydratedFourRowTemplate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.HydratedFourRowTemplate} HydratedFourRowTemplate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HydratedFourRowTemplate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.HydratedFourRowTemplate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 6:
                    message.hydratedContentText = reader.string();
                    break;
                case 7:
                    message.hydratedFooterText = reader.string();
                    break;
                case 8:
                    if (!(message.hydratedButtons && message.hydratedButtons.length))
                        message.hydratedButtons = [];
                    message.hydratedButtons.push($root.Message.HydratedTemplateButton.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.templateId = reader.string();
                    break;
                case 1:
                    message.documentMessage = $root.Message.DocumentMessage.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.hydratedTitleText = reader.string();
                    break;
                case 3:
                    message.imageMessage = $root.Message.ImageMessage.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.videoMessage = $root.Message.VideoMessage.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.locationMessage = $root.Message.LocationMessage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HydratedFourRowTemplate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.HydratedFourRowTemplate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.HydratedFourRowTemplate} HydratedFourRowTemplate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HydratedFourRowTemplate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HydratedFourRowTemplate message.
         * @function verify
         * @memberof Message.HydratedFourRowTemplate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HydratedFourRowTemplate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.hydratedContentText != null && message.hasOwnProperty("hydratedContentText"))
                if (!$util.isString(message.hydratedContentText))
                    return "hydratedContentText: string expected";
            if (message.hydratedFooterText != null && message.hasOwnProperty("hydratedFooterText"))
                if (!$util.isString(message.hydratedFooterText))
                    return "hydratedFooterText: string expected";
            if (message.hydratedButtons != null && message.hasOwnProperty("hydratedButtons")) {
                if (!Array.isArray(message.hydratedButtons))
                    return "hydratedButtons: array expected";
                for (var i = 0; i < message.hydratedButtons.length; ++i) {
                    var error = $root.Message.HydratedTemplateButton.verify(message.hydratedButtons[i]);
                    if (error)
                        return "hydratedButtons." + error;
                }
            }
            if (message.templateId != null && message.hasOwnProperty("templateId"))
                if (!$util.isString(message.templateId))
                    return "templateId: string expected";
            if (message.documentMessage != null && message.hasOwnProperty("documentMessage")) {
                properties.title = 1;
                {
                    var error = $root.Message.DocumentMessage.verify(message.documentMessage);
                    if (error)
                        return "documentMessage." + error;
                }
            }
            if (message.hydratedTitleText != null && message.hasOwnProperty("hydratedTitleText")) {
                if (properties.title === 1)
                    return "title: multiple values";
                properties.title = 1;
                if (!$util.isString(message.hydratedTitleText))
                    return "hydratedTitleText: string expected";
            }
            if (message.imageMessage != null && message.hasOwnProperty("imageMessage")) {
                if (properties.title === 1)
                    return "title: multiple values";
                properties.title = 1;
                {
                    var error = $root.Message.ImageMessage.verify(message.imageMessage);
                    if (error)
                        return "imageMessage." + error;
                }
            }
            if (message.videoMessage != null && message.hasOwnProperty("videoMessage")) {
                if (properties.title === 1)
                    return "title: multiple values";
                properties.title = 1;
                {
                    var error = $root.Message.VideoMessage.verify(message.videoMessage);
                    if (error)
                        return "videoMessage." + error;
                }
            }
            if (message.locationMessage != null && message.hasOwnProperty("locationMessage")) {
                if (properties.title === 1)
                    return "title: multiple values";
                properties.title = 1;
                {
                    var error = $root.Message.LocationMessage.verify(message.locationMessage);
                    if (error)
                        return "locationMessage." + error;
                }
            }
            return null;
        };

        /**
         * Creates a HydratedFourRowTemplate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.HydratedFourRowTemplate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.HydratedFourRowTemplate} HydratedFourRowTemplate
         */
        HydratedFourRowTemplate.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.HydratedFourRowTemplate)
                return object;
            var message = new $root.Message.HydratedFourRowTemplate();
            if (object.hydratedContentText != null)
                message.hydratedContentText = String(object.hydratedContentText);
            if (object.hydratedFooterText != null)
                message.hydratedFooterText = String(object.hydratedFooterText);
            if (object.hydratedButtons) {
                if (!Array.isArray(object.hydratedButtons))
                    throw TypeError(".Message.HydratedFourRowTemplate.hydratedButtons: array expected");
                message.hydratedButtons = [];
                for (var i = 0; i < object.hydratedButtons.length; ++i) {
                    if (typeof object.hydratedButtons[i] !== "object")
                        throw TypeError(".Message.HydratedFourRowTemplate.hydratedButtons: object expected");
                    message.hydratedButtons[i] = $root.Message.HydratedTemplateButton.fromObject(object.hydratedButtons[i]);
                }
            }
            if (object.templateId != null)
                message.templateId = String(object.templateId);
            if (object.documentMessage != null) {
                if (typeof object.documentMessage !== "object")
                    throw TypeError(".Message.HydratedFourRowTemplate.documentMessage: object expected");
                message.documentMessage = $root.Message.DocumentMessage.fromObject(object.documentMessage);
            }
            if (object.hydratedTitleText != null)
                message.hydratedTitleText = String(object.hydratedTitleText);
            if (object.imageMessage != null) {
                if (typeof object.imageMessage !== "object")
                    throw TypeError(".Message.HydratedFourRowTemplate.imageMessage: object expected");
                message.imageMessage = $root.Message.ImageMessage.fromObject(object.imageMessage);
            }
            if (object.videoMessage != null) {
                if (typeof object.videoMessage !== "object")
                    throw TypeError(".Message.HydratedFourRowTemplate.videoMessage: object expected");
                message.videoMessage = $root.Message.VideoMessage.fromObject(object.videoMessage);
            }
            if (object.locationMessage != null) {
                if (typeof object.locationMessage !== "object")
                    throw TypeError(".Message.HydratedFourRowTemplate.locationMessage: object expected");
                message.locationMessage = $root.Message.LocationMessage.fromObject(object.locationMessage);
            }
            return message;
        };

        /**
         * Creates a plain object from a HydratedFourRowTemplate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.HydratedFourRowTemplate
         * @static
         * @param {Message.HydratedFourRowTemplate} message HydratedFourRowTemplate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HydratedFourRowTemplate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.hydratedButtons = [];
            if (options.defaults) {
                object.hydratedContentText = "";
                object.hydratedFooterText = "";
                object.templateId = "";
            }
            if (message.documentMessage != null && message.hasOwnProperty("documentMessage")) {
                object.documentMessage = $root.Message.DocumentMessage.toObject(message.documentMessage, options);
                if (options.oneofs)
                    object.title = "documentMessage";
            }
            if (message.hydratedTitleText != null && message.hasOwnProperty("hydratedTitleText")) {
                object.hydratedTitleText = message.hydratedTitleText;
                if (options.oneofs)
                    object.title = "hydratedTitleText";
            }
            if (message.imageMessage != null && message.hasOwnProperty("imageMessage")) {
                object.imageMessage = $root.Message.ImageMessage.toObject(message.imageMessage, options);
                if (options.oneofs)
                    object.title = "imageMessage";
            }
            if (message.videoMessage != null && message.hasOwnProperty("videoMessage")) {
                object.videoMessage = $root.Message.VideoMessage.toObject(message.videoMessage, options);
                if (options.oneofs)
                    object.title = "videoMessage";
            }
            if (message.locationMessage != null && message.hasOwnProperty("locationMessage")) {
                object.locationMessage = $root.Message.LocationMessage.toObject(message.locationMessage, options);
                if (options.oneofs)
                    object.title = "locationMessage";
            }
            if (message.hydratedContentText != null && message.hasOwnProperty("hydratedContentText"))
                object.hydratedContentText = message.hydratedContentText;
            if (message.hydratedFooterText != null && message.hasOwnProperty("hydratedFooterText"))
                object.hydratedFooterText = message.hydratedFooterText;
            if (message.hydratedButtons && message.hydratedButtons.length) {
                object.hydratedButtons = [];
                for (var j = 0; j < message.hydratedButtons.length; ++j)
                    object.hydratedButtons[j] = $root.Message.HydratedTemplateButton.toObject(message.hydratedButtons[j], options);
            }
            if (message.templateId != null && message.hasOwnProperty("templateId"))
                object.templateId = message.templateId;
            return object;
        };

        /**
         * Converts this HydratedFourRowTemplate to JSON.
         * @function toJSON
         * @memberof Message.HydratedFourRowTemplate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HydratedFourRowTemplate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HydratedFourRowTemplate;
    })();

    Message.TemplateMessage = (function() {

        /**
         * Properties of a TemplateMessage.
         * @memberof Message
         * @interface ITemplateMessage
         * @property {Message.IContextInfo|null} [contextInfo] TemplateMessage contextInfo
         * @property {Message.IHydratedFourRowTemplate|null} [hydratedTemplate] TemplateMessage hydratedTemplate
         * @property {Message.IFourRowTemplate|null} [fourRowTemplate] TemplateMessage fourRowTemplate
         * @property {Message.IHydratedFourRowTemplate|null} [hydratedFourRowTemplate] TemplateMessage hydratedFourRowTemplate
         */

        /**
         * Constructs a new TemplateMessage.
         * @memberof Message
         * @classdesc Represents a TemplateMessage.
         * @implements ITemplateMessage
         * @constructor
         * @param {Message.ITemplateMessage=} [properties] Properties to set
         */
        function TemplateMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TemplateMessage contextInfo.
         * @member {Message.IContextInfo|null|undefined} contextInfo
         * @memberof Message.TemplateMessage
         * @instance
         */
        TemplateMessage.prototype.contextInfo = null;

        /**
         * TemplateMessage hydratedTemplate.
         * @member {Message.IHydratedFourRowTemplate|null|undefined} hydratedTemplate
         * @memberof Message.TemplateMessage
         * @instance
         */
        TemplateMessage.prototype.hydratedTemplate = null;

        /**
         * TemplateMessage fourRowTemplate.
         * @member {Message.IFourRowTemplate|null|undefined} fourRowTemplate
         * @memberof Message.TemplateMessage
         * @instance
         */
        TemplateMessage.prototype.fourRowTemplate = null;

        /**
         * TemplateMessage hydratedFourRowTemplate.
         * @member {Message.IHydratedFourRowTemplate|null|undefined} hydratedFourRowTemplate
         * @memberof Message.TemplateMessage
         * @instance
         */
        TemplateMessage.prototype.hydratedFourRowTemplate = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * TemplateMessage format.
         * @member {"fourRowTemplate"|"hydratedFourRowTemplate"|undefined} format
         * @memberof Message.TemplateMessage
         * @instance
         */
        Object.defineProperty(TemplateMessage.prototype, "format", {
            get: $util.oneOfGetter($oneOfFields = ["fourRowTemplate", "hydratedFourRowTemplate"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new TemplateMessage instance using the specified properties.
         * @function create
         * @memberof Message.TemplateMessage
         * @static
         * @param {Message.ITemplateMessage=} [properties] Properties to set
         * @returns {Message.TemplateMessage} TemplateMessage instance
         */
        TemplateMessage.create = function create(properties) {
            return new TemplateMessage(properties);
        };

        /**
         * Encodes the specified TemplateMessage message. Does not implicitly {@link Message.TemplateMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.TemplateMessage
         * @static
         * @param {Message.ITemplateMessage} message TemplateMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TemplateMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fourRowTemplate != null && Object.hasOwnProperty.call(message, "fourRowTemplate"))
                $root.Message.FourRowTemplate.encode(message.fourRowTemplate, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.hydratedFourRowTemplate != null && Object.hasOwnProperty.call(message, "hydratedFourRowTemplate"))
                $root.Message.HydratedFourRowTemplate.encode(message.hydratedFourRowTemplate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                $root.Message.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.hydratedTemplate != null && Object.hasOwnProperty.call(message, "hydratedTemplate"))
                $root.Message.HydratedFourRowTemplate.encode(message.hydratedTemplate, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TemplateMessage message, length delimited. Does not implicitly {@link Message.TemplateMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.TemplateMessage
         * @static
         * @param {Message.ITemplateMessage} message TemplateMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TemplateMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TemplateMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.TemplateMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.TemplateMessage} TemplateMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TemplateMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.TemplateMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 3:
                    message.contextInfo = $root.Message.ContextInfo.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.hydratedTemplate = $root.Message.HydratedFourRowTemplate.decode(reader, reader.uint32());
                    break;
                case 1:
                    message.fourRowTemplate = $root.Message.FourRowTemplate.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.hydratedFourRowTemplate = $root.Message.HydratedFourRowTemplate.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TemplateMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.TemplateMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.TemplateMessage} TemplateMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TemplateMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TemplateMessage message.
         * @function verify
         * @memberof Message.TemplateMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TemplateMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                var error = $root.Message.ContextInfo.verify(message.contextInfo);
                if (error)
                    return "contextInfo." + error;
            }
            if (message.hydratedTemplate != null && message.hasOwnProperty("hydratedTemplate")) {
                var error = $root.Message.HydratedFourRowTemplate.verify(message.hydratedTemplate);
                if (error)
                    return "hydratedTemplate." + error;
            }
            if (message.fourRowTemplate != null && message.hasOwnProperty("fourRowTemplate")) {
                properties.format = 1;
                {
                    var error = $root.Message.FourRowTemplate.verify(message.fourRowTemplate);
                    if (error)
                        return "fourRowTemplate." + error;
                }
            }
            if (message.hydratedFourRowTemplate != null && message.hasOwnProperty("hydratedFourRowTemplate")) {
                if (properties.format === 1)
                    return "format: multiple values";
                properties.format = 1;
                {
                    var error = $root.Message.HydratedFourRowTemplate.verify(message.hydratedFourRowTemplate);
                    if (error)
                        return "hydratedFourRowTemplate." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TemplateMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.TemplateMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.TemplateMessage} TemplateMessage
         */
        TemplateMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.TemplateMessage)
                return object;
            var message = new $root.Message.TemplateMessage();
            if (object.contextInfo != null) {
                if (typeof object.contextInfo !== "object")
                    throw TypeError(".Message.TemplateMessage.contextInfo: object expected");
                message.contextInfo = $root.Message.ContextInfo.fromObject(object.contextInfo);
            }
            if (object.hydratedTemplate != null) {
                if (typeof object.hydratedTemplate !== "object")
                    throw TypeError(".Message.TemplateMessage.hydratedTemplate: object expected");
                message.hydratedTemplate = $root.Message.HydratedFourRowTemplate.fromObject(object.hydratedTemplate);
            }
            if (object.fourRowTemplate != null) {
                if (typeof object.fourRowTemplate !== "object")
                    throw TypeError(".Message.TemplateMessage.fourRowTemplate: object expected");
                message.fourRowTemplate = $root.Message.FourRowTemplate.fromObject(object.fourRowTemplate);
            }
            if (object.hydratedFourRowTemplate != null) {
                if (typeof object.hydratedFourRowTemplate !== "object")
                    throw TypeError(".Message.TemplateMessage.hydratedFourRowTemplate: object expected");
                message.hydratedFourRowTemplate = $root.Message.HydratedFourRowTemplate.fromObject(object.hydratedFourRowTemplate);
            }
            return message;
        };

        /**
         * Creates a plain object from a TemplateMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.TemplateMessage
         * @static
         * @param {Message.TemplateMessage} message TemplateMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TemplateMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.contextInfo = null;
                object.hydratedTemplate = null;
            }
            if (message.fourRowTemplate != null && message.hasOwnProperty("fourRowTemplate")) {
                object.fourRowTemplate = $root.Message.FourRowTemplate.toObject(message.fourRowTemplate, options);
                if (options.oneofs)
                    object.format = "fourRowTemplate";
            }
            if (message.hydratedFourRowTemplate != null && message.hasOwnProperty("hydratedFourRowTemplate")) {
                object.hydratedFourRowTemplate = $root.Message.HydratedFourRowTemplate.toObject(message.hydratedFourRowTemplate, options);
                if (options.oneofs)
                    object.format = "hydratedFourRowTemplate";
            }
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                object.contextInfo = $root.Message.ContextInfo.toObject(message.contextInfo, options);
            if (message.hydratedTemplate != null && message.hasOwnProperty("hydratedTemplate"))
                object.hydratedTemplate = $root.Message.HydratedFourRowTemplate.toObject(message.hydratedTemplate, options);
            return object;
        };

        /**
         * Converts this TemplateMessage to JSON.
         * @function toJSON
         * @memberof Message.TemplateMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TemplateMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TemplateMessage;
    })();

    Message.TemplateButtonReplyMessage = (function() {

        /**
         * Properties of a TemplateButtonReplyMessage.
         * @memberof Message
         * @interface ITemplateButtonReplyMessage
         * @property {string|null} [selectedId] TemplateButtonReplyMessage selectedId
         * @property {string|null} [selectedDisplayText] TemplateButtonReplyMessage selectedDisplayText
         * @property {Message.IContextInfo|null} [contextInfo] TemplateButtonReplyMessage contextInfo
         * @property {number|null} [selectedIndex] TemplateButtonReplyMessage selectedIndex
         */

        /**
         * Constructs a new TemplateButtonReplyMessage.
         * @memberof Message
         * @classdesc Represents a TemplateButtonReplyMessage.
         * @implements ITemplateButtonReplyMessage
         * @constructor
         * @param {Message.ITemplateButtonReplyMessage=} [properties] Properties to set
         */
        function TemplateButtonReplyMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TemplateButtonReplyMessage selectedId.
         * @member {string} selectedId
         * @memberof Message.TemplateButtonReplyMessage
         * @instance
         */
        TemplateButtonReplyMessage.prototype.selectedId = "";

        /**
         * TemplateButtonReplyMessage selectedDisplayText.
         * @member {string} selectedDisplayText
         * @memberof Message.TemplateButtonReplyMessage
         * @instance
         */
        TemplateButtonReplyMessage.prototype.selectedDisplayText = "";

        /**
         * TemplateButtonReplyMessage contextInfo.
         * @member {Message.IContextInfo|null|undefined} contextInfo
         * @memberof Message.TemplateButtonReplyMessage
         * @instance
         */
        TemplateButtonReplyMessage.prototype.contextInfo = null;

        /**
         * TemplateButtonReplyMessage selectedIndex.
         * @member {number} selectedIndex
         * @memberof Message.TemplateButtonReplyMessage
         * @instance
         */
        TemplateButtonReplyMessage.prototype.selectedIndex = 0;

        /**
         * Creates a new TemplateButtonReplyMessage instance using the specified properties.
         * @function create
         * @memberof Message.TemplateButtonReplyMessage
         * @static
         * @param {Message.ITemplateButtonReplyMessage=} [properties] Properties to set
         * @returns {Message.TemplateButtonReplyMessage} TemplateButtonReplyMessage instance
         */
        TemplateButtonReplyMessage.create = function create(properties) {
            return new TemplateButtonReplyMessage(properties);
        };

        /**
         * Encodes the specified TemplateButtonReplyMessage message. Does not implicitly {@link Message.TemplateButtonReplyMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.TemplateButtonReplyMessage
         * @static
         * @param {Message.ITemplateButtonReplyMessage} message TemplateButtonReplyMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TemplateButtonReplyMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.selectedId != null && Object.hasOwnProperty.call(message, "selectedId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.selectedId);
            if (message.selectedDisplayText != null && Object.hasOwnProperty.call(message, "selectedDisplayText"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.selectedDisplayText);
            if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                $root.Message.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.selectedIndex != null && Object.hasOwnProperty.call(message, "selectedIndex"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.selectedIndex);
            return writer;
        };

        /**
         * Encodes the specified TemplateButtonReplyMessage message, length delimited. Does not implicitly {@link Message.TemplateButtonReplyMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.TemplateButtonReplyMessage
         * @static
         * @param {Message.ITemplateButtonReplyMessage} message TemplateButtonReplyMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TemplateButtonReplyMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TemplateButtonReplyMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.TemplateButtonReplyMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.TemplateButtonReplyMessage} TemplateButtonReplyMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TemplateButtonReplyMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.TemplateButtonReplyMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.selectedId = reader.string();
                    break;
                case 2:
                    message.selectedDisplayText = reader.string();
                    break;
                case 3:
                    message.contextInfo = $root.Message.ContextInfo.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.selectedIndex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TemplateButtonReplyMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.TemplateButtonReplyMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.TemplateButtonReplyMessage} TemplateButtonReplyMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TemplateButtonReplyMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TemplateButtonReplyMessage message.
         * @function verify
         * @memberof Message.TemplateButtonReplyMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TemplateButtonReplyMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.selectedId != null && message.hasOwnProperty("selectedId"))
                if (!$util.isString(message.selectedId))
                    return "selectedId: string expected";
            if (message.selectedDisplayText != null && message.hasOwnProperty("selectedDisplayText"))
                if (!$util.isString(message.selectedDisplayText))
                    return "selectedDisplayText: string expected";
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                var error = $root.Message.ContextInfo.verify(message.contextInfo);
                if (error)
                    return "contextInfo." + error;
            }
            if (message.selectedIndex != null && message.hasOwnProperty("selectedIndex"))
                if (!$util.isInteger(message.selectedIndex))
                    return "selectedIndex: integer expected";
            return null;
        };

        /**
         * Creates a TemplateButtonReplyMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.TemplateButtonReplyMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.TemplateButtonReplyMessage} TemplateButtonReplyMessage
         */
        TemplateButtonReplyMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.TemplateButtonReplyMessage)
                return object;
            var message = new $root.Message.TemplateButtonReplyMessage();
            if (object.selectedId != null)
                message.selectedId = String(object.selectedId);
            if (object.selectedDisplayText != null)
                message.selectedDisplayText = String(object.selectedDisplayText);
            if (object.contextInfo != null) {
                if (typeof object.contextInfo !== "object")
                    throw TypeError(".Message.TemplateButtonReplyMessage.contextInfo: object expected");
                message.contextInfo = $root.Message.ContextInfo.fromObject(object.contextInfo);
            }
            if (object.selectedIndex != null)
                message.selectedIndex = object.selectedIndex >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a TemplateButtonReplyMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.TemplateButtonReplyMessage
         * @static
         * @param {Message.TemplateButtonReplyMessage} message TemplateButtonReplyMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TemplateButtonReplyMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.selectedId = "";
                object.selectedDisplayText = "";
                object.contextInfo = null;
                object.selectedIndex = 0;
            }
            if (message.selectedId != null && message.hasOwnProperty("selectedId"))
                object.selectedId = message.selectedId;
            if (message.selectedDisplayText != null && message.hasOwnProperty("selectedDisplayText"))
                object.selectedDisplayText = message.selectedDisplayText;
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                object.contextInfo = $root.Message.ContextInfo.toObject(message.contextInfo, options);
            if (message.selectedIndex != null && message.hasOwnProperty("selectedIndex"))
                object.selectedIndex = message.selectedIndex;
            return object;
        };

        /**
         * Converts this TemplateButtonReplyMessage to JSON.
         * @function toJSON
         * @memberof Message.TemplateButtonReplyMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TemplateButtonReplyMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TemplateButtonReplyMessage;
    })();

    Message.CatalogSnapshot = (function() {

        /**
         * Properties of a CatalogSnapshot.
         * @memberof Message
         * @interface ICatalogSnapshot
         * @property {Message.IImageMessage|null} [catalogImage] CatalogSnapshot catalogImage
         * @property {string|null} [title] CatalogSnapshot title
         * @property {string|null} [description] CatalogSnapshot description
         */

        /**
         * Constructs a new CatalogSnapshot.
         * @memberof Message
         * @classdesc Represents a CatalogSnapshot.
         * @implements ICatalogSnapshot
         * @constructor
         * @param {Message.ICatalogSnapshot=} [properties] Properties to set
         */
        function CatalogSnapshot(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CatalogSnapshot catalogImage.
         * @member {Message.IImageMessage|null|undefined} catalogImage
         * @memberof Message.CatalogSnapshot
         * @instance
         */
        CatalogSnapshot.prototype.catalogImage = null;

        /**
         * CatalogSnapshot title.
         * @member {string} title
         * @memberof Message.CatalogSnapshot
         * @instance
         */
        CatalogSnapshot.prototype.title = "";

        /**
         * CatalogSnapshot description.
         * @member {string} description
         * @memberof Message.CatalogSnapshot
         * @instance
         */
        CatalogSnapshot.prototype.description = "";

        /**
         * Creates a new CatalogSnapshot instance using the specified properties.
         * @function create
         * @memberof Message.CatalogSnapshot
         * @static
         * @param {Message.ICatalogSnapshot=} [properties] Properties to set
         * @returns {Message.CatalogSnapshot} CatalogSnapshot instance
         */
        CatalogSnapshot.create = function create(properties) {
            return new CatalogSnapshot(properties);
        };

        /**
         * Encodes the specified CatalogSnapshot message. Does not implicitly {@link Message.CatalogSnapshot.verify|verify} messages.
         * @function encode
         * @memberof Message.CatalogSnapshot
         * @static
         * @param {Message.ICatalogSnapshot} message CatalogSnapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CatalogSnapshot.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.catalogImage != null && Object.hasOwnProperty.call(message, "catalogImage"))
                $root.Message.ImageMessage.encode(message.catalogImage, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.description);
            return writer;
        };

        /**
         * Encodes the specified CatalogSnapshot message, length delimited. Does not implicitly {@link Message.CatalogSnapshot.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.CatalogSnapshot
         * @static
         * @param {Message.ICatalogSnapshot} message CatalogSnapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CatalogSnapshot.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CatalogSnapshot message from the specified reader or buffer.
         * @function decode
         * @memberof Message.CatalogSnapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.CatalogSnapshot} CatalogSnapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CatalogSnapshot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.CatalogSnapshot();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.catalogImage = $root.Message.ImageMessage.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.title = reader.string();
                    break;
                case 3:
                    message.description = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CatalogSnapshot message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.CatalogSnapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.CatalogSnapshot} CatalogSnapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CatalogSnapshot.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CatalogSnapshot message.
         * @function verify
         * @memberof Message.CatalogSnapshot
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CatalogSnapshot.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.catalogImage != null && message.hasOwnProperty("catalogImage")) {
                var error = $root.Message.ImageMessage.verify(message.catalogImage);
                if (error)
                    return "catalogImage." + error;
            }
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            return null;
        };

        /**
         * Creates a CatalogSnapshot message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.CatalogSnapshot
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.CatalogSnapshot} CatalogSnapshot
         */
        CatalogSnapshot.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.CatalogSnapshot)
                return object;
            var message = new $root.Message.CatalogSnapshot();
            if (object.catalogImage != null) {
                if (typeof object.catalogImage !== "object")
                    throw TypeError(".Message.CatalogSnapshot.catalogImage: object expected");
                message.catalogImage = $root.Message.ImageMessage.fromObject(object.catalogImage);
            }
            if (object.title != null)
                message.title = String(object.title);
            if (object.description != null)
                message.description = String(object.description);
            return message;
        };

        /**
         * Creates a plain object from a CatalogSnapshot message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.CatalogSnapshot
         * @static
         * @param {Message.CatalogSnapshot} message CatalogSnapshot
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CatalogSnapshot.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.catalogImage = null;
                object.title = "";
                object.description = "";
            }
            if (message.catalogImage != null && message.hasOwnProperty("catalogImage"))
                object.catalogImage = $root.Message.ImageMessage.toObject(message.catalogImage, options);
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            return object;
        };

        /**
         * Converts this CatalogSnapshot to JSON.
         * @function toJSON
         * @memberof Message.CatalogSnapshot
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CatalogSnapshot.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CatalogSnapshot;
    })();

    Message.ProductSnapshot = (function() {

        /**
         * Properties of a ProductSnapshot.
         * @memberof Message
         * @interface IProductSnapshot
         * @property {Message.IImageMessage|null} [productImage] ProductSnapshot productImage
         * @property {string|null} [productId] ProductSnapshot productId
         * @property {string|null} [title] ProductSnapshot title
         * @property {string|null} [description] ProductSnapshot description
         * @property {string|null} [currencyCode] ProductSnapshot currencyCode
         * @property {number|Long|null} [priceAmount1000] ProductSnapshot priceAmount1000
         * @property {string|null} [retailerId] ProductSnapshot retailerId
         * @property {string|null} [url] ProductSnapshot url
         * @property {number|null} [productImageCount] ProductSnapshot productImageCount
         * @property {string|null} [firstImageId] ProductSnapshot firstImageId
         */

        /**
         * Constructs a new ProductSnapshot.
         * @memberof Message
         * @classdesc Represents a ProductSnapshot.
         * @implements IProductSnapshot
         * @constructor
         * @param {Message.IProductSnapshot=} [properties] Properties to set
         */
        function ProductSnapshot(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProductSnapshot productImage.
         * @member {Message.IImageMessage|null|undefined} productImage
         * @memberof Message.ProductSnapshot
         * @instance
         */
        ProductSnapshot.prototype.productImage = null;

        /**
         * ProductSnapshot productId.
         * @member {string} productId
         * @memberof Message.ProductSnapshot
         * @instance
         */
        ProductSnapshot.prototype.productId = "";

        /**
         * ProductSnapshot title.
         * @member {string} title
         * @memberof Message.ProductSnapshot
         * @instance
         */
        ProductSnapshot.prototype.title = "";

        /**
         * ProductSnapshot description.
         * @member {string} description
         * @memberof Message.ProductSnapshot
         * @instance
         */
        ProductSnapshot.prototype.description = "";

        /**
         * ProductSnapshot currencyCode.
         * @member {string} currencyCode
         * @memberof Message.ProductSnapshot
         * @instance
         */
        ProductSnapshot.prototype.currencyCode = "";

        /**
         * ProductSnapshot priceAmount1000.
         * @member {number|Long} priceAmount1000
         * @memberof Message.ProductSnapshot
         * @instance
         */
        ProductSnapshot.prototype.priceAmount1000 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ProductSnapshot retailerId.
         * @member {string} retailerId
         * @memberof Message.ProductSnapshot
         * @instance
         */
        ProductSnapshot.prototype.retailerId = "";

        /**
         * ProductSnapshot url.
         * @member {string} url
         * @memberof Message.ProductSnapshot
         * @instance
         */
        ProductSnapshot.prototype.url = "";

        /**
         * ProductSnapshot productImageCount.
         * @member {number} productImageCount
         * @memberof Message.ProductSnapshot
         * @instance
         */
        ProductSnapshot.prototype.productImageCount = 0;

        /**
         * ProductSnapshot firstImageId.
         * @member {string} firstImageId
         * @memberof Message.ProductSnapshot
         * @instance
         */
        ProductSnapshot.prototype.firstImageId = "";

        /**
         * Creates a new ProductSnapshot instance using the specified properties.
         * @function create
         * @memberof Message.ProductSnapshot
         * @static
         * @param {Message.IProductSnapshot=} [properties] Properties to set
         * @returns {Message.ProductSnapshot} ProductSnapshot instance
         */
        ProductSnapshot.create = function create(properties) {
            return new ProductSnapshot(properties);
        };

        /**
         * Encodes the specified ProductSnapshot message. Does not implicitly {@link Message.ProductSnapshot.verify|verify} messages.
         * @function encode
         * @memberof Message.ProductSnapshot
         * @static
         * @param {Message.IProductSnapshot} message ProductSnapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProductSnapshot.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.productImage != null && Object.hasOwnProperty.call(message, "productImage"))
                $root.Message.ImageMessage.encode(message.productImage, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.productId != null && Object.hasOwnProperty.call(message, "productId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.productId);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.title);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
            if (message.currencyCode != null && Object.hasOwnProperty.call(message, "currencyCode"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.currencyCode);
            if (message.priceAmount1000 != null && Object.hasOwnProperty.call(message, "priceAmount1000"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.priceAmount1000);
            if (message.retailerId != null && Object.hasOwnProperty.call(message, "retailerId"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.retailerId);
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.url);
            if (message.productImageCount != null && Object.hasOwnProperty.call(message, "productImageCount"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.productImageCount);
            if (message.firstImageId != null && Object.hasOwnProperty.call(message, "firstImageId"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.firstImageId);
            return writer;
        };

        /**
         * Encodes the specified ProductSnapshot message, length delimited. Does not implicitly {@link Message.ProductSnapshot.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.ProductSnapshot
         * @static
         * @param {Message.IProductSnapshot} message ProductSnapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProductSnapshot.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProductSnapshot message from the specified reader or buffer.
         * @function decode
         * @memberof Message.ProductSnapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.ProductSnapshot} ProductSnapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProductSnapshot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.ProductSnapshot();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.productImage = $root.Message.ImageMessage.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.productId = reader.string();
                    break;
                case 3:
                    message.title = reader.string();
                    break;
                case 4:
                    message.description = reader.string();
                    break;
                case 5:
                    message.currencyCode = reader.string();
                    break;
                case 6:
                    message.priceAmount1000 = reader.int64();
                    break;
                case 7:
                    message.retailerId = reader.string();
                    break;
                case 8:
                    message.url = reader.string();
                    break;
                case 9:
                    message.productImageCount = reader.uint32();
                    break;
                case 11:
                    message.firstImageId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProductSnapshot message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.ProductSnapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.ProductSnapshot} ProductSnapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProductSnapshot.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProductSnapshot message.
         * @function verify
         * @memberof Message.ProductSnapshot
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProductSnapshot.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.productImage != null && message.hasOwnProperty("productImage")) {
                var error = $root.Message.ImageMessage.verify(message.productImage);
                if (error)
                    return "productImage." + error;
            }
            if (message.productId != null && message.hasOwnProperty("productId"))
                if (!$util.isString(message.productId))
                    return "productId: string expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
                if (!$util.isString(message.currencyCode))
                    return "currencyCode: string expected";
            if (message.priceAmount1000 != null && message.hasOwnProperty("priceAmount1000"))
                if (!$util.isInteger(message.priceAmount1000) && !(message.priceAmount1000 && $util.isInteger(message.priceAmount1000.low) && $util.isInteger(message.priceAmount1000.high)))
                    return "priceAmount1000: integer|Long expected";
            if (message.retailerId != null && message.hasOwnProperty("retailerId"))
                if (!$util.isString(message.retailerId))
                    return "retailerId: string expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.productImageCount != null && message.hasOwnProperty("productImageCount"))
                if (!$util.isInteger(message.productImageCount))
                    return "productImageCount: integer expected";
            if (message.firstImageId != null && message.hasOwnProperty("firstImageId"))
                if (!$util.isString(message.firstImageId))
                    return "firstImageId: string expected";
            return null;
        };

        /**
         * Creates a ProductSnapshot message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.ProductSnapshot
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.ProductSnapshot} ProductSnapshot
         */
        ProductSnapshot.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.ProductSnapshot)
                return object;
            var message = new $root.Message.ProductSnapshot();
            if (object.productImage != null) {
                if (typeof object.productImage !== "object")
                    throw TypeError(".Message.ProductSnapshot.productImage: object expected");
                message.productImage = $root.Message.ImageMessage.fromObject(object.productImage);
            }
            if (object.productId != null)
                message.productId = String(object.productId);
            if (object.title != null)
                message.title = String(object.title);
            if (object.description != null)
                message.description = String(object.description);
            if (object.currencyCode != null)
                message.currencyCode = String(object.currencyCode);
            if (object.priceAmount1000 != null)
                if ($util.Long)
                    (message.priceAmount1000 = $util.Long.fromValue(object.priceAmount1000)).unsigned = false;
                else if (typeof object.priceAmount1000 === "string")
                    message.priceAmount1000 = parseInt(object.priceAmount1000, 10);
                else if (typeof object.priceAmount1000 === "number")
                    message.priceAmount1000 = object.priceAmount1000;
                else if (typeof object.priceAmount1000 === "object")
                    message.priceAmount1000 = new $util.LongBits(object.priceAmount1000.low >>> 0, object.priceAmount1000.high >>> 0).toNumber();
            if (object.retailerId != null)
                message.retailerId = String(object.retailerId);
            if (object.url != null)
                message.url = String(object.url);
            if (object.productImageCount != null)
                message.productImageCount = object.productImageCount >>> 0;
            if (object.firstImageId != null)
                message.firstImageId = String(object.firstImageId);
            return message;
        };

        /**
         * Creates a plain object from a ProductSnapshot message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.ProductSnapshot
         * @static
         * @param {Message.ProductSnapshot} message ProductSnapshot
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProductSnapshot.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.productImage = null;
                object.productId = "";
                object.title = "";
                object.description = "";
                object.currencyCode = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.priceAmount1000 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.priceAmount1000 = options.longs === String ? "0" : 0;
                object.retailerId = "";
                object.url = "";
                object.productImageCount = 0;
                object.firstImageId = "";
            }
            if (message.productImage != null && message.hasOwnProperty("productImage"))
                object.productImage = $root.Message.ImageMessage.toObject(message.productImage, options);
            if (message.productId != null && message.hasOwnProperty("productId"))
                object.productId = message.productId;
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.currencyCode != null && message.hasOwnProperty("currencyCode"))
                object.currencyCode = message.currencyCode;
            if (message.priceAmount1000 != null && message.hasOwnProperty("priceAmount1000"))
                if (typeof message.priceAmount1000 === "number")
                    object.priceAmount1000 = options.longs === String ? String(message.priceAmount1000) : message.priceAmount1000;
                else
                    object.priceAmount1000 = options.longs === String ? $util.Long.prototype.toString.call(message.priceAmount1000) : options.longs === Number ? new $util.LongBits(message.priceAmount1000.low >>> 0, message.priceAmount1000.high >>> 0).toNumber() : message.priceAmount1000;
            if (message.retailerId != null && message.hasOwnProperty("retailerId"))
                object.retailerId = message.retailerId;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.productImageCount != null && message.hasOwnProperty("productImageCount"))
                object.productImageCount = message.productImageCount;
            if (message.firstImageId != null && message.hasOwnProperty("firstImageId"))
                object.firstImageId = message.firstImageId;
            return object;
        };

        /**
         * Converts this ProductSnapshot to JSON.
         * @function toJSON
         * @memberof Message.ProductSnapshot
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProductSnapshot.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProductSnapshot;
    })();

    Message.ProductMessage = (function() {

        /**
         * Properties of a ProductMessage.
         * @memberof Message
         * @interface IProductMessage
         * @property {Message.IProductSnapshot|null} [product] ProductMessage product
         * @property {string|null} [businessOwnerJid] ProductMessage businessOwnerJid
         * @property {Message.ICatalogSnapshot|null} [catalog] ProductMessage catalog
         * @property {Message.IContextInfo|null} [contextInfo] ProductMessage contextInfo
         */

        /**
         * Constructs a new ProductMessage.
         * @memberof Message
         * @classdesc Represents a ProductMessage.
         * @implements IProductMessage
         * @constructor
         * @param {Message.IProductMessage=} [properties] Properties to set
         */
        function ProductMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProductMessage product.
         * @member {Message.IProductSnapshot|null|undefined} product
         * @memberof Message.ProductMessage
         * @instance
         */
        ProductMessage.prototype.product = null;

        /**
         * ProductMessage businessOwnerJid.
         * @member {string} businessOwnerJid
         * @memberof Message.ProductMessage
         * @instance
         */
        ProductMessage.prototype.businessOwnerJid = "";

        /**
         * ProductMessage catalog.
         * @member {Message.ICatalogSnapshot|null|undefined} catalog
         * @memberof Message.ProductMessage
         * @instance
         */
        ProductMessage.prototype.catalog = null;

        /**
         * ProductMessage contextInfo.
         * @member {Message.IContextInfo|null|undefined} contextInfo
         * @memberof Message.ProductMessage
         * @instance
         */
        ProductMessage.prototype.contextInfo = null;

        /**
         * Creates a new ProductMessage instance using the specified properties.
         * @function create
         * @memberof Message.ProductMessage
         * @static
         * @param {Message.IProductMessage=} [properties] Properties to set
         * @returns {Message.ProductMessage} ProductMessage instance
         */
        ProductMessage.create = function create(properties) {
            return new ProductMessage(properties);
        };

        /**
         * Encodes the specified ProductMessage message. Does not implicitly {@link Message.ProductMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.ProductMessage
         * @static
         * @param {Message.IProductMessage} message ProductMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProductMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.product != null && Object.hasOwnProperty.call(message, "product"))
                $root.Message.ProductSnapshot.encode(message.product, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.businessOwnerJid != null && Object.hasOwnProperty.call(message, "businessOwnerJid"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.businessOwnerJid);
            if (message.catalog != null && Object.hasOwnProperty.call(message, "catalog"))
                $root.Message.CatalogSnapshot.encode(message.catalog, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                $root.Message.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ProductMessage message, length delimited. Does not implicitly {@link Message.ProductMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.ProductMessage
         * @static
         * @param {Message.IProductMessage} message ProductMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProductMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProductMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.ProductMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.ProductMessage} ProductMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProductMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.ProductMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.product = $root.Message.ProductSnapshot.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.businessOwnerJid = reader.string();
                    break;
                case 4:
                    message.catalog = $root.Message.CatalogSnapshot.decode(reader, reader.uint32());
                    break;
                case 17:
                    message.contextInfo = $root.Message.ContextInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProductMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.ProductMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.ProductMessage} ProductMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProductMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProductMessage message.
         * @function verify
         * @memberof Message.ProductMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProductMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.product != null && message.hasOwnProperty("product")) {
                var error = $root.Message.ProductSnapshot.verify(message.product);
                if (error)
                    return "product." + error;
            }
            if (message.businessOwnerJid != null && message.hasOwnProperty("businessOwnerJid"))
                if (!$util.isString(message.businessOwnerJid))
                    return "businessOwnerJid: string expected";
            if (message.catalog != null && message.hasOwnProperty("catalog")) {
                var error = $root.Message.CatalogSnapshot.verify(message.catalog);
                if (error)
                    return "catalog." + error;
            }
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                var error = $root.Message.ContextInfo.verify(message.contextInfo);
                if (error)
                    return "contextInfo." + error;
            }
            return null;
        };

        /**
         * Creates a ProductMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.ProductMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.ProductMessage} ProductMessage
         */
        ProductMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.ProductMessage)
                return object;
            var message = new $root.Message.ProductMessage();
            if (object.product != null) {
                if (typeof object.product !== "object")
                    throw TypeError(".Message.ProductMessage.product: object expected");
                message.product = $root.Message.ProductSnapshot.fromObject(object.product);
            }
            if (object.businessOwnerJid != null)
                message.businessOwnerJid = String(object.businessOwnerJid);
            if (object.catalog != null) {
                if (typeof object.catalog !== "object")
                    throw TypeError(".Message.ProductMessage.catalog: object expected");
                message.catalog = $root.Message.CatalogSnapshot.fromObject(object.catalog);
            }
            if (object.contextInfo != null) {
                if (typeof object.contextInfo !== "object")
                    throw TypeError(".Message.ProductMessage.contextInfo: object expected");
                message.contextInfo = $root.Message.ContextInfo.fromObject(object.contextInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a ProductMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.ProductMessage
         * @static
         * @param {Message.ProductMessage} message ProductMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProductMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.product = null;
                object.businessOwnerJid = "";
                object.catalog = null;
                object.contextInfo = null;
            }
            if (message.product != null && message.hasOwnProperty("product"))
                object.product = $root.Message.ProductSnapshot.toObject(message.product, options);
            if (message.businessOwnerJid != null && message.hasOwnProperty("businessOwnerJid"))
                object.businessOwnerJid = message.businessOwnerJid;
            if (message.catalog != null && message.hasOwnProperty("catalog"))
                object.catalog = $root.Message.CatalogSnapshot.toObject(message.catalog, options);
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                object.contextInfo = $root.Message.ContextInfo.toObject(message.contextInfo, options);
            return object;
        };

        /**
         * Converts this ProductMessage to JSON.
         * @function toJSON
         * @memberof Message.ProductMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProductMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProductMessage;
    })();

    Message.GroupInviteMessage = (function() {

        /**
         * Properties of a GroupInviteMessage.
         * @memberof Message
         * @interface IGroupInviteMessage
         * @property {string|null} [groupJid] GroupInviteMessage groupJid
         * @property {string|null} [inviteCode] GroupInviteMessage inviteCode
         * @property {number|Long|null} [inviteExpiration] GroupInviteMessage inviteExpiration
         * @property {string|null} [groupName] GroupInviteMessage groupName
         * @property {Uint8Array|null} [jpegThumbnail] GroupInviteMessage jpegThumbnail
         * @property {string|null} [caption] GroupInviteMessage caption
         * @property {Message.IContextInfo|null} [contextInfo] GroupInviteMessage contextInfo
         */

        /**
         * Constructs a new GroupInviteMessage.
         * @memberof Message
         * @classdesc Represents a GroupInviteMessage.
         * @implements IGroupInviteMessage
         * @constructor
         * @param {Message.IGroupInviteMessage=} [properties] Properties to set
         */
        function GroupInviteMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroupInviteMessage groupJid.
         * @member {string} groupJid
         * @memberof Message.GroupInviteMessage
         * @instance
         */
        GroupInviteMessage.prototype.groupJid = "";

        /**
         * GroupInviteMessage inviteCode.
         * @member {string} inviteCode
         * @memberof Message.GroupInviteMessage
         * @instance
         */
        GroupInviteMessage.prototype.inviteCode = "";

        /**
         * GroupInviteMessage inviteExpiration.
         * @member {number|Long} inviteExpiration
         * @memberof Message.GroupInviteMessage
         * @instance
         */
        GroupInviteMessage.prototype.inviteExpiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * GroupInviteMessage groupName.
         * @member {string} groupName
         * @memberof Message.GroupInviteMessage
         * @instance
         */
        GroupInviteMessage.prototype.groupName = "";

        /**
         * GroupInviteMessage jpegThumbnail.
         * @member {Uint8Array} jpegThumbnail
         * @memberof Message.GroupInviteMessage
         * @instance
         */
        GroupInviteMessage.prototype.jpegThumbnail = $util.newBuffer([]);

        /**
         * GroupInviteMessage caption.
         * @member {string} caption
         * @memberof Message.GroupInviteMessage
         * @instance
         */
        GroupInviteMessage.prototype.caption = "";

        /**
         * GroupInviteMessage contextInfo.
         * @member {Message.IContextInfo|null|undefined} contextInfo
         * @memberof Message.GroupInviteMessage
         * @instance
         */
        GroupInviteMessage.prototype.contextInfo = null;

        /**
         * Creates a new GroupInviteMessage instance using the specified properties.
         * @function create
         * @memberof Message.GroupInviteMessage
         * @static
         * @param {Message.IGroupInviteMessage=} [properties] Properties to set
         * @returns {Message.GroupInviteMessage} GroupInviteMessage instance
         */
        GroupInviteMessage.create = function create(properties) {
            return new GroupInviteMessage(properties);
        };

        /**
         * Encodes the specified GroupInviteMessage message. Does not implicitly {@link Message.GroupInviteMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.GroupInviteMessage
         * @static
         * @param {Message.IGroupInviteMessage} message GroupInviteMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupInviteMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.groupJid != null && Object.hasOwnProperty.call(message, "groupJid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.groupJid);
            if (message.inviteCode != null && Object.hasOwnProperty.call(message, "inviteCode"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.inviteCode);
            if (message.inviteExpiration != null && Object.hasOwnProperty.call(message, "inviteExpiration"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.inviteExpiration);
            if (message.groupName != null && Object.hasOwnProperty.call(message, "groupName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.groupName);
            if (message.jpegThumbnail != null && Object.hasOwnProperty.call(message, "jpegThumbnail"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.jpegThumbnail);
            if (message.caption != null && Object.hasOwnProperty.call(message, "caption"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.caption);
            if (message.contextInfo != null && Object.hasOwnProperty.call(message, "contextInfo"))
                $root.Message.ContextInfo.encode(message.contextInfo, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GroupInviteMessage message, length delimited. Does not implicitly {@link Message.GroupInviteMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.GroupInviteMessage
         * @static
         * @param {Message.IGroupInviteMessage} message GroupInviteMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroupInviteMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroupInviteMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.GroupInviteMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.GroupInviteMessage} GroupInviteMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupInviteMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.GroupInviteMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.groupJid = reader.string();
                    break;
                case 2:
                    message.inviteCode = reader.string();
                    break;
                case 3:
                    message.inviteExpiration = reader.int64();
                    break;
                case 4:
                    message.groupName = reader.string();
                    break;
                case 5:
                    message.jpegThumbnail = reader.bytes();
                    break;
                case 6:
                    message.caption = reader.string();
                    break;
                case 7:
                    message.contextInfo = $root.Message.ContextInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroupInviteMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.GroupInviteMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.GroupInviteMessage} GroupInviteMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupInviteMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroupInviteMessage message.
         * @function verify
         * @memberof Message.GroupInviteMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroupInviteMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.groupJid != null && message.hasOwnProperty("groupJid"))
                if (!$util.isString(message.groupJid))
                    return "groupJid: string expected";
            if (message.inviteCode != null && message.hasOwnProperty("inviteCode"))
                if (!$util.isString(message.inviteCode))
                    return "inviteCode: string expected";
            if (message.inviteExpiration != null && message.hasOwnProperty("inviteExpiration"))
                if (!$util.isInteger(message.inviteExpiration) && !(message.inviteExpiration && $util.isInteger(message.inviteExpiration.low) && $util.isInteger(message.inviteExpiration.high)))
                    return "inviteExpiration: integer|Long expected";
            if (message.groupName != null && message.hasOwnProperty("groupName"))
                if (!$util.isString(message.groupName))
                    return "groupName: string expected";
            if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                if (!(message.jpegThumbnail && typeof message.jpegThumbnail.length === "number" || $util.isString(message.jpegThumbnail)))
                    return "jpegThumbnail: buffer expected";
            if (message.caption != null && message.hasOwnProperty("caption"))
                if (!$util.isString(message.caption))
                    return "caption: string expected";
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo")) {
                var error = $root.Message.ContextInfo.verify(message.contextInfo);
                if (error)
                    return "contextInfo." + error;
            }
            return null;
        };

        /**
         * Creates a GroupInviteMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.GroupInviteMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.GroupInviteMessage} GroupInviteMessage
         */
        GroupInviteMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.GroupInviteMessage)
                return object;
            var message = new $root.Message.GroupInviteMessage();
            if (object.groupJid != null)
                message.groupJid = String(object.groupJid);
            if (object.inviteCode != null)
                message.inviteCode = String(object.inviteCode);
            if (object.inviteExpiration != null)
                if ($util.Long)
                    (message.inviteExpiration = $util.Long.fromValue(object.inviteExpiration)).unsigned = false;
                else if (typeof object.inviteExpiration === "string")
                    message.inviteExpiration = parseInt(object.inviteExpiration, 10);
                else if (typeof object.inviteExpiration === "number")
                    message.inviteExpiration = object.inviteExpiration;
                else if (typeof object.inviteExpiration === "object")
                    message.inviteExpiration = new $util.LongBits(object.inviteExpiration.low >>> 0, object.inviteExpiration.high >>> 0).toNumber();
            if (object.groupName != null)
                message.groupName = String(object.groupName);
            if (object.jpegThumbnail != null)
                if (typeof object.jpegThumbnail === "string")
                    $util.base64.decode(object.jpegThumbnail, message.jpegThumbnail = $util.newBuffer($util.base64.length(object.jpegThumbnail)), 0);
                else if (object.jpegThumbnail.length)
                    message.jpegThumbnail = object.jpegThumbnail;
            if (object.caption != null)
                message.caption = String(object.caption);
            if (object.contextInfo != null) {
                if (typeof object.contextInfo !== "object")
                    throw TypeError(".Message.GroupInviteMessage.contextInfo: object expected");
                message.contextInfo = $root.Message.ContextInfo.fromObject(object.contextInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a GroupInviteMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.GroupInviteMessage
         * @static
         * @param {Message.GroupInviteMessage} message GroupInviteMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroupInviteMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.groupJid = "";
                object.inviteCode = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.inviteExpiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.inviteExpiration = options.longs === String ? "0" : 0;
                object.groupName = "";
                if (options.bytes === String)
                    object.jpegThumbnail = "";
                else {
                    object.jpegThumbnail = [];
                    if (options.bytes !== Array)
                        object.jpegThumbnail = $util.newBuffer(object.jpegThumbnail);
                }
                object.caption = "";
                object.contextInfo = null;
            }
            if (message.groupJid != null && message.hasOwnProperty("groupJid"))
                object.groupJid = message.groupJid;
            if (message.inviteCode != null && message.hasOwnProperty("inviteCode"))
                object.inviteCode = message.inviteCode;
            if (message.inviteExpiration != null && message.hasOwnProperty("inviteExpiration"))
                if (typeof message.inviteExpiration === "number")
                    object.inviteExpiration = options.longs === String ? String(message.inviteExpiration) : message.inviteExpiration;
                else
                    object.inviteExpiration = options.longs === String ? $util.Long.prototype.toString.call(message.inviteExpiration) : options.longs === Number ? new $util.LongBits(message.inviteExpiration.low >>> 0, message.inviteExpiration.high >>> 0).toNumber() : message.inviteExpiration;
            if (message.groupName != null && message.hasOwnProperty("groupName"))
                object.groupName = message.groupName;
            if (message.jpegThumbnail != null && message.hasOwnProperty("jpegThumbnail"))
                object.jpegThumbnail = options.bytes === String ? $util.base64.encode(message.jpegThumbnail, 0, message.jpegThumbnail.length) : options.bytes === Array ? Array.prototype.slice.call(message.jpegThumbnail) : message.jpegThumbnail;
            if (message.caption != null && message.hasOwnProperty("caption"))
                object.caption = message.caption;
            if (message.contextInfo != null && message.hasOwnProperty("contextInfo"))
                object.contextInfo = $root.Message.ContextInfo.toObject(message.contextInfo, options);
            return object;
        };

        /**
         * Converts this GroupInviteMessage to JSON.
         * @function toJSON
         * @memberof Message.GroupInviteMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroupInviteMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GroupInviteMessage;
    })();

    Message.DeviceSentMessage = (function() {

        /**
         * Properties of a DeviceSentMessage.
         * @memberof Message
         * @interface IDeviceSentMessage
         * @property {string|null} [destinationJid] DeviceSentMessage destinationJid
         * @property {Message.IMessage|null} [message] DeviceSentMessage message
         * @property {string|null} [phash] DeviceSentMessage phash
         */

        /**
         * Constructs a new DeviceSentMessage.
         * @memberof Message
         * @classdesc Represents a DeviceSentMessage.
         * @implements IDeviceSentMessage
         * @constructor
         * @param {Message.IDeviceSentMessage=} [properties] Properties to set
         */
        function DeviceSentMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceSentMessage destinationJid.
         * @member {string} destinationJid
         * @memberof Message.DeviceSentMessage
         * @instance
         */
        DeviceSentMessage.prototype.destinationJid = "";

        /**
         * DeviceSentMessage message.
         * @member {Message.IMessage|null|undefined} message
         * @memberof Message.DeviceSentMessage
         * @instance
         */
        DeviceSentMessage.prototype.message = null;

        /**
         * DeviceSentMessage phash.
         * @member {string} phash
         * @memberof Message.DeviceSentMessage
         * @instance
         */
        DeviceSentMessage.prototype.phash = "";

        /**
         * Creates a new DeviceSentMessage instance using the specified properties.
         * @function create
         * @memberof Message.DeviceSentMessage
         * @static
         * @param {Message.IDeviceSentMessage=} [properties] Properties to set
         * @returns {Message.DeviceSentMessage} DeviceSentMessage instance
         */
        DeviceSentMessage.create = function create(properties) {
            return new DeviceSentMessage(properties);
        };

        /**
         * Encodes the specified DeviceSentMessage message. Does not implicitly {@link Message.DeviceSentMessage.verify|verify} messages.
         * @function encode
         * @memberof Message.DeviceSentMessage
         * @static
         * @param {Message.IDeviceSentMessage} message DeviceSentMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceSentMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.destinationJid != null && Object.hasOwnProperty.call(message, "destinationJid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.destinationJid);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                $root.Message.Message.encode(message.message, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.phash != null && Object.hasOwnProperty.call(message, "phash"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.phash);
            return writer;
        };

        /**
         * Encodes the specified DeviceSentMessage message, length delimited. Does not implicitly {@link Message.DeviceSentMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.DeviceSentMessage
         * @static
         * @param {Message.IDeviceSentMessage} message DeviceSentMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceSentMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceSentMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Message.DeviceSentMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.DeviceSentMessage} DeviceSentMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceSentMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.DeviceSentMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.destinationJid = reader.string();
                    break;
                case 2:
                    message.message = $root.Message.Message.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.phash = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceSentMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.DeviceSentMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.DeviceSentMessage} DeviceSentMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceSentMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceSentMessage message.
         * @function verify
         * @memberof Message.DeviceSentMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceSentMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.destinationJid != null && message.hasOwnProperty("destinationJid"))
                if (!$util.isString(message.destinationJid))
                    return "destinationJid: string expected";
            if (message.message != null && message.hasOwnProperty("message")) {
                var error = $root.Message.Message.verify(message.message);
                if (error)
                    return "message." + error;
            }
            if (message.phash != null && message.hasOwnProperty("phash"))
                if (!$util.isString(message.phash))
                    return "phash: string expected";
            return null;
        };

        /**
         * Creates a DeviceSentMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.DeviceSentMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.DeviceSentMessage} DeviceSentMessage
         */
        DeviceSentMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.DeviceSentMessage)
                return object;
            var message = new $root.Message.DeviceSentMessage();
            if (object.destinationJid != null)
                message.destinationJid = String(object.destinationJid);
            if (object.message != null) {
                if (typeof object.message !== "object")
                    throw TypeError(".Message.DeviceSentMessage.message: object expected");
                message.message = $root.Message.Message.fromObject(object.message);
            }
            if (object.phash != null)
                message.phash = String(object.phash);
            return message;
        };

        /**
         * Creates a plain object from a DeviceSentMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.DeviceSentMessage
         * @static
         * @param {Message.DeviceSentMessage} message DeviceSentMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceSentMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.destinationJid = "";
                object.message = null;
                object.phash = "";
            }
            if (message.destinationJid != null && message.hasOwnProperty("destinationJid"))
                object.destinationJid = message.destinationJid;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = $root.Message.Message.toObject(message.message, options);
            if (message.phash != null && message.hasOwnProperty("phash"))
                object.phash = message.phash;
            return object;
        };

        /**
         * Converts this DeviceSentMessage to JSON.
         * @function toJSON
         * @memberof Message.DeviceSentMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceSentMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceSentMessage;
    })();

    Message.TemplateMessageContainer = (function() {

        /**
         * Properties of a TemplateMessageContainer.
         * @memberof Message
         * @interface ITemplateMessageContainer
         * @property {Message.ITemplateMessage|null} [templateMessage] TemplateMessageContainer templateMessage
         */

        /**
         * Constructs a new TemplateMessageContainer.
         * @memberof Message
         * @classdesc Represents a TemplateMessageContainer.
         * @implements ITemplateMessageContainer
         * @constructor
         * @param {Message.ITemplateMessageContainer=} [properties] Properties to set
         */
        function TemplateMessageContainer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TemplateMessageContainer templateMessage.
         * @member {Message.ITemplateMessage|null|undefined} templateMessage
         * @memberof Message.TemplateMessageContainer
         * @instance
         */
        TemplateMessageContainer.prototype.templateMessage = null;

        /**
         * Creates a new TemplateMessageContainer instance using the specified properties.
         * @function create
         * @memberof Message.TemplateMessageContainer
         * @static
         * @param {Message.ITemplateMessageContainer=} [properties] Properties to set
         * @returns {Message.TemplateMessageContainer} TemplateMessageContainer instance
         */
        TemplateMessageContainer.create = function create(properties) {
            return new TemplateMessageContainer(properties);
        };

        /**
         * Encodes the specified TemplateMessageContainer message. Does not implicitly {@link Message.TemplateMessageContainer.verify|verify} messages.
         * @function encode
         * @memberof Message.TemplateMessageContainer
         * @static
         * @param {Message.ITemplateMessageContainer} message TemplateMessageContainer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TemplateMessageContainer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.templateMessage != null && Object.hasOwnProperty.call(message, "templateMessage"))
                $root.Message.TemplateMessage.encode(message.templateMessage, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TemplateMessageContainer message, length delimited. Does not implicitly {@link Message.TemplateMessageContainer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.TemplateMessageContainer
         * @static
         * @param {Message.ITemplateMessageContainer} message TemplateMessageContainer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TemplateMessageContainer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TemplateMessageContainer message from the specified reader or buffer.
         * @function decode
         * @memberof Message.TemplateMessageContainer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.TemplateMessageContainer} TemplateMessageContainer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TemplateMessageContainer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.TemplateMessageContainer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 25:
                    message.templateMessage = $root.Message.TemplateMessage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TemplateMessageContainer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.TemplateMessageContainer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.TemplateMessageContainer} TemplateMessageContainer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TemplateMessageContainer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TemplateMessageContainer message.
         * @function verify
         * @memberof Message.TemplateMessageContainer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TemplateMessageContainer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.templateMessage != null && message.hasOwnProperty("templateMessage")) {
                var error = $root.Message.TemplateMessage.verify(message.templateMessage);
                if (error)
                    return "templateMessage." + error;
            }
            return null;
        };

        /**
         * Creates a TemplateMessageContainer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.TemplateMessageContainer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.TemplateMessageContainer} TemplateMessageContainer
         */
        TemplateMessageContainer.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.TemplateMessageContainer)
                return object;
            var message = new $root.Message.TemplateMessageContainer();
            if (object.templateMessage != null) {
                if (typeof object.templateMessage !== "object")
                    throw TypeError(".Message.TemplateMessageContainer.templateMessage: object expected");
                message.templateMessage = $root.Message.TemplateMessage.fromObject(object.templateMessage);
            }
            return message;
        };

        /**
         * Creates a plain object from a TemplateMessageContainer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.TemplateMessageContainer
         * @static
         * @param {Message.TemplateMessageContainer} message TemplateMessageContainer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TemplateMessageContainer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.templateMessage = null;
            if (message.templateMessage != null && message.hasOwnProperty("templateMessage"))
                object.templateMessage = $root.Message.TemplateMessage.toObject(message.templateMessage, options);
            return object;
        };

        /**
         * Converts this TemplateMessageContainer to JSON.
         * @function toJSON
         * @memberof Message.TemplateMessageContainer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TemplateMessageContainer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TemplateMessageContainer;
    })();

    Message.TemplateMessageTop = (function() {

        /**
         * Properties of a TemplateMessageTop.
         * @memberof Message
         * @interface ITemplateMessageTop
         * @property {Message.ITemplateMessageContainer|null} [templateMessageContainer] TemplateMessageTop templateMessageContainer
         */

        /**
         * Constructs a new TemplateMessageTop.
         * @memberof Message
         * @classdesc Represents a TemplateMessageTop.
         * @implements ITemplateMessageTop
         * @constructor
         * @param {Message.ITemplateMessageTop=} [properties] Properties to set
         */
        function TemplateMessageTop(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TemplateMessageTop templateMessageContainer.
         * @member {Message.ITemplateMessageContainer|null|undefined} templateMessageContainer
         * @memberof Message.TemplateMessageTop
         * @instance
         */
        TemplateMessageTop.prototype.templateMessageContainer = null;

        /**
         * Creates a new TemplateMessageTop instance using the specified properties.
         * @function create
         * @memberof Message.TemplateMessageTop
         * @static
         * @param {Message.ITemplateMessageTop=} [properties] Properties to set
         * @returns {Message.TemplateMessageTop} TemplateMessageTop instance
         */
        TemplateMessageTop.create = function create(properties) {
            return new TemplateMessageTop(properties);
        };

        /**
         * Encodes the specified TemplateMessageTop message. Does not implicitly {@link Message.TemplateMessageTop.verify|verify} messages.
         * @function encode
         * @memberof Message.TemplateMessageTop
         * @static
         * @param {Message.ITemplateMessageTop} message TemplateMessageTop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TemplateMessageTop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.templateMessageContainer != null && Object.hasOwnProperty.call(message, "templateMessageContainer"))
                $root.Message.TemplateMessageContainer.encode(message.templateMessageContainer, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TemplateMessageTop message, length delimited. Does not implicitly {@link Message.TemplateMessageTop.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.TemplateMessageTop
         * @static
         * @param {Message.ITemplateMessageTop} message TemplateMessageTop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TemplateMessageTop.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TemplateMessageTop message from the specified reader or buffer.
         * @function decode
         * @memberof Message.TemplateMessageTop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.TemplateMessageTop} TemplateMessageTop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TemplateMessageTop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.TemplateMessageTop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.templateMessageContainer = $root.Message.TemplateMessageContainer.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TemplateMessageTop message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.TemplateMessageTop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.TemplateMessageTop} TemplateMessageTop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TemplateMessageTop.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TemplateMessageTop message.
         * @function verify
         * @memberof Message.TemplateMessageTop
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TemplateMessageTop.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.templateMessageContainer != null && message.hasOwnProperty("templateMessageContainer")) {
                var error = $root.Message.TemplateMessageContainer.verify(message.templateMessageContainer);
                if (error)
                    return "templateMessageContainer." + error;
            }
            return null;
        };

        /**
         * Creates a TemplateMessageTop message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.TemplateMessageTop
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.TemplateMessageTop} TemplateMessageTop
         */
        TemplateMessageTop.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.TemplateMessageTop)
                return object;
            var message = new $root.Message.TemplateMessageTop();
            if (object.templateMessageContainer != null) {
                if (typeof object.templateMessageContainer !== "object")
                    throw TypeError(".Message.TemplateMessageTop.templateMessageContainer: object expected");
                message.templateMessageContainer = $root.Message.TemplateMessageContainer.fromObject(object.templateMessageContainer);
            }
            return message;
        };

        /**
         * Creates a plain object from a TemplateMessageTop message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.TemplateMessageTop
         * @static
         * @param {Message.TemplateMessageTop} message TemplateMessageTop
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TemplateMessageTop.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.templateMessageContainer = null;
            if (message.templateMessageContainer != null && message.hasOwnProperty("templateMessageContainer"))
                object.templateMessageContainer = $root.Message.TemplateMessageContainer.toObject(message.templateMessageContainer, options);
            return object;
        };

        /**
         * Converts this TemplateMessageTop to JSON.
         * @function toJSON
         * @memberof Message.TemplateMessageTop
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TemplateMessageTop.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TemplateMessageTop;
    })();

    Message.Message = (function() {

        /**
         * Properties of a Message.
         * @memberof Message
         * @interface IMessage
         * @property {string|null} [conversation] Message conversation
         * @property {Message.ISenderKeyDistributionMessage|null} [senderKeyDistributionMessage] Message senderKeyDistributionMessage
         * @property {Message.IImageMessage|null} [imageMessage] Message imageMessage
         * @property {Message.IContactMessage|null} [contactMessage] Message contactMessage
         * @property {Message.ILocationMessage|null} [locationMessage] Message locationMessage
         * @property {Message.IExtendedTextMessage|null} [extendedTextMessage] Message extendedTextMessage
         * @property {Message.IDocumentMessage|null} [documentMessage] Message documentMessage
         * @property {Message.IAudioMessage|null} [audioMessage] Message audioMessage
         * @property {Message.IVideoMessage|null} [videoMessage] Message videoMessage
         * @property {Message.ICall|null} [call] Message call
         * @property {Message.IChat|null} [chat] Message chat
         * @property {Message.IProtocolMessage|null} [protocolMessage] Message protocolMessage
         * @property {Message.IContactsArrayMessage|null} [contactsArrayMessage] Message contactsArrayMessage
         * @property {Message.IHighlyStructuredMessage|null} [highlyStructuredMessage] Message highlyStructuredMessage
         * @property {Message.ISenderKeyDistributionMessage|null} [fastRatchetKeySenderKeyDistributionMessage] Message fastRatchetKeySenderKeyDistributionMessage
         * @property {Message.ISendPaymentMessage|null} [sendPaymentMessage] Message sendPaymentMessage
         * @property {Message.ILiveLocationMessage|null} [liveLocationMessage] Message liveLocationMessage
         * @property {Message.IRequestPaymentMessage|null} [requestPaymentMessage] Message requestPaymentMessage
         * @property {Message.IDeclinePaymentRequestMessage|null} [declinePaymentRequestMessage] Message declinePaymentRequestMessage
         * @property {Message.ICancelPaymentRequestMessage|null} [cancelPaymentRequestMessage] Message cancelPaymentRequestMessage
         * @property {Message.ITemplateMessage|null} [templateMessage] Message templateMessage
         * @property {Message.IStickerMessage|null} [stickerMessage] Message stickerMessage
         * @property {Message.IGroupInviteMessage|null} [groupInviteMessage] Message groupInviteMessage
         * @property {Message.ITemplateButtonReplyMessage|null} [templateButtonReplyMessage] Message templateButtonReplyMessage
         * @property {Message.IProductMessage|null} [productMessage] Message productMessage
         * @property {Message.IDeviceSentMessage|null} [deviceSentMessage] Message deviceSentMessage
         * @property {Message.ITemplateMessageTop|null} [templateMessageTop] Message templateMessageTop
         */

        /**
         * Constructs a new Message.
         * @memberof Message
         * @classdesc Represents a Message.
         * @implements IMessage
         * @constructor
         * @param {Message.IMessage=} [properties] Properties to set
         */
        function Message(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Message conversation.
         * @member {string} conversation
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.conversation = "";

        /**
         * Message senderKeyDistributionMessage.
         * @member {Message.ISenderKeyDistributionMessage|null|undefined} senderKeyDistributionMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.senderKeyDistributionMessage = null;

        /**
         * Message imageMessage.
         * @member {Message.IImageMessage|null|undefined} imageMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.imageMessage = null;

        /**
         * Message contactMessage.
         * @member {Message.IContactMessage|null|undefined} contactMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.contactMessage = null;

        /**
         * Message locationMessage.
         * @member {Message.ILocationMessage|null|undefined} locationMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.locationMessage = null;

        /**
         * Message extendedTextMessage.
         * @member {Message.IExtendedTextMessage|null|undefined} extendedTextMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.extendedTextMessage = null;

        /**
         * Message documentMessage.
         * @member {Message.IDocumentMessage|null|undefined} documentMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.documentMessage = null;

        /**
         * Message audioMessage.
         * @member {Message.IAudioMessage|null|undefined} audioMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.audioMessage = null;

        /**
         * Message videoMessage.
         * @member {Message.IVideoMessage|null|undefined} videoMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.videoMessage = null;

        /**
         * Message call.
         * @member {Message.ICall|null|undefined} call
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.call = null;

        /**
         * Message chat.
         * @member {Message.IChat|null|undefined} chat
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.chat = null;

        /**
         * Message protocolMessage.
         * @member {Message.IProtocolMessage|null|undefined} protocolMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.protocolMessage = null;

        /**
         * Message contactsArrayMessage.
         * @member {Message.IContactsArrayMessage|null|undefined} contactsArrayMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.contactsArrayMessage = null;

        /**
         * Message highlyStructuredMessage.
         * @member {Message.IHighlyStructuredMessage|null|undefined} highlyStructuredMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.highlyStructuredMessage = null;

        /**
         * Message fastRatchetKeySenderKeyDistributionMessage.
         * @member {Message.ISenderKeyDistributionMessage|null|undefined} fastRatchetKeySenderKeyDistributionMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.fastRatchetKeySenderKeyDistributionMessage = null;

        /**
         * Message sendPaymentMessage.
         * @member {Message.ISendPaymentMessage|null|undefined} sendPaymentMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.sendPaymentMessage = null;

        /**
         * Message liveLocationMessage.
         * @member {Message.ILiveLocationMessage|null|undefined} liveLocationMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.liveLocationMessage = null;

        /**
         * Message requestPaymentMessage.
         * @member {Message.IRequestPaymentMessage|null|undefined} requestPaymentMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.requestPaymentMessage = null;

        /**
         * Message declinePaymentRequestMessage.
         * @member {Message.IDeclinePaymentRequestMessage|null|undefined} declinePaymentRequestMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.declinePaymentRequestMessage = null;

        /**
         * Message cancelPaymentRequestMessage.
         * @member {Message.ICancelPaymentRequestMessage|null|undefined} cancelPaymentRequestMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.cancelPaymentRequestMessage = null;

        /**
         * Message templateMessage.
         * @member {Message.ITemplateMessage|null|undefined} templateMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.templateMessage = null;

        /**
         * Message stickerMessage.
         * @member {Message.IStickerMessage|null|undefined} stickerMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.stickerMessage = null;

        /**
         * Message groupInviteMessage.
         * @member {Message.IGroupInviteMessage|null|undefined} groupInviteMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.groupInviteMessage = null;

        /**
         * Message templateButtonReplyMessage.
         * @member {Message.ITemplateButtonReplyMessage|null|undefined} templateButtonReplyMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.templateButtonReplyMessage = null;

        /**
         * Message productMessage.
         * @member {Message.IProductMessage|null|undefined} productMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.productMessage = null;

        /**
         * Message deviceSentMessage.
         * @member {Message.IDeviceSentMessage|null|undefined} deviceSentMessage
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.deviceSentMessage = null;

        /**
         * Message templateMessageTop.
         * @member {Message.ITemplateMessageTop|null|undefined} templateMessageTop
         * @memberof Message.Message
         * @instance
         */
        Message.prototype.templateMessageTop = null;

        /**
         * Creates a new Message instance using the specified properties.
         * @function create
         * @memberof Message.Message
         * @static
         * @param {Message.IMessage=} [properties] Properties to set
         * @returns {Message.Message} Message instance
         */
        Message.create = function create(properties) {
            return new Message(properties);
        };

        /**
         * Encodes the specified Message message. Does not implicitly {@link Message.Message.verify|verify} messages.
         * @function encode
         * @memberof Message.Message
         * @static
         * @param {Message.IMessage} message Message message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Message.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.conversation != null && Object.hasOwnProperty.call(message, "conversation"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.conversation);
            if (message.senderKeyDistributionMessage != null && Object.hasOwnProperty.call(message, "senderKeyDistributionMessage"))
                $root.Message.SenderKeyDistributionMessage.encode(message.senderKeyDistributionMessage, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.imageMessage != null && Object.hasOwnProperty.call(message, "imageMessage"))
                $root.Message.ImageMessage.encode(message.imageMessage, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.contactMessage != null && Object.hasOwnProperty.call(message, "contactMessage"))
                $root.Message.ContactMessage.encode(message.contactMessage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.locationMessage != null && Object.hasOwnProperty.call(message, "locationMessage"))
                $root.Message.LocationMessage.encode(message.locationMessage, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.extendedTextMessage != null && Object.hasOwnProperty.call(message, "extendedTextMessage"))
                $root.Message.ExtendedTextMessage.encode(message.extendedTextMessage, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.documentMessage != null && Object.hasOwnProperty.call(message, "documentMessage"))
                $root.Message.DocumentMessage.encode(message.documentMessage, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.audioMessage != null && Object.hasOwnProperty.call(message, "audioMessage"))
                $root.Message.AudioMessage.encode(message.audioMessage, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.videoMessage != null && Object.hasOwnProperty.call(message, "videoMessage"))
                $root.Message.VideoMessage.encode(message.videoMessage, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.call != null && Object.hasOwnProperty.call(message, "call"))
                $root.Message.Call.encode(message.call, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.chat != null && Object.hasOwnProperty.call(message, "chat"))
                $root.Message.Chat.encode(message.chat, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.protocolMessage != null && Object.hasOwnProperty.call(message, "protocolMessage"))
                $root.Message.ProtocolMessage.encode(message.protocolMessage, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.contactsArrayMessage != null && Object.hasOwnProperty.call(message, "contactsArrayMessage"))
                $root.Message.ContactsArrayMessage.encode(message.contactsArrayMessage, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.highlyStructuredMessage != null && Object.hasOwnProperty.call(message, "highlyStructuredMessage"))
                $root.Message.HighlyStructuredMessage.encode(message.highlyStructuredMessage, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.fastRatchetKeySenderKeyDistributionMessage != null && Object.hasOwnProperty.call(message, "fastRatchetKeySenderKeyDistributionMessage"))
                $root.Message.SenderKeyDistributionMessage.encode(message.fastRatchetKeySenderKeyDistributionMessage, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.sendPaymentMessage != null && Object.hasOwnProperty.call(message, "sendPaymentMessage"))
                $root.Message.SendPaymentMessage.encode(message.sendPaymentMessage, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.liveLocationMessage != null && Object.hasOwnProperty.call(message, "liveLocationMessage"))
                $root.Message.LiveLocationMessage.encode(message.liveLocationMessage, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.requestPaymentMessage != null && Object.hasOwnProperty.call(message, "requestPaymentMessage"))
                $root.Message.RequestPaymentMessage.encode(message.requestPaymentMessage, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.declinePaymentRequestMessage != null && Object.hasOwnProperty.call(message, "declinePaymentRequestMessage"))
                $root.Message.DeclinePaymentRequestMessage.encode(message.declinePaymentRequestMessage, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            if (message.cancelPaymentRequestMessage != null && Object.hasOwnProperty.call(message, "cancelPaymentRequestMessage"))
                $root.Message.CancelPaymentRequestMessage.encode(message.cancelPaymentRequestMessage, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.templateMessage != null && Object.hasOwnProperty.call(message, "templateMessage"))
                $root.Message.TemplateMessage.encode(message.templateMessage, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
            if (message.stickerMessage != null && Object.hasOwnProperty.call(message, "stickerMessage"))
                $root.Message.StickerMessage.encode(message.stickerMessage, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
            if (message.groupInviteMessage != null && Object.hasOwnProperty.call(message, "groupInviteMessage"))
                $root.Message.GroupInviteMessage.encode(message.groupInviteMessage, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
            if (message.templateButtonReplyMessage != null && Object.hasOwnProperty.call(message, "templateButtonReplyMessage"))
                $root.Message.TemplateButtonReplyMessage.encode(message.templateButtonReplyMessage, writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
            if (message.productMessage != null && Object.hasOwnProperty.call(message, "productMessage"))
                $root.Message.ProductMessage.encode(message.productMessage, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
            if (message.deviceSentMessage != null && Object.hasOwnProperty.call(message, "deviceSentMessage"))
                $root.Message.DeviceSentMessage.encode(message.deviceSentMessage, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
            if (message.templateMessageTop != null && Object.hasOwnProperty.call(message, "templateMessageTop"))
                $root.Message.TemplateMessageTop.encode(message.templateMessageTop, writer.uint32(/* id 37, wireType 2 =*/298).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Message message, length delimited. Does not implicitly {@link Message.Message.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.Message
         * @static
         * @param {Message.IMessage} message Message message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Message.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Message message from the specified reader or buffer.
         * @function decode
         * @memberof Message.Message
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.Message} Message
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Message.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.Message();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.conversation = reader.string();
                    break;
                case 2:
                    message.senderKeyDistributionMessage = $root.Message.SenderKeyDistributionMessage.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.imageMessage = $root.Message.ImageMessage.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.contactMessage = $root.Message.ContactMessage.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.locationMessage = $root.Message.LocationMessage.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.extendedTextMessage = $root.Message.ExtendedTextMessage.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.documentMessage = $root.Message.DocumentMessage.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.audioMessage = $root.Message.AudioMessage.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.videoMessage = $root.Message.VideoMessage.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.call = $root.Message.Call.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.chat = $root.Message.Chat.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.protocolMessage = $root.Message.ProtocolMessage.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.contactsArrayMessage = $root.Message.ContactsArrayMessage.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.highlyStructuredMessage = $root.Message.HighlyStructuredMessage.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.fastRatchetKeySenderKeyDistributionMessage = $root.Message.SenderKeyDistributionMessage.decode(reader, reader.uint32());
                    break;
                case 16:
                    message.sendPaymentMessage = $root.Message.SendPaymentMessage.decode(reader, reader.uint32());
                    break;
                case 18:
                    message.liveLocationMessage = $root.Message.LiveLocationMessage.decode(reader, reader.uint32());
                    break;
                case 22:
                    message.requestPaymentMessage = $root.Message.RequestPaymentMessage.decode(reader, reader.uint32());
                    break;
                case 23:
                    message.declinePaymentRequestMessage = $root.Message.DeclinePaymentRequestMessage.decode(reader, reader.uint32());
                    break;
                case 24:
                    message.cancelPaymentRequestMessage = $root.Message.CancelPaymentRequestMessage.decode(reader, reader.uint32());
                    break;
                case 25:
                    message.templateMessage = $root.Message.TemplateMessage.decode(reader, reader.uint32());
                    break;
                case 26:
                    message.stickerMessage = $root.Message.StickerMessage.decode(reader, reader.uint32());
                    break;
                case 28:
                    message.groupInviteMessage = $root.Message.GroupInviteMessage.decode(reader, reader.uint32());
                    break;
                case 29:
                    message.templateButtonReplyMessage = $root.Message.TemplateButtonReplyMessage.decode(reader, reader.uint32());
                    break;
                case 30:
                    message.productMessage = $root.Message.ProductMessage.decode(reader, reader.uint32());
                    break;
                case 31:
                    message.deviceSentMessage = $root.Message.DeviceSentMessage.decode(reader, reader.uint32());
                    break;
                case 37:
                    message.templateMessageTop = $root.Message.TemplateMessageTop.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Message message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.Message
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.Message} Message
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Message.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Message message.
         * @function verify
         * @memberof Message.Message
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Message.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.conversation != null && message.hasOwnProperty("conversation"))
                if (!$util.isString(message.conversation))
                    return "conversation: string expected";
            if (message.senderKeyDistributionMessage != null && message.hasOwnProperty("senderKeyDistributionMessage")) {
                var error = $root.Message.SenderKeyDistributionMessage.verify(message.senderKeyDistributionMessage);
                if (error)
                    return "senderKeyDistributionMessage." + error;
            }
            if (message.imageMessage != null && message.hasOwnProperty("imageMessage")) {
                var error = $root.Message.ImageMessage.verify(message.imageMessage);
                if (error)
                    return "imageMessage." + error;
            }
            if (message.contactMessage != null && message.hasOwnProperty("contactMessage")) {
                var error = $root.Message.ContactMessage.verify(message.contactMessage);
                if (error)
                    return "contactMessage." + error;
            }
            if (message.locationMessage != null && message.hasOwnProperty("locationMessage")) {
                var error = $root.Message.LocationMessage.verify(message.locationMessage);
                if (error)
                    return "locationMessage." + error;
            }
            if (message.extendedTextMessage != null && message.hasOwnProperty("extendedTextMessage")) {
                var error = $root.Message.ExtendedTextMessage.verify(message.extendedTextMessage);
                if (error)
                    return "extendedTextMessage." + error;
            }
            if (message.documentMessage != null && message.hasOwnProperty("documentMessage")) {
                var error = $root.Message.DocumentMessage.verify(message.documentMessage);
                if (error)
                    return "documentMessage." + error;
            }
            if (message.audioMessage != null && message.hasOwnProperty("audioMessage")) {
                var error = $root.Message.AudioMessage.verify(message.audioMessage);
                if (error)
                    return "audioMessage." + error;
            }
            if (message.videoMessage != null && message.hasOwnProperty("videoMessage")) {
                var error = $root.Message.VideoMessage.verify(message.videoMessage);
                if (error)
                    return "videoMessage." + error;
            }
            if (message.call != null && message.hasOwnProperty("call")) {
                var error = $root.Message.Call.verify(message.call);
                if (error)
                    return "call." + error;
            }
            if (message.chat != null && message.hasOwnProperty("chat")) {
                var error = $root.Message.Chat.verify(message.chat);
                if (error)
                    return "chat." + error;
            }
            if (message.protocolMessage != null && message.hasOwnProperty("protocolMessage")) {
                var error = $root.Message.ProtocolMessage.verify(message.protocolMessage);
                if (error)
                    return "protocolMessage." + error;
            }
            if (message.contactsArrayMessage != null && message.hasOwnProperty("contactsArrayMessage")) {
                var error = $root.Message.ContactsArrayMessage.verify(message.contactsArrayMessage);
                if (error)
                    return "contactsArrayMessage." + error;
            }
            if (message.highlyStructuredMessage != null && message.hasOwnProperty("highlyStructuredMessage")) {
                var error = $root.Message.HighlyStructuredMessage.verify(message.highlyStructuredMessage);
                if (error)
                    return "highlyStructuredMessage." + error;
            }
            if (message.fastRatchetKeySenderKeyDistributionMessage != null && message.hasOwnProperty("fastRatchetKeySenderKeyDistributionMessage")) {
                var error = $root.Message.SenderKeyDistributionMessage.verify(message.fastRatchetKeySenderKeyDistributionMessage);
                if (error)
                    return "fastRatchetKeySenderKeyDistributionMessage." + error;
            }
            if (message.sendPaymentMessage != null && message.hasOwnProperty("sendPaymentMessage")) {
                var error = $root.Message.SendPaymentMessage.verify(message.sendPaymentMessage);
                if (error)
                    return "sendPaymentMessage." + error;
            }
            if (message.liveLocationMessage != null && message.hasOwnProperty("liveLocationMessage")) {
                var error = $root.Message.LiveLocationMessage.verify(message.liveLocationMessage);
                if (error)
                    return "liveLocationMessage." + error;
            }
            if (message.requestPaymentMessage != null && message.hasOwnProperty("requestPaymentMessage")) {
                var error = $root.Message.RequestPaymentMessage.verify(message.requestPaymentMessage);
                if (error)
                    return "requestPaymentMessage." + error;
            }
            if (message.declinePaymentRequestMessage != null && message.hasOwnProperty("declinePaymentRequestMessage")) {
                var error = $root.Message.DeclinePaymentRequestMessage.verify(message.declinePaymentRequestMessage);
                if (error)
                    return "declinePaymentRequestMessage." + error;
            }
            if (message.cancelPaymentRequestMessage != null && message.hasOwnProperty("cancelPaymentRequestMessage")) {
                var error = $root.Message.CancelPaymentRequestMessage.verify(message.cancelPaymentRequestMessage);
                if (error)
                    return "cancelPaymentRequestMessage." + error;
            }
            if (message.templateMessage != null && message.hasOwnProperty("templateMessage")) {
                var error = $root.Message.TemplateMessage.verify(message.templateMessage);
                if (error)
                    return "templateMessage." + error;
            }
            if (message.stickerMessage != null && message.hasOwnProperty("stickerMessage")) {
                var error = $root.Message.StickerMessage.verify(message.stickerMessage);
                if (error)
                    return "stickerMessage." + error;
            }
            if (message.groupInviteMessage != null && message.hasOwnProperty("groupInviteMessage")) {
                var error = $root.Message.GroupInviteMessage.verify(message.groupInviteMessage);
                if (error)
                    return "groupInviteMessage." + error;
            }
            if (message.templateButtonReplyMessage != null && message.hasOwnProperty("templateButtonReplyMessage")) {
                var error = $root.Message.TemplateButtonReplyMessage.verify(message.templateButtonReplyMessage);
                if (error)
                    return "templateButtonReplyMessage." + error;
            }
            if (message.productMessage != null && message.hasOwnProperty("productMessage")) {
                var error = $root.Message.ProductMessage.verify(message.productMessage);
                if (error)
                    return "productMessage." + error;
            }
            if (message.deviceSentMessage != null && message.hasOwnProperty("deviceSentMessage")) {
                var error = $root.Message.DeviceSentMessage.verify(message.deviceSentMessage);
                if (error)
                    return "deviceSentMessage." + error;
            }
            if (message.templateMessageTop != null && message.hasOwnProperty("templateMessageTop")) {
                var error = $root.Message.TemplateMessageTop.verify(message.templateMessageTop);
                if (error)
                    return "templateMessageTop." + error;
            }
            return null;
        };

        /**
         * Creates a Message message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.Message
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.Message} Message
         */
        Message.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.Message)
                return object;
            var message = new $root.Message.Message();
            if (object.conversation != null)
                message.conversation = String(object.conversation);
            if (object.senderKeyDistributionMessage != null) {
                if (typeof object.senderKeyDistributionMessage !== "object")
                    throw TypeError(".Message.Message.senderKeyDistributionMessage: object expected");
                message.senderKeyDistributionMessage = $root.Message.SenderKeyDistributionMessage.fromObject(object.senderKeyDistributionMessage);
            }
            if (object.imageMessage != null) {
                if (typeof object.imageMessage !== "object")
                    throw TypeError(".Message.Message.imageMessage: object expected");
                message.imageMessage = $root.Message.ImageMessage.fromObject(object.imageMessage);
            }
            if (object.contactMessage != null) {
                if (typeof object.contactMessage !== "object")
                    throw TypeError(".Message.Message.contactMessage: object expected");
                message.contactMessage = $root.Message.ContactMessage.fromObject(object.contactMessage);
            }
            if (object.locationMessage != null) {
                if (typeof object.locationMessage !== "object")
                    throw TypeError(".Message.Message.locationMessage: object expected");
                message.locationMessage = $root.Message.LocationMessage.fromObject(object.locationMessage);
            }
            if (object.extendedTextMessage != null) {
                if (typeof object.extendedTextMessage !== "object")
                    throw TypeError(".Message.Message.extendedTextMessage: object expected");
                message.extendedTextMessage = $root.Message.ExtendedTextMessage.fromObject(object.extendedTextMessage);
            }
            if (object.documentMessage != null) {
                if (typeof object.documentMessage !== "object")
                    throw TypeError(".Message.Message.documentMessage: object expected");
                message.documentMessage = $root.Message.DocumentMessage.fromObject(object.documentMessage);
            }
            if (object.audioMessage != null) {
                if (typeof object.audioMessage !== "object")
                    throw TypeError(".Message.Message.audioMessage: object expected");
                message.audioMessage = $root.Message.AudioMessage.fromObject(object.audioMessage);
            }
            if (object.videoMessage != null) {
                if (typeof object.videoMessage !== "object")
                    throw TypeError(".Message.Message.videoMessage: object expected");
                message.videoMessage = $root.Message.VideoMessage.fromObject(object.videoMessage);
            }
            if (object.call != null) {
                if (typeof object.call !== "object")
                    throw TypeError(".Message.Message.call: object expected");
                message.call = $root.Message.Call.fromObject(object.call);
            }
            if (object.chat != null) {
                if (typeof object.chat !== "object")
                    throw TypeError(".Message.Message.chat: object expected");
                message.chat = $root.Message.Chat.fromObject(object.chat);
            }
            if (object.protocolMessage != null) {
                if (typeof object.protocolMessage !== "object")
                    throw TypeError(".Message.Message.protocolMessage: object expected");
                message.protocolMessage = $root.Message.ProtocolMessage.fromObject(object.protocolMessage);
            }
            if (object.contactsArrayMessage != null) {
                if (typeof object.contactsArrayMessage !== "object")
                    throw TypeError(".Message.Message.contactsArrayMessage: object expected");
                message.contactsArrayMessage = $root.Message.ContactsArrayMessage.fromObject(object.contactsArrayMessage);
            }
            if (object.highlyStructuredMessage != null) {
                if (typeof object.highlyStructuredMessage !== "object")
                    throw TypeError(".Message.Message.highlyStructuredMessage: object expected");
                message.highlyStructuredMessage = $root.Message.HighlyStructuredMessage.fromObject(object.highlyStructuredMessage);
            }
            if (object.fastRatchetKeySenderKeyDistributionMessage != null) {
                if (typeof object.fastRatchetKeySenderKeyDistributionMessage !== "object")
                    throw TypeError(".Message.Message.fastRatchetKeySenderKeyDistributionMessage: object expected");
                message.fastRatchetKeySenderKeyDistributionMessage = $root.Message.SenderKeyDistributionMessage.fromObject(object.fastRatchetKeySenderKeyDistributionMessage);
            }
            if (object.sendPaymentMessage != null) {
                if (typeof object.sendPaymentMessage !== "object")
                    throw TypeError(".Message.Message.sendPaymentMessage: object expected");
                message.sendPaymentMessage = $root.Message.SendPaymentMessage.fromObject(object.sendPaymentMessage);
            }
            if (object.liveLocationMessage != null) {
                if (typeof object.liveLocationMessage !== "object")
                    throw TypeError(".Message.Message.liveLocationMessage: object expected");
                message.liveLocationMessage = $root.Message.LiveLocationMessage.fromObject(object.liveLocationMessage);
            }
            if (object.requestPaymentMessage != null) {
                if (typeof object.requestPaymentMessage !== "object")
                    throw TypeError(".Message.Message.requestPaymentMessage: object expected");
                message.requestPaymentMessage = $root.Message.RequestPaymentMessage.fromObject(object.requestPaymentMessage);
            }
            if (object.declinePaymentRequestMessage != null) {
                if (typeof object.declinePaymentRequestMessage !== "object")
                    throw TypeError(".Message.Message.declinePaymentRequestMessage: object expected");
                message.declinePaymentRequestMessage = $root.Message.DeclinePaymentRequestMessage.fromObject(object.declinePaymentRequestMessage);
            }
            if (object.cancelPaymentRequestMessage != null) {
                if (typeof object.cancelPaymentRequestMessage !== "object")
                    throw TypeError(".Message.Message.cancelPaymentRequestMessage: object expected");
                message.cancelPaymentRequestMessage = $root.Message.CancelPaymentRequestMessage.fromObject(object.cancelPaymentRequestMessage);
            }
            if (object.templateMessage != null) {
                if (typeof object.templateMessage !== "object")
                    throw TypeError(".Message.Message.templateMessage: object expected");
                message.templateMessage = $root.Message.TemplateMessage.fromObject(object.templateMessage);
            }
            if (object.stickerMessage != null) {
                if (typeof object.stickerMessage !== "object")
                    throw TypeError(".Message.Message.stickerMessage: object expected");
                message.stickerMessage = $root.Message.StickerMessage.fromObject(object.stickerMessage);
            }
            if (object.groupInviteMessage != null) {
                if (typeof object.groupInviteMessage !== "object")
                    throw TypeError(".Message.Message.groupInviteMessage: object expected");
                message.groupInviteMessage = $root.Message.GroupInviteMessage.fromObject(object.groupInviteMessage);
            }
            if (object.templateButtonReplyMessage != null) {
                if (typeof object.templateButtonReplyMessage !== "object")
                    throw TypeError(".Message.Message.templateButtonReplyMessage: object expected");
                message.templateButtonReplyMessage = $root.Message.TemplateButtonReplyMessage.fromObject(object.templateButtonReplyMessage);
            }
            if (object.productMessage != null) {
                if (typeof object.productMessage !== "object")
                    throw TypeError(".Message.Message.productMessage: object expected");
                message.productMessage = $root.Message.ProductMessage.fromObject(object.productMessage);
            }
            if (object.deviceSentMessage != null) {
                if (typeof object.deviceSentMessage !== "object")
                    throw TypeError(".Message.Message.deviceSentMessage: object expected");
                message.deviceSentMessage = $root.Message.DeviceSentMessage.fromObject(object.deviceSentMessage);
            }
            if (object.templateMessageTop != null) {
                if (typeof object.templateMessageTop !== "object")
                    throw TypeError(".Message.Message.templateMessageTop: object expected");
                message.templateMessageTop = $root.Message.TemplateMessageTop.fromObject(object.templateMessageTop);
            }
            return message;
        };

        /**
         * Creates a plain object from a Message message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.Message
         * @static
         * @param {Message.Message} message Message
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Message.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.conversation = "";
                object.senderKeyDistributionMessage = null;
                object.imageMessage = null;
                object.contactMessage = null;
                object.locationMessage = null;
                object.extendedTextMessage = null;
                object.documentMessage = null;
                object.audioMessage = null;
                object.videoMessage = null;
                object.call = null;
                object.chat = null;
                object.protocolMessage = null;
                object.contactsArrayMessage = null;
                object.highlyStructuredMessage = null;
                object.fastRatchetKeySenderKeyDistributionMessage = null;
                object.sendPaymentMessage = null;
                object.liveLocationMessage = null;
                object.requestPaymentMessage = null;
                object.declinePaymentRequestMessage = null;
                object.cancelPaymentRequestMessage = null;
                object.templateMessage = null;
                object.stickerMessage = null;
                object.groupInviteMessage = null;
                object.templateButtonReplyMessage = null;
                object.productMessage = null;
                object.deviceSentMessage = null;
                object.templateMessageTop = null;
            }
            if (message.conversation != null && message.hasOwnProperty("conversation"))
                object.conversation = message.conversation;
            if (message.senderKeyDistributionMessage != null && message.hasOwnProperty("senderKeyDistributionMessage"))
                object.senderKeyDistributionMessage = $root.Message.SenderKeyDistributionMessage.toObject(message.senderKeyDistributionMessage, options);
            if (message.imageMessage != null && message.hasOwnProperty("imageMessage"))
                object.imageMessage = $root.Message.ImageMessage.toObject(message.imageMessage, options);
            if (message.contactMessage != null && message.hasOwnProperty("contactMessage"))
                object.contactMessage = $root.Message.ContactMessage.toObject(message.contactMessage, options);
            if (message.locationMessage != null && message.hasOwnProperty("locationMessage"))
                object.locationMessage = $root.Message.LocationMessage.toObject(message.locationMessage, options);
            if (message.extendedTextMessage != null && message.hasOwnProperty("extendedTextMessage"))
                object.extendedTextMessage = $root.Message.ExtendedTextMessage.toObject(message.extendedTextMessage, options);
            if (message.documentMessage != null && message.hasOwnProperty("documentMessage"))
                object.documentMessage = $root.Message.DocumentMessage.toObject(message.documentMessage, options);
            if (message.audioMessage != null && message.hasOwnProperty("audioMessage"))
                object.audioMessage = $root.Message.AudioMessage.toObject(message.audioMessage, options);
            if (message.videoMessage != null && message.hasOwnProperty("videoMessage"))
                object.videoMessage = $root.Message.VideoMessage.toObject(message.videoMessage, options);
            if (message.call != null && message.hasOwnProperty("call"))
                object.call = $root.Message.Call.toObject(message.call, options);
            if (message.chat != null && message.hasOwnProperty("chat"))
                object.chat = $root.Message.Chat.toObject(message.chat, options);
            if (message.protocolMessage != null && message.hasOwnProperty("protocolMessage"))
                object.protocolMessage = $root.Message.ProtocolMessage.toObject(message.protocolMessage, options);
            if (message.contactsArrayMessage != null && message.hasOwnProperty("contactsArrayMessage"))
                object.contactsArrayMessage = $root.Message.ContactsArrayMessage.toObject(message.contactsArrayMessage, options);
            if (message.highlyStructuredMessage != null && message.hasOwnProperty("highlyStructuredMessage"))
                object.highlyStructuredMessage = $root.Message.HighlyStructuredMessage.toObject(message.highlyStructuredMessage, options);
            if (message.fastRatchetKeySenderKeyDistributionMessage != null && message.hasOwnProperty("fastRatchetKeySenderKeyDistributionMessage"))
                object.fastRatchetKeySenderKeyDistributionMessage = $root.Message.SenderKeyDistributionMessage.toObject(message.fastRatchetKeySenderKeyDistributionMessage, options);
            if (message.sendPaymentMessage != null && message.hasOwnProperty("sendPaymentMessage"))
                object.sendPaymentMessage = $root.Message.SendPaymentMessage.toObject(message.sendPaymentMessage, options);
            if (message.liveLocationMessage != null && message.hasOwnProperty("liveLocationMessage"))
                object.liveLocationMessage = $root.Message.LiveLocationMessage.toObject(message.liveLocationMessage, options);
            if (message.requestPaymentMessage != null && message.hasOwnProperty("requestPaymentMessage"))
                object.requestPaymentMessage = $root.Message.RequestPaymentMessage.toObject(message.requestPaymentMessage, options);
            if (message.declinePaymentRequestMessage != null && message.hasOwnProperty("declinePaymentRequestMessage"))
                object.declinePaymentRequestMessage = $root.Message.DeclinePaymentRequestMessage.toObject(message.declinePaymentRequestMessage, options);
            if (message.cancelPaymentRequestMessage != null && message.hasOwnProperty("cancelPaymentRequestMessage"))
                object.cancelPaymentRequestMessage = $root.Message.CancelPaymentRequestMessage.toObject(message.cancelPaymentRequestMessage, options);
            if (message.templateMessage != null && message.hasOwnProperty("templateMessage"))
                object.templateMessage = $root.Message.TemplateMessage.toObject(message.templateMessage, options);
            if (message.stickerMessage != null && message.hasOwnProperty("stickerMessage"))
                object.stickerMessage = $root.Message.StickerMessage.toObject(message.stickerMessage, options);
            if (message.groupInviteMessage != null && message.hasOwnProperty("groupInviteMessage"))
                object.groupInviteMessage = $root.Message.GroupInviteMessage.toObject(message.groupInviteMessage, options);
            if (message.templateButtonReplyMessage != null && message.hasOwnProperty("templateButtonReplyMessage"))
                object.templateButtonReplyMessage = $root.Message.TemplateButtonReplyMessage.toObject(message.templateButtonReplyMessage, options);
            if (message.productMessage != null && message.hasOwnProperty("productMessage"))
                object.productMessage = $root.Message.ProductMessage.toObject(message.productMessage, options);
            if (message.deviceSentMessage != null && message.hasOwnProperty("deviceSentMessage"))
                object.deviceSentMessage = $root.Message.DeviceSentMessage.toObject(message.deviceSentMessage, options);
            if (message.templateMessageTop != null && message.hasOwnProperty("templateMessageTop"))
                object.templateMessageTop = $root.Message.TemplateMessageTop.toObject(message.templateMessageTop, options);
            return object;
        };

        /**
         * Converts this Message to JSON.
         * @function toJSON
         * @memberof Message.Message
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Message.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Message;
    })();

    Message.MessageKey = (function() {

        /**
         * Properties of a MessageKey.
         * @memberof Message
         * @interface IMessageKey
         * @property {string|null} [remoteJid] MessageKey remoteJid
         * @property {boolean|null} [fromMe] MessageKey fromMe
         * @property {string|null} [id] MessageKey id
         * @property {string|null} [participant] MessageKey participant
         */

        /**
         * Constructs a new MessageKey.
         * @memberof Message
         * @classdesc Represents a MessageKey.
         * @implements IMessageKey
         * @constructor
         * @param {Message.IMessageKey=} [properties] Properties to set
         */
        function MessageKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MessageKey remoteJid.
         * @member {string} remoteJid
         * @memberof Message.MessageKey
         * @instance
         */
        MessageKey.prototype.remoteJid = "";

        /**
         * MessageKey fromMe.
         * @member {boolean} fromMe
         * @memberof Message.MessageKey
         * @instance
         */
        MessageKey.prototype.fromMe = false;

        /**
         * MessageKey id.
         * @member {string} id
         * @memberof Message.MessageKey
         * @instance
         */
        MessageKey.prototype.id = "";

        /**
         * MessageKey participant.
         * @member {string} participant
         * @memberof Message.MessageKey
         * @instance
         */
        MessageKey.prototype.participant = "";

        /**
         * Creates a new MessageKey instance using the specified properties.
         * @function create
         * @memberof Message.MessageKey
         * @static
         * @param {Message.IMessageKey=} [properties] Properties to set
         * @returns {Message.MessageKey} MessageKey instance
         */
        MessageKey.create = function create(properties) {
            return new MessageKey(properties);
        };

        /**
         * Encodes the specified MessageKey message. Does not implicitly {@link Message.MessageKey.verify|verify} messages.
         * @function encode
         * @memberof Message.MessageKey
         * @static
         * @param {Message.IMessageKey} message MessageKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.remoteJid != null && Object.hasOwnProperty.call(message, "remoteJid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.remoteJid);
            if (message.fromMe != null && Object.hasOwnProperty.call(message, "fromMe"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.fromMe);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.id);
            if (message.participant != null && Object.hasOwnProperty.call(message, "participant"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.participant);
            return writer;
        };

        /**
         * Encodes the specified MessageKey message, length delimited. Does not implicitly {@link Message.MessageKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.MessageKey
         * @static
         * @param {Message.IMessageKey} message MessageKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MessageKey message from the specified reader or buffer.
         * @function decode
         * @memberof Message.MessageKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.MessageKey} MessageKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.MessageKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.remoteJid = reader.string();
                    break;
                case 2:
                    message.fromMe = reader.bool();
                    break;
                case 3:
                    message.id = reader.string();
                    break;
                case 4:
                    message.participant = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MessageKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.MessageKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.MessageKey} MessageKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MessageKey message.
         * @function verify
         * @memberof Message.MessageKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MessageKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.remoteJid != null && message.hasOwnProperty("remoteJid"))
                if (!$util.isString(message.remoteJid))
                    return "remoteJid: string expected";
            if (message.fromMe != null && message.hasOwnProperty("fromMe"))
                if (typeof message.fromMe !== "boolean")
                    return "fromMe: boolean expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.participant != null && message.hasOwnProperty("participant"))
                if (!$util.isString(message.participant))
                    return "participant: string expected";
            return null;
        };

        /**
         * Creates a MessageKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.MessageKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.MessageKey} MessageKey
         */
        MessageKey.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.MessageKey)
                return object;
            var message = new $root.Message.MessageKey();
            if (object.remoteJid != null)
                message.remoteJid = String(object.remoteJid);
            if (object.fromMe != null)
                message.fromMe = Boolean(object.fromMe);
            if (object.id != null)
                message.id = String(object.id);
            if (object.participant != null)
                message.participant = String(object.participant);
            return message;
        };

        /**
         * Creates a plain object from a MessageKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.MessageKey
         * @static
         * @param {Message.MessageKey} message MessageKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MessageKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.remoteJid = "";
                object.fromMe = false;
                object.id = "";
                object.participant = "";
            }
            if (message.remoteJid != null && message.hasOwnProperty("remoteJid"))
                object.remoteJid = message.remoteJid;
            if (message.fromMe != null && message.hasOwnProperty("fromMe"))
                object.fromMe = message.fromMe;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.participant != null && message.hasOwnProperty("participant"))
                object.participant = message.participant;
            return object;
        };

        /**
         * Converts this MessageKey to JSON.
         * @function toJSON
         * @memberof Message.MessageKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MessageKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MessageKey;
    })();

    Message.WebFeatures = (function() {

        /**
         * Properties of a WebFeatures.
         * @memberof Message
         * @interface IWebFeatures
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [labelsDisplay] WebFeatures labelsDisplay
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [voipIndividualOutgoing] WebFeatures voipIndividualOutgoing
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [groupsV3] WebFeatures groupsV3
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [groupsV3Create] WebFeatures groupsV3Create
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [changeNumberV2] WebFeatures changeNumberV2
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [queryStatusV3Thumbnail] WebFeatures queryStatusV3Thumbnail
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [liveLocations] WebFeatures liveLocations
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [queryVname] WebFeatures queryVname
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [voipIndividualIncoming] WebFeatures voipIndividualIncoming
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [quickRepliesQuery] WebFeatures quickRepliesQuery
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [payments] WebFeatures payments
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [stickerPackQuery] WebFeatures stickerPackQuery
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [liveLocationsFinal] WebFeatures liveLocationsFinal
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [labelsEdit] WebFeatures labelsEdit
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [mediaUpload] WebFeatures mediaUpload
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [mediaUploadRichQuickReplies] WebFeatures mediaUploadRichQuickReplies
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [vnameV2] WebFeatures vnameV2
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [videoPlaybackUrl] WebFeatures videoPlaybackUrl
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [statusRanking] WebFeatures statusRanking
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [voipIndividualVideo] WebFeatures voipIndividualVideo
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [thirdPartyStickers] WebFeatures thirdPartyStickers
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [frequentlyForwardedSetting] WebFeatures frequentlyForwardedSetting
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [groupsV4JoinPermission] WebFeatures groupsV4JoinPermission
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [recentStickers] WebFeatures recentStickers
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [catalog] WebFeatures catalog
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [starredStickers] WebFeatures starredStickers
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [voipGroupCall] WebFeatures voipGroupCall
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [templateMessage] WebFeatures templateMessage
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [templateMessageInteractivity] WebFeatures templateMessageInteractivity
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [ephemeralMessages] WebFeatures ephemeralMessages
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [e2ENotificationSync] WebFeatures e2ENotificationSync
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [recentStickersV2] WebFeatures recentStickersV2
         * @property {Message.WebFeatures.WEB_FEATURES_FLAG|null} [syncdRelease1] WebFeatures syncdRelease1
         */

        /**
         * Constructs a new WebFeatures.
         * @memberof Message
         * @classdesc Represents a WebFeatures.
         * @implements IWebFeatures
         * @constructor
         * @param {Message.IWebFeatures=} [properties] Properties to set
         */
        function WebFeatures(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WebFeatures labelsDisplay.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} labelsDisplay
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.labelsDisplay = 0;

        /**
         * WebFeatures voipIndividualOutgoing.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} voipIndividualOutgoing
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.voipIndividualOutgoing = 0;

        /**
         * WebFeatures groupsV3.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} groupsV3
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.groupsV3 = 0;

        /**
         * WebFeatures groupsV3Create.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} groupsV3Create
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.groupsV3Create = 0;

        /**
         * WebFeatures changeNumberV2.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} changeNumberV2
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.changeNumberV2 = 0;

        /**
         * WebFeatures queryStatusV3Thumbnail.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} queryStatusV3Thumbnail
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.queryStatusV3Thumbnail = 0;

        /**
         * WebFeatures liveLocations.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} liveLocations
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.liveLocations = 0;

        /**
         * WebFeatures queryVname.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} queryVname
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.queryVname = 0;

        /**
         * WebFeatures voipIndividualIncoming.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} voipIndividualIncoming
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.voipIndividualIncoming = 0;

        /**
         * WebFeatures quickRepliesQuery.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} quickRepliesQuery
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.quickRepliesQuery = 0;

        /**
         * WebFeatures payments.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} payments
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.payments = 0;

        /**
         * WebFeatures stickerPackQuery.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} stickerPackQuery
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.stickerPackQuery = 0;

        /**
         * WebFeatures liveLocationsFinal.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} liveLocationsFinal
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.liveLocationsFinal = 0;

        /**
         * WebFeatures labelsEdit.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} labelsEdit
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.labelsEdit = 0;

        /**
         * WebFeatures mediaUpload.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} mediaUpload
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.mediaUpload = 0;

        /**
         * WebFeatures mediaUploadRichQuickReplies.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} mediaUploadRichQuickReplies
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.mediaUploadRichQuickReplies = 0;

        /**
         * WebFeatures vnameV2.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} vnameV2
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.vnameV2 = 0;

        /**
         * WebFeatures videoPlaybackUrl.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} videoPlaybackUrl
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.videoPlaybackUrl = 0;

        /**
         * WebFeatures statusRanking.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} statusRanking
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.statusRanking = 0;

        /**
         * WebFeatures voipIndividualVideo.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} voipIndividualVideo
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.voipIndividualVideo = 0;

        /**
         * WebFeatures thirdPartyStickers.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} thirdPartyStickers
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.thirdPartyStickers = 0;

        /**
         * WebFeatures frequentlyForwardedSetting.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} frequentlyForwardedSetting
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.frequentlyForwardedSetting = 0;

        /**
         * WebFeatures groupsV4JoinPermission.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} groupsV4JoinPermission
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.groupsV4JoinPermission = 0;

        /**
         * WebFeatures recentStickers.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} recentStickers
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.recentStickers = 0;

        /**
         * WebFeatures catalog.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} catalog
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.catalog = 0;

        /**
         * WebFeatures starredStickers.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} starredStickers
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.starredStickers = 0;

        /**
         * WebFeatures voipGroupCall.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} voipGroupCall
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.voipGroupCall = 0;

        /**
         * WebFeatures templateMessage.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} templateMessage
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.templateMessage = 0;

        /**
         * WebFeatures templateMessageInteractivity.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} templateMessageInteractivity
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.templateMessageInteractivity = 0;

        /**
         * WebFeatures ephemeralMessages.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} ephemeralMessages
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.ephemeralMessages = 0;

        /**
         * WebFeatures e2ENotificationSync.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} e2ENotificationSync
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.e2ENotificationSync = 0;

        /**
         * WebFeatures recentStickersV2.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} recentStickersV2
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.recentStickersV2 = 0;

        /**
         * WebFeatures syncdRelease1.
         * @member {Message.WebFeatures.WEB_FEATURES_FLAG} syncdRelease1
         * @memberof Message.WebFeatures
         * @instance
         */
        WebFeatures.prototype.syncdRelease1 = 0;

        /**
         * Creates a new WebFeatures instance using the specified properties.
         * @function create
         * @memberof Message.WebFeatures
         * @static
         * @param {Message.IWebFeatures=} [properties] Properties to set
         * @returns {Message.WebFeatures} WebFeatures instance
         */
        WebFeatures.create = function create(properties) {
            return new WebFeatures(properties);
        };

        /**
         * Encodes the specified WebFeatures message. Does not implicitly {@link Message.WebFeatures.verify|verify} messages.
         * @function encode
         * @memberof Message.WebFeatures
         * @static
         * @param {Message.IWebFeatures} message WebFeatures message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebFeatures.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.labelsDisplay != null && Object.hasOwnProperty.call(message, "labelsDisplay"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.labelsDisplay);
            if (message.voipIndividualOutgoing != null && Object.hasOwnProperty.call(message, "voipIndividualOutgoing"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.voipIndividualOutgoing);
            if (message.groupsV3 != null && Object.hasOwnProperty.call(message, "groupsV3"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.groupsV3);
            if (message.groupsV3Create != null && Object.hasOwnProperty.call(message, "groupsV3Create"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.groupsV3Create);
            if (message.changeNumberV2 != null && Object.hasOwnProperty.call(message, "changeNumberV2"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.changeNumberV2);
            if (message.queryStatusV3Thumbnail != null && Object.hasOwnProperty.call(message, "queryStatusV3Thumbnail"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.queryStatusV3Thumbnail);
            if (message.liveLocations != null && Object.hasOwnProperty.call(message, "liveLocations"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.liveLocations);
            if (message.queryVname != null && Object.hasOwnProperty.call(message, "queryVname"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.queryVname);
            if (message.voipIndividualIncoming != null && Object.hasOwnProperty.call(message, "voipIndividualIncoming"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.voipIndividualIncoming);
            if (message.quickRepliesQuery != null && Object.hasOwnProperty.call(message, "quickRepliesQuery"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.quickRepliesQuery);
            if (message.payments != null && Object.hasOwnProperty.call(message, "payments"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.payments);
            if (message.stickerPackQuery != null && Object.hasOwnProperty.call(message, "stickerPackQuery"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.stickerPackQuery);
            if (message.liveLocationsFinal != null && Object.hasOwnProperty.call(message, "liveLocationsFinal"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.liveLocationsFinal);
            if (message.labelsEdit != null && Object.hasOwnProperty.call(message, "labelsEdit"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.labelsEdit);
            if (message.mediaUpload != null && Object.hasOwnProperty.call(message, "mediaUpload"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.mediaUpload);
            if (message.mediaUploadRichQuickReplies != null && Object.hasOwnProperty.call(message, "mediaUploadRichQuickReplies"))
                writer.uint32(/* id 18, wireType 0 =*/144).int32(message.mediaUploadRichQuickReplies);
            if (message.vnameV2 != null && Object.hasOwnProperty.call(message, "vnameV2"))
                writer.uint32(/* id 19, wireType 0 =*/152).int32(message.vnameV2);
            if (message.videoPlaybackUrl != null && Object.hasOwnProperty.call(message, "videoPlaybackUrl"))
                writer.uint32(/* id 20, wireType 0 =*/160).int32(message.videoPlaybackUrl);
            if (message.statusRanking != null && Object.hasOwnProperty.call(message, "statusRanking"))
                writer.uint32(/* id 21, wireType 0 =*/168).int32(message.statusRanking);
            if (message.voipIndividualVideo != null && Object.hasOwnProperty.call(message, "voipIndividualVideo"))
                writer.uint32(/* id 22, wireType 0 =*/176).int32(message.voipIndividualVideo);
            if (message.thirdPartyStickers != null && Object.hasOwnProperty.call(message, "thirdPartyStickers"))
                writer.uint32(/* id 23, wireType 0 =*/184).int32(message.thirdPartyStickers);
            if (message.frequentlyForwardedSetting != null && Object.hasOwnProperty.call(message, "frequentlyForwardedSetting"))
                writer.uint32(/* id 24, wireType 0 =*/192).int32(message.frequentlyForwardedSetting);
            if (message.groupsV4JoinPermission != null && Object.hasOwnProperty.call(message, "groupsV4JoinPermission"))
                writer.uint32(/* id 25, wireType 0 =*/200).int32(message.groupsV4JoinPermission);
            if (message.recentStickers != null && Object.hasOwnProperty.call(message, "recentStickers"))
                writer.uint32(/* id 26, wireType 0 =*/208).int32(message.recentStickers);
            if (message.catalog != null && Object.hasOwnProperty.call(message, "catalog"))
                writer.uint32(/* id 27, wireType 0 =*/216).int32(message.catalog);
            if (message.starredStickers != null && Object.hasOwnProperty.call(message, "starredStickers"))
                writer.uint32(/* id 28, wireType 0 =*/224).int32(message.starredStickers);
            if (message.voipGroupCall != null && Object.hasOwnProperty.call(message, "voipGroupCall"))
                writer.uint32(/* id 29, wireType 0 =*/232).int32(message.voipGroupCall);
            if (message.templateMessage != null && Object.hasOwnProperty.call(message, "templateMessage"))
                writer.uint32(/* id 30, wireType 0 =*/240).int32(message.templateMessage);
            if (message.templateMessageInteractivity != null && Object.hasOwnProperty.call(message, "templateMessageInteractivity"))
                writer.uint32(/* id 31, wireType 0 =*/248).int32(message.templateMessageInteractivity);
            if (message.ephemeralMessages != null && Object.hasOwnProperty.call(message, "ephemeralMessages"))
                writer.uint32(/* id 32, wireType 0 =*/256).int32(message.ephemeralMessages);
            if (message.e2ENotificationSync != null && Object.hasOwnProperty.call(message, "e2ENotificationSync"))
                writer.uint32(/* id 33, wireType 0 =*/264).int32(message.e2ENotificationSync);
            if (message.recentStickersV2 != null && Object.hasOwnProperty.call(message, "recentStickersV2"))
                writer.uint32(/* id 34, wireType 0 =*/272).int32(message.recentStickersV2);
            if (message.syncdRelease1 != null && Object.hasOwnProperty.call(message, "syncdRelease1"))
                writer.uint32(/* id 35, wireType 0 =*/280).int32(message.syncdRelease1);
            return writer;
        };

        /**
         * Encodes the specified WebFeatures message, length delimited. Does not implicitly {@link Message.WebFeatures.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.WebFeatures
         * @static
         * @param {Message.IWebFeatures} message WebFeatures message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebFeatures.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WebFeatures message from the specified reader or buffer.
         * @function decode
         * @memberof Message.WebFeatures
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.WebFeatures} WebFeatures
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebFeatures.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.WebFeatures();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.labelsDisplay = reader.int32();
                    break;
                case 2:
                    message.voipIndividualOutgoing = reader.int32();
                    break;
                case 3:
                    message.groupsV3 = reader.int32();
                    break;
                case 4:
                    message.groupsV3Create = reader.int32();
                    break;
                case 5:
                    message.changeNumberV2 = reader.int32();
                    break;
                case 6:
                    message.queryStatusV3Thumbnail = reader.int32();
                    break;
                case 7:
                    message.liveLocations = reader.int32();
                    break;
                case 8:
                    message.queryVname = reader.int32();
                    break;
                case 9:
                    message.voipIndividualIncoming = reader.int32();
                    break;
                case 10:
                    message.quickRepliesQuery = reader.int32();
                    break;
                case 11:
                    message.payments = reader.int32();
                    break;
                case 12:
                    message.stickerPackQuery = reader.int32();
                    break;
                case 13:
                    message.liveLocationsFinal = reader.int32();
                    break;
                case 14:
                    message.labelsEdit = reader.int32();
                    break;
                case 15:
                    message.mediaUpload = reader.int32();
                    break;
                case 18:
                    message.mediaUploadRichQuickReplies = reader.int32();
                    break;
                case 19:
                    message.vnameV2 = reader.int32();
                    break;
                case 20:
                    message.videoPlaybackUrl = reader.int32();
                    break;
                case 21:
                    message.statusRanking = reader.int32();
                    break;
                case 22:
                    message.voipIndividualVideo = reader.int32();
                    break;
                case 23:
                    message.thirdPartyStickers = reader.int32();
                    break;
                case 24:
                    message.frequentlyForwardedSetting = reader.int32();
                    break;
                case 25:
                    message.groupsV4JoinPermission = reader.int32();
                    break;
                case 26:
                    message.recentStickers = reader.int32();
                    break;
                case 27:
                    message.catalog = reader.int32();
                    break;
                case 28:
                    message.starredStickers = reader.int32();
                    break;
                case 29:
                    message.voipGroupCall = reader.int32();
                    break;
                case 30:
                    message.templateMessage = reader.int32();
                    break;
                case 31:
                    message.templateMessageInteractivity = reader.int32();
                    break;
                case 32:
                    message.ephemeralMessages = reader.int32();
                    break;
                case 33:
                    message.e2ENotificationSync = reader.int32();
                    break;
                case 34:
                    message.recentStickersV2 = reader.int32();
                    break;
                case 35:
                    message.syncdRelease1 = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WebFeatures message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.WebFeatures
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.WebFeatures} WebFeatures
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebFeatures.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WebFeatures message.
         * @function verify
         * @memberof Message.WebFeatures
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WebFeatures.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.labelsDisplay != null && message.hasOwnProperty("labelsDisplay"))
                switch (message.labelsDisplay) {
                default:
                    return "labelsDisplay: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.voipIndividualOutgoing != null && message.hasOwnProperty("voipIndividualOutgoing"))
                switch (message.voipIndividualOutgoing) {
                default:
                    return "voipIndividualOutgoing: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.groupsV3 != null && message.hasOwnProperty("groupsV3"))
                switch (message.groupsV3) {
                default:
                    return "groupsV3: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.groupsV3Create != null && message.hasOwnProperty("groupsV3Create"))
                switch (message.groupsV3Create) {
                default:
                    return "groupsV3Create: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.changeNumberV2 != null && message.hasOwnProperty("changeNumberV2"))
                switch (message.changeNumberV2) {
                default:
                    return "changeNumberV2: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.queryStatusV3Thumbnail != null && message.hasOwnProperty("queryStatusV3Thumbnail"))
                switch (message.queryStatusV3Thumbnail) {
                default:
                    return "queryStatusV3Thumbnail: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.liveLocations != null && message.hasOwnProperty("liveLocations"))
                switch (message.liveLocations) {
                default:
                    return "liveLocations: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.queryVname != null && message.hasOwnProperty("queryVname"))
                switch (message.queryVname) {
                default:
                    return "queryVname: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.voipIndividualIncoming != null && message.hasOwnProperty("voipIndividualIncoming"))
                switch (message.voipIndividualIncoming) {
                default:
                    return "voipIndividualIncoming: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.quickRepliesQuery != null && message.hasOwnProperty("quickRepliesQuery"))
                switch (message.quickRepliesQuery) {
                default:
                    return "quickRepliesQuery: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.payments != null && message.hasOwnProperty("payments"))
                switch (message.payments) {
                default:
                    return "payments: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.stickerPackQuery != null && message.hasOwnProperty("stickerPackQuery"))
                switch (message.stickerPackQuery) {
                default:
                    return "stickerPackQuery: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.liveLocationsFinal != null && message.hasOwnProperty("liveLocationsFinal"))
                switch (message.liveLocationsFinal) {
                default:
                    return "liveLocationsFinal: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.labelsEdit != null && message.hasOwnProperty("labelsEdit"))
                switch (message.labelsEdit) {
                default:
                    return "labelsEdit: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.mediaUpload != null && message.hasOwnProperty("mediaUpload"))
                switch (message.mediaUpload) {
                default:
                    return "mediaUpload: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.mediaUploadRichQuickReplies != null && message.hasOwnProperty("mediaUploadRichQuickReplies"))
                switch (message.mediaUploadRichQuickReplies) {
                default:
                    return "mediaUploadRichQuickReplies: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.vnameV2 != null && message.hasOwnProperty("vnameV2"))
                switch (message.vnameV2) {
                default:
                    return "vnameV2: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.videoPlaybackUrl != null && message.hasOwnProperty("videoPlaybackUrl"))
                switch (message.videoPlaybackUrl) {
                default:
                    return "videoPlaybackUrl: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.statusRanking != null && message.hasOwnProperty("statusRanking"))
                switch (message.statusRanking) {
                default:
                    return "statusRanking: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.voipIndividualVideo != null && message.hasOwnProperty("voipIndividualVideo"))
                switch (message.voipIndividualVideo) {
                default:
                    return "voipIndividualVideo: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.thirdPartyStickers != null && message.hasOwnProperty("thirdPartyStickers"))
                switch (message.thirdPartyStickers) {
                default:
                    return "thirdPartyStickers: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.frequentlyForwardedSetting != null && message.hasOwnProperty("frequentlyForwardedSetting"))
                switch (message.frequentlyForwardedSetting) {
                default:
                    return "frequentlyForwardedSetting: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.groupsV4JoinPermission != null && message.hasOwnProperty("groupsV4JoinPermission"))
                switch (message.groupsV4JoinPermission) {
                default:
                    return "groupsV4JoinPermission: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.recentStickers != null && message.hasOwnProperty("recentStickers"))
                switch (message.recentStickers) {
                default:
                    return "recentStickers: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.catalog != null && message.hasOwnProperty("catalog"))
                switch (message.catalog) {
                default:
                    return "catalog: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.starredStickers != null && message.hasOwnProperty("starredStickers"))
                switch (message.starredStickers) {
                default:
                    return "starredStickers: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.voipGroupCall != null && message.hasOwnProperty("voipGroupCall"))
                switch (message.voipGroupCall) {
                default:
                    return "voipGroupCall: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.templateMessage != null && message.hasOwnProperty("templateMessage"))
                switch (message.templateMessage) {
                default:
                    return "templateMessage: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.templateMessageInteractivity != null && message.hasOwnProperty("templateMessageInteractivity"))
                switch (message.templateMessageInteractivity) {
                default:
                    return "templateMessageInteractivity: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.ephemeralMessages != null && message.hasOwnProperty("ephemeralMessages"))
                switch (message.ephemeralMessages) {
                default:
                    return "ephemeralMessages: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.e2ENotificationSync != null && message.hasOwnProperty("e2ENotificationSync"))
                switch (message.e2ENotificationSync) {
                default:
                    return "e2ENotificationSync: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.recentStickersV2 != null && message.hasOwnProperty("recentStickersV2"))
                switch (message.recentStickersV2) {
                default:
                    return "recentStickersV2: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.syncdRelease1 != null && message.hasOwnProperty("syncdRelease1"))
                switch (message.syncdRelease1) {
                default:
                    return "syncdRelease1: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a WebFeatures message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.WebFeatures
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.WebFeatures} WebFeatures
         */
        WebFeatures.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.WebFeatures)
                return object;
            var message = new $root.Message.WebFeatures();
            switch (object.labelsDisplay) {
            case "NOT_STARTED":
            case 0:
                message.labelsDisplay = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.labelsDisplay = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.labelsDisplay = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.labelsDisplay = 3;
                break;
            }
            switch (object.voipIndividualOutgoing) {
            case "NOT_STARTED":
            case 0:
                message.voipIndividualOutgoing = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.voipIndividualOutgoing = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.voipIndividualOutgoing = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.voipIndividualOutgoing = 3;
                break;
            }
            switch (object.groupsV3) {
            case "NOT_STARTED":
            case 0:
                message.groupsV3 = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.groupsV3 = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.groupsV3 = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.groupsV3 = 3;
                break;
            }
            switch (object.groupsV3Create) {
            case "NOT_STARTED":
            case 0:
                message.groupsV3Create = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.groupsV3Create = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.groupsV3Create = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.groupsV3Create = 3;
                break;
            }
            switch (object.changeNumberV2) {
            case "NOT_STARTED":
            case 0:
                message.changeNumberV2 = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.changeNumberV2 = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.changeNumberV2 = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.changeNumberV2 = 3;
                break;
            }
            switch (object.queryStatusV3Thumbnail) {
            case "NOT_STARTED":
            case 0:
                message.queryStatusV3Thumbnail = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.queryStatusV3Thumbnail = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.queryStatusV3Thumbnail = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.queryStatusV3Thumbnail = 3;
                break;
            }
            switch (object.liveLocations) {
            case "NOT_STARTED":
            case 0:
                message.liveLocations = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.liveLocations = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.liveLocations = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.liveLocations = 3;
                break;
            }
            switch (object.queryVname) {
            case "NOT_STARTED":
            case 0:
                message.queryVname = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.queryVname = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.queryVname = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.queryVname = 3;
                break;
            }
            switch (object.voipIndividualIncoming) {
            case "NOT_STARTED":
            case 0:
                message.voipIndividualIncoming = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.voipIndividualIncoming = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.voipIndividualIncoming = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.voipIndividualIncoming = 3;
                break;
            }
            switch (object.quickRepliesQuery) {
            case "NOT_STARTED":
            case 0:
                message.quickRepliesQuery = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.quickRepliesQuery = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.quickRepliesQuery = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.quickRepliesQuery = 3;
                break;
            }
            switch (object.payments) {
            case "NOT_STARTED":
            case 0:
                message.payments = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.payments = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.payments = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.payments = 3;
                break;
            }
            switch (object.stickerPackQuery) {
            case "NOT_STARTED":
            case 0:
                message.stickerPackQuery = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.stickerPackQuery = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.stickerPackQuery = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.stickerPackQuery = 3;
                break;
            }
            switch (object.liveLocationsFinal) {
            case "NOT_STARTED":
            case 0:
                message.liveLocationsFinal = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.liveLocationsFinal = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.liveLocationsFinal = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.liveLocationsFinal = 3;
                break;
            }
            switch (object.labelsEdit) {
            case "NOT_STARTED":
            case 0:
                message.labelsEdit = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.labelsEdit = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.labelsEdit = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.labelsEdit = 3;
                break;
            }
            switch (object.mediaUpload) {
            case "NOT_STARTED":
            case 0:
                message.mediaUpload = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.mediaUpload = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.mediaUpload = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.mediaUpload = 3;
                break;
            }
            switch (object.mediaUploadRichQuickReplies) {
            case "NOT_STARTED":
            case 0:
                message.mediaUploadRichQuickReplies = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.mediaUploadRichQuickReplies = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.mediaUploadRichQuickReplies = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.mediaUploadRichQuickReplies = 3;
                break;
            }
            switch (object.vnameV2) {
            case "NOT_STARTED":
            case 0:
                message.vnameV2 = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.vnameV2 = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.vnameV2 = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.vnameV2 = 3;
                break;
            }
            switch (object.videoPlaybackUrl) {
            case "NOT_STARTED":
            case 0:
                message.videoPlaybackUrl = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.videoPlaybackUrl = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.videoPlaybackUrl = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.videoPlaybackUrl = 3;
                break;
            }
            switch (object.statusRanking) {
            case "NOT_STARTED":
            case 0:
                message.statusRanking = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.statusRanking = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.statusRanking = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.statusRanking = 3;
                break;
            }
            switch (object.voipIndividualVideo) {
            case "NOT_STARTED":
            case 0:
                message.voipIndividualVideo = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.voipIndividualVideo = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.voipIndividualVideo = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.voipIndividualVideo = 3;
                break;
            }
            switch (object.thirdPartyStickers) {
            case "NOT_STARTED":
            case 0:
                message.thirdPartyStickers = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.thirdPartyStickers = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.thirdPartyStickers = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.thirdPartyStickers = 3;
                break;
            }
            switch (object.frequentlyForwardedSetting) {
            case "NOT_STARTED":
            case 0:
                message.frequentlyForwardedSetting = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.frequentlyForwardedSetting = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.frequentlyForwardedSetting = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.frequentlyForwardedSetting = 3;
                break;
            }
            switch (object.groupsV4JoinPermission) {
            case "NOT_STARTED":
            case 0:
                message.groupsV4JoinPermission = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.groupsV4JoinPermission = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.groupsV4JoinPermission = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.groupsV4JoinPermission = 3;
                break;
            }
            switch (object.recentStickers) {
            case "NOT_STARTED":
            case 0:
                message.recentStickers = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.recentStickers = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.recentStickers = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.recentStickers = 3;
                break;
            }
            switch (object.catalog) {
            case "NOT_STARTED":
            case 0:
                message.catalog = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.catalog = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.catalog = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.catalog = 3;
                break;
            }
            switch (object.starredStickers) {
            case "NOT_STARTED":
            case 0:
                message.starredStickers = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.starredStickers = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.starredStickers = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.starredStickers = 3;
                break;
            }
            switch (object.voipGroupCall) {
            case "NOT_STARTED":
            case 0:
                message.voipGroupCall = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.voipGroupCall = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.voipGroupCall = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.voipGroupCall = 3;
                break;
            }
            switch (object.templateMessage) {
            case "NOT_STARTED":
            case 0:
                message.templateMessage = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.templateMessage = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.templateMessage = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.templateMessage = 3;
                break;
            }
            switch (object.templateMessageInteractivity) {
            case "NOT_STARTED":
            case 0:
                message.templateMessageInteractivity = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.templateMessageInteractivity = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.templateMessageInteractivity = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.templateMessageInteractivity = 3;
                break;
            }
            switch (object.ephemeralMessages) {
            case "NOT_STARTED":
            case 0:
                message.ephemeralMessages = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.ephemeralMessages = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.ephemeralMessages = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.ephemeralMessages = 3;
                break;
            }
            switch (object.e2ENotificationSync) {
            case "NOT_STARTED":
            case 0:
                message.e2ENotificationSync = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.e2ENotificationSync = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.e2ENotificationSync = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.e2ENotificationSync = 3;
                break;
            }
            switch (object.recentStickersV2) {
            case "NOT_STARTED":
            case 0:
                message.recentStickersV2 = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.recentStickersV2 = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.recentStickersV2 = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.recentStickersV2 = 3;
                break;
            }
            switch (object.syncdRelease1) {
            case "NOT_STARTED":
            case 0:
                message.syncdRelease1 = 0;
                break;
            case "FORCE_UPGRADE":
            case 1:
                message.syncdRelease1 = 1;
                break;
            case "DEVELOPMENT":
            case 2:
                message.syncdRelease1 = 2;
                break;
            case "PRODUCTION":
            case 3:
                message.syncdRelease1 = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a WebFeatures message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.WebFeatures
         * @static
         * @param {Message.WebFeatures} message WebFeatures
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WebFeatures.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.labelsDisplay = options.enums === String ? "NOT_STARTED" : 0;
                object.voipIndividualOutgoing = options.enums === String ? "NOT_STARTED" : 0;
                object.groupsV3 = options.enums === String ? "NOT_STARTED" : 0;
                object.groupsV3Create = options.enums === String ? "NOT_STARTED" : 0;
                object.changeNumberV2 = options.enums === String ? "NOT_STARTED" : 0;
                object.queryStatusV3Thumbnail = options.enums === String ? "NOT_STARTED" : 0;
                object.liveLocations = options.enums === String ? "NOT_STARTED" : 0;
                object.queryVname = options.enums === String ? "NOT_STARTED" : 0;
                object.voipIndividualIncoming = options.enums === String ? "NOT_STARTED" : 0;
                object.quickRepliesQuery = options.enums === String ? "NOT_STARTED" : 0;
                object.payments = options.enums === String ? "NOT_STARTED" : 0;
                object.stickerPackQuery = options.enums === String ? "NOT_STARTED" : 0;
                object.liveLocationsFinal = options.enums === String ? "NOT_STARTED" : 0;
                object.labelsEdit = options.enums === String ? "NOT_STARTED" : 0;
                object.mediaUpload = options.enums === String ? "NOT_STARTED" : 0;
                object.mediaUploadRichQuickReplies = options.enums === String ? "NOT_STARTED" : 0;
                object.vnameV2 = options.enums === String ? "NOT_STARTED" : 0;
                object.videoPlaybackUrl = options.enums === String ? "NOT_STARTED" : 0;
                object.statusRanking = options.enums === String ? "NOT_STARTED" : 0;
                object.voipIndividualVideo = options.enums === String ? "NOT_STARTED" : 0;
                object.thirdPartyStickers = options.enums === String ? "NOT_STARTED" : 0;
                object.frequentlyForwardedSetting = options.enums === String ? "NOT_STARTED" : 0;
                object.groupsV4JoinPermission = options.enums === String ? "NOT_STARTED" : 0;
                object.recentStickers = options.enums === String ? "NOT_STARTED" : 0;
                object.catalog = options.enums === String ? "NOT_STARTED" : 0;
                object.starredStickers = options.enums === String ? "NOT_STARTED" : 0;
                object.voipGroupCall = options.enums === String ? "NOT_STARTED" : 0;
                object.templateMessage = options.enums === String ? "NOT_STARTED" : 0;
                object.templateMessageInteractivity = options.enums === String ? "NOT_STARTED" : 0;
                object.ephemeralMessages = options.enums === String ? "NOT_STARTED" : 0;
                object.e2ENotificationSync = options.enums === String ? "NOT_STARTED" : 0;
                object.recentStickersV2 = options.enums === String ? "NOT_STARTED" : 0;
                object.syncdRelease1 = options.enums === String ? "NOT_STARTED" : 0;
            }
            if (message.labelsDisplay != null && message.hasOwnProperty("labelsDisplay"))
                object.labelsDisplay = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.labelsDisplay] : message.labelsDisplay;
            if (message.voipIndividualOutgoing != null && message.hasOwnProperty("voipIndividualOutgoing"))
                object.voipIndividualOutgoing = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.voipIndividualOutgoing] : message.voipIndividualOutgoing;
            if (message.groupsV3 != null && message.hasOwnProperty("groupsV3"))
                object.groupsV3 = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.groupsV3] : message.groupsV3;
            if (message.groupsV3Create != null && message.hasOwnProperty("groupsV3Create"))
                object.groupsV3Create = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.groupsV3Create] : message.groupsV3Create;
            if (message.changeNumberV2 != null && message.hasOwnProperty("changeNumberV2"))
                object.changeNumberV2 = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.changeNumberV2] : message.changeNumberV2;
            if (message.queryStatusV3Thumbnail != null && message.hasOwnProperty("queryStatusV3Thumbnail"))
                object.queryStatusV3Thumbnail = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.queryStatusV3Thumbnail] : message.queryStatusV3Thumbnail;
            if (message.liveLocations != null && message.hasOwnProperty("liveLocations"))
                object.liveLocations = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.liveLocations] : message.liveLocations;
            if (message.queryVname != null && message.hasOwnProperty("queryVname"))
                object.queryVname = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.queryVname] : message.queryVname;
            if (message.voipIndividualIncoming != null && message.hasOwnProperty("voipIndividualIncoming"))
                object.voipIndividualIncoming = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.voipIndividualIncoming] : message.voipIndividualIncoming;
            if (message.quickRepliesQuery != null && message.hasOwnProperty("quickRepliesQuery"))
                object.quickRepliesQuery = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.quickRepliesQuery] : message.quickRepliesQuery;
            if (message.payments != null && message.hasOwnProperty("payments"))
                object.payments = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.payments] : message.payments;
            if (message.stickerPackQuery != null && message.hasOwnProperty("stickerPackQuery"))
                object.stickerPackQuery = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.stickerPackQuery] : message.stickerPackQuery;
            if (message.liveLocationsFinal != null && message.hasOwnProperty("liveLocationsFinal"))
                object.liveLocationsFinal = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.liveLocationsFinal] : message.liveLocationsFinal;
            if (message.labelsEdit != null && message.hasOwnProperty("labelsEdit"))
                object.labelsEdit = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.labelsEdit] : message.labelsEdit;
            if (message.mediaUpload != null && message.hasOwnProperty("mediaUpload"))
                object.mediaUpload = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.mediaUpload] : message.mediaUpload;
            if (message.mediaUploadRichQuickReplies != null && message.hasOwnProperty("mediaUploadRichQuickReplies"))
                object.mediaUploadRichQuickReplies = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.mediaUploadRichQuickReplies] : message.mediaUploadRichQuickReplies;
            if (message.vnameV2 != null && message.hasOwnProperty("vnameV2"))
                object.vnameV2 = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.vnameV2] : message.vnameV2;
            if (message.videoPlaybackUrl != null && message.hasOwnProperty("videoPlaybackUrl"))
                object.videoPlaybackUrl = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.videoPlaybackUrl] : message.videoPlaybackUrl;
            if (message.statusRanking != null && message.hasOwnProperty("statusRanking"))
                object.statusRanking = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.statusRanking] : message.statusRanking;
            if (message.voipIndividualVideo != null && message.hasOwnProperty("voipIndividualVideo"))
                object.voipIndividualVideo = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.voipIndividualVideo] : message.voipIndividualVideo;
            if (message.thirdPartyStickers != null && message.hasOwnProperty("thirdPartyStickers"))
                object.thirdPartyStickers = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.thirdPartyStickers] : message.thirdPartyStickers;
            if (message.frequentlyForwardedSetting != null && message.hasOwnProperty("frequentlyForwardedSetting"))
                object.frequentlyForwardedSetting = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.frequentlyForwardedSetting] : message.frequentlyForwardedSetting;
            if (message.groupsV4JoinPermission != null && message.hasOwnProperty("groupsV4JoinPermission"))
                object.groupsV4JoinPermission = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.groupsV4JoinPermission] : message.groupsV4JoinPermission;
            if (message.recentStickers != null && message.hasOwnProperty("recentStickers"))
                object.recentStickers = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.recentStickers] : message.recentStickers;
            if (message.catalog != null && message.hasOwnProperty("catalog"))
                object.catalog = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.catalog] : message.catalog;
            if (message.starredStickers != null && message.hasOwnProperty("starredStickers"))
                object.starredStickers = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.starredStickers] : message.starredStickers;
            if (message.voipGroupCall != null && message.hasOwnProperty("voipGroupCall"))
                object.voipGroupCall = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.voipGroupCall] : message.voipGroupCall;
            if (message.templateMessage != null && message.hasOwnProperty("templateMessage"))
                object.templateMessage = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.templateMessage] : message.templateMessage;
            if (message.templateMessageInteractivity != null && message.hasOwnProperty("templateMessageInteractivity"))
                object.templateMessageInteractivity = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.templateMessageInteractivity] : message.templateMessageInteractivity;
            if (message.ephemeralMessages != null && message.hasOwnProperty("ephemeralMessages"))
                object.ephemeralMessages = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.ephemeralMessages] : message.ephemeralMessages;
            if (message.e2ENotificationSync != null && message.hasOwnProperty("e2ENotificationSync"))
                object.e2ENotificationSync = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.e2ENotificationSync] : message.e2ENotificationSync;
            if (message.recentStickersV2 != null && message.hasOwnProperty("recentStickersV2"))
                object.recentStickersV2 = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.recentStickersV2] : message.recentStickersV2;
            if (message.syncdRelease1 != null && message.hasOwnProperty("syncdRelease1"))
                object.syncdRelease1 = options.enums === String ? $root.Message.WebFeatures.WEB_FEATURES_FLAG[message.syncdRelease1] : message.syncdRelease1;
            return object;
        };

        /**
         * Converts this WebFeatures to JSON.
         * @function toJSON
         * @memberof Message.WebFeatures
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WebFeatures.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * WEB_FEATURES_FLAG enum.
         * @name Message.WebFeatures.WEB_FEATURES_FLAG
         * @enum {number}
         * @property {number} NOT_STARTED=0 NOT_STARTED value
         * @property {number} FORCE_UPGRADE=1 FORCE_UPGRADE value
         * @property {number} DEVELOPMENT=2 DEVELOPMENT value
         * @property {number} PRODUCTION=3 PRODUCTION value
         */
        WebFeatures.WEB_FEATURES_FLAG = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NOT_STARTED"] = 0;
            values[valuesById[1] = "FORCE_UPGRADE"] = 1;
            values[valuesById[2] = "DEVELOPMENT"] = 2;
            values[valuesById[3] = "PRODUCTION"] = 3;
            return values;
        })();

        return WebFeatures;
    })();

    Message.TabletNotificationsInfo = (function() {

        /**
         * Properties of a TabletNotificationsInfo.
         * @memberof Message
         * @interface ITabletNotificationsInfo
         * @property {number|Long|null} [timestamp] TabletNotificationsInfo timestamp
         * @property {number|null} [unreadChats] TabletNotificationsInfo unreadChats
         * @property {number|null} [notifyMessageCount] TabletNotificationsInfo notifyMessageCount
         * @property {Array.<Message.INotificationMessageInfo>|null} [notifyMessage] TabletNotificationsInfo notifyMessage
         */

        /**
         * Constructs a new TabletNotificationsInfo.
         * @memberof Message
         * @classdesc Represents a TabletNotificationsInfo.
         * @implements ITabletNotificationsInfo
         * @constructor
         * @param {Message.ITabletNotificationsInfo=} [properties] Properties to set
         */
        function TabletNotificationsInfo(properties) {
            this.notifyMessage = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TabletNotificationsInfo timestamp.
         * @member {number|Long} timestamp
         * @memberof Message.TabletNotificationsInfo
         * @instance
         */
        TabletNotificationsInfo.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TabletNotificationsInfo unreadChats.
         * @member {number} unreadChats
         * @memberof Message.TabletNotificationsInfo
         * @instance
         */
        TabletNotificationsInfo.prototype.unreadChats = 0;

        /**
         * TabletNotificationsInfo notifyMessageCount.
         * @member {number} notifyMessageCount
         * @memberof Message.TabletNotificationsInfo
         * @instance
         */
        TabletNotificationsInfo.prototype.notifyMessageCount = 0;

        /**
         * TabletNotificationsInfo notifyMessage.
         * @member {Array.<Message.INotificationMessageInfo>} notifyMessage
         * @memberof Message.TabletNotificationsInfo
         * @instance
         */
        TabletNotificationsInfo.prototype.notifyMessage = $util.emptyArray;

        /**
         * Creates a new TabletNotificationsInfo instance using the specified properties.
         * @function create
         * @memberof Message.TabletNotificationsInfo
         * @static
         * @param {Message.ITabletNotificationsInfo=} [properties] Properties to set
         * @returns {Message.TabletNotificationsInfo} TabletNotificationsInfo instance
         */
        TabletNotificationsInfo.create = function create(properties) {
            return new TabletNotificationsInfo(properties);
        };

        /**
         * Encodes the specified TabletNotificationsInfo message. Does not implicitly {@link Message.TabletNotificationsInfo.verify|verify} messages.
         * @function encode
         * @memberof Message.TabletNotificationsInfo
         * @static
         * @param {Message.ITabletNotificationsInfo} message TabletNotificationsInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TabletNotificationsInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp);
            if (message.unreadChats != null && Object.hasOwnProperty.call(message, "unreadChats"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.unreadChats);
            if (message.notifyMessageCount != null && Object.hasOwnProperty.call(message, "notifyMessageCount"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.notifyMessageCount);
            if (message.notifyMessage != null && message.notifyMessage.length)
                for (var i = 0; i < message.notifyMessage.length; ++i)
                    $root.Message.NotificationMessageInfo.encode(message.notifyMessage[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TabletNotificationsInfo message, length delimited. Does not implicitly {@link Message.TabletNotificationsInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.TabletNotificationsInfo
         * @static
         * @param {Message.ITabletNotificationsInfo} message TabletNotificationsInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TabletNotificationsInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TabletNotificationsInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Message.TabletNotificationsInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.TabletNotificationsInfo} TabletNotificationsInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TabletNotificationsInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.TabletNotificationsInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.timestamp = reader.uint64();
                    break;
                case 3:
                    message.unreadChats = reader.uint32();
                    break;
                case 4:
                    message.notifyMessageCount = reader.uint32();
                    break;
                case 5:
                    if (!(message.notifyMessage && message.notifyMessage.length))
                        message.notifyMessage = [];
                    message.notifyMessage.push($root.Message.NotificationMessageInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TabletNotificationsInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.TabletNotificationsInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.TabletNotificationsInfo} TabletNotificationsInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TabletNotificationsInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TabletNotificationsInfo message.
         * @function verify
         * @memberof Message.TabletNotificationsInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TabletNotificationsInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.unreadChats != null && message.hasOwnProperty("unreadChats"))
                if (!$util.isInteger(message.unreadChats))
                    return "unreadChats: integer expected";
            if (message.notifyMessageCount != null && message.hasOwnProperty("notifyMessageCount"))
                if (!$util.isInteger(message.notifyMessageCount))
                    return "notifyMessageCount: integer expected";
            if (message.notifyMessage != null && message.hasOwnProperty("notifyMessage")) {
                if (!Array.isArray(message.notifyMessage))
                    return "notifyMessage: array expected";
                for (var i = 0; i < message.notifyMessage.length; ++i) {
                    var error = $root.Message.NotificationMessageInfo.verify(message.notifyMessage[i]);
                    if (error)
                        return "notifyMessage." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TabletNotificationsInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.TabletNotificationsInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.TabletNotificationsInfo} TabletNotificationsInfo
         */
        TabletNotificationsInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.TabletNotificationsInfo)
                return object;
            var message = new $root.Message.TabletNotificationsInfo();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            if (object.unreadChats != null)
                message.unreadChats = object.unreadChats >>> 0;
            if (object.notifyMessageCount != null)
                message.notifyMessageCount = object.notifyMessageCount >>> 0;
            if (object.notifyMessage) {
                if (!Array.isArray(object.notifyMessage))
                    throw TypeError(".Message.TabletNotificationsInfo.notifyMessage: array expected");
                message.notifyMessage = [];
                for (var i = 0; i < object.notifyMessage.length; ++i) {
                    if (typeof object.notifyMessage[i] !== "object")
                        throw TypeError(".Message.TabletNotificationsInfo.notifyMessage: object expected");
                    message.notifyMessage[i] = $root.Message.NotificationMessageInfo.fromObject(object.notifyMessage[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TabletNotificationsInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.TabletNotificationsInfo
         * @static
         * @param {Message.TabletNotificationsInfo} message TabletNotificationsInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TabletNotificationsInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.notifyMessage = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.unreadChats = 0;
                object.notifyMessageCount = 0;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            if (message.unreadChats != null && message.hasOwnProperty("unreadChats"))
                object.unreadChats = message.unreadChats;
            if (message.notifyMessageCount != null && message.hasOwnProperty("notifyMessageCount"))
                object.notifyMessageCount = message.notifyMessageCount;
            if (message.notifyMessage && message.notifyMessage.length) {
                object.notifyMessage = [];
                for (var j = 0; j < message.notifyMessage.length; ++j)
                    object.notifyMessage[j] = $root.Message.NotificationMessageInfo.toObject(message.notifyMessage[j], options);
            }
            return object;
        };

        /**
         * Converts this TabletNotificationsInfo to JSON.
         * @function toJSON
         * @memberof Message.TabletNotificationsInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TabletNotificationsInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TabletNotificationsInfo;
    })();

    Message.NotificationMessageInfo = (function() {

        /**
         * Properties of a NotificationMessageInfo.
         * @memberof Message
         * @interface INotificationMessageInfo
         * @property {Message.IMessageKey|null} [key] NotificationMessageInfo key
         * @property {Message.IMessage|null} [message] NotificationMessageInfo message
         * @property {number|Long|null} [messageTimestamp] NotificationMessageInfo messageTimestamp
         * @property {string|null} [participant] NotificationMessageInfo participant
         */

        /**
         * Constructs a new NotificationMessageInfo.
         * @memberof Message
         * @classdesc Represents a NotificationMessageInfo.
         * @implements INotificationMessageInfo
         * @constructor
         * @param {Message.INotificationMessageInfo=} [properties] Properties to set
         */
        function NotificationMessageInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NotificationMessageInfo key.
         * @member {Message.IMessageKey|null|undefined} key
         * @memberof Message.NotificationMessageInfo
         * @instance
         */
        NotificationMessageInfo.prototype.key = null;

        /**
         * NotificationMessageInfo message.
         * @member {Message.IMessage|null|undefined} message
         * @memberof Message.NotificationMessageInfo
         * @instance
         */
        NotificationMessageInfo.prototype.message = null;

        /**
         * NotificationMessageInfo messageTimestamp.
         * @member {number|Long} messageTimestamp
         * @memberof Message.NotificationMessageInfo
         * @instance
         */
        NotificationMessageInfo.prototype.messageTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * NotificationMessageInfo participant.
         * @member {string} participant
         * @memberof Message.NotificationMessageInfo
         * @instance
         */
        NotificationMessageInfo.prototype.participant = "";

        /**
         * Creates a new NotificationMessageInfo instance using the specified properties.
         * @function create
         * @memberof Message.NotificationMessageInfo
         * @static
         * @param {Message.INotificationMessageInfo=} [properties] Properties to set
         * @returns {Message.NotificationMessageInfo} NotificationMessageInfo instance
         */
        NotificationMessageInfo.create = function create(properties) {
            return new NotificationMessageInfo(properties);
        };

        /**
         * Encodes the specified NotificationMessageInfo message. Does not implicitly {@link Message.NotificationMessageInfo.verify|verify} messages.
         * @function encode
         * @memberof Message.NotificationMessageInfo
         * @static
         * @param {Message.INotificationMessageInfo} message NotificationMessageInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NotificationMessageInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                $root.Message.MessageKey.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                $root.Message.Message.encode(message.message, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.messageTimestamp != null && Object.hasOwnProperty.call(message, "messageTimestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageTimestamp);
            if (message.participant != null && Object.hasOwnProperty.call(message, "participant"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.participant);
            return writer;
        };

        /**
         * Encodes the specified NotificationMessageInfo message, length delimited. Does not implicitly {@link Message.NotificationMessageInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.NotificationMessageInfo
         * @static
         * @param {Message.INotificationMessageInfo} message NotificationMessageInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NotificationMessageInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NotificationMessageInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Message.NotificationMessageInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.NotificationMessageInfo} NotificationMessageInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NotificationMessageInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.NotificationMessageInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = $root.Message.MessageKey.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.message = $root.Message.Message.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.messageTimestamp = reader.uint64();
                    break;
                case 4:
                    message.participant = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NotificationMessageInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.NotificationMessageInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.NotificationMessageInfo} NotificationMessageInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NotificationMessageInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NotificationMessageInfo message.
         * @function verify
         * @memberof Message.NotificationMessageInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NotificationMessageInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key")) {
                var error = $root.Message.MessageKey.verify(message.key);
                if (error)
                    return "key." + error;
            }
            if (message.message != null && message.hasOwnProperty("message")) {
                var error = $root.Message.Message.verify(message.message);
                if (error)
                    return "message." + error;
            }
            if (message.messageTimestamp != null && message.hasOwnProperty("messageTimestamp"))
                if (!$util.isInteger(message.messageTimestamp) && !(message.messageTimestamp && $util.isInteger(message.messageTimestamp.low) && $util.isInteger(message.messageTimestamp.high)))
                    return "messageTimestamp: integer|Long expected";
            if (message.participant != null && message.hasOwnProperty("participant"))
                if (!$util.isString(message.participant))
                    return "participant: string expected";
            return null;
        };

        /**
         * Creates a NotificationMessageInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.NotificationMessageInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.NotificationMessageInfo} NotificationMessageInfo
         */
        NotificationMessageInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.NotificationMessageInfo)
                return object;
            var message = new $root.Message.NotificationMessageInfo();
            if (object.key != null) {
                if (typeof object.key !== "object")
                    throw TypeError(".Message.NotificationMessageInfo.key: object expected");
                message.key = $root.Message.MessageKey.fromObject(object.key);
            }
            if (object.message != null) {
                if (typeof object.message !== "object")
                    throw TypeError(".Message.NotificationMessageInfo.message: object expected");
                message.message = $root.Message.Message.fromObject(object.message);
            }
            if (object.messageTimestamp != null)
                if ($util.Long)
                    (message.messageTimestamp = $util.Long.fromValue(object.messageTimestamp)).unsigned = true;
                else if (typeof object.messageTimestamp === "string")
                    message.messageTimestamp = parseInt(object.messageTimestamp, 10);
                else if (typeof object.messageTimestamp === "number")
                    message.messageTimestamp = object.messageTimestamp;
                else if (typeof object.messageTimestamp === "object")
                    message.messageTimestamp = new $util.LongBits(object.messageTimestamp.low >>> 0, object.messageTimestamp.high >>> 0).toNumber(true);
            if (object.participant != null)
                message.participant = String(object.participant);
            return message;
        };

        /**
         * Creates a plain object from a NotificationMessageInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.NotificationMessageInfo
         * @static
         * @param {Message.NotificationMessageInfo} message NotificationMessageInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NotificationMessageInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.key = null;
                object.message = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.messageTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.messageTimestamp = options.longs === String ? "0" : 0;
                object.participant = "";
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = $root.Message.MessageKey.toObject(message.key, options);
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = $root.Message.Message.toObject(message.message, options);
            if (message.messageTimestamp != null && message.hasOwnProperty("messageTimestamp"))
                if (typeof message.messageTimestamp === "number")
                    object.messageTimestamp = options.longs === String ? String(message.messageTimestamp) : message.messageTimestamp;
                else
                    object.messageTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.messageTimestamp) : options.longs === Number ? new $util.LongBits(message.messageTimestamp.low >>> 0, message.messageTimestamp.high >>> 0).toNumber(true) : message.messageTimestamp;
            if (message.participant != null && message.hasOwnProperty("participant"))
                object.participant = message.participant;
            return object;
        };

        /**
         * Converts this NotificationMessageInfo to JSON.
         * @function toJSON
         * @memberof Message.NotificationMessageInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NotificationMessageInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NotificationMessageInfo;
    })();

    Message.WebNotificationsInfo = (function() {

        /**
         * Properties of a WebNotificationsInfo.
         * @memberof Message
         * @interface IWebNotificationsInfo
         * @property {number|Long|null} [timestamp] WebNotificationsInfo timestamp
         * @property {number|null} [unreadChats] WebNotificationsInfo unreadChats
         * @property {number|null} [notifyMessageCount] WebNotificationsInfo notifyMessageCount
         * @property {Array.<Message.IWebMessageInfo>|null} [notifyMessages] WebNotificationsInfo notifyMessages
         */

        /**
         * Constructs a new WebNotificationsInfo.
         * @memberof Message
         * @classdesc Represents a WebNotificationsInfo.
         * @implements IWebNotificationsInfo
         * @constructor
         * @param {Message.IWebNotificationsInfo=} [properties] Properties to set
         */
        function WebNotificationsInfo(properties) {
            this.notifyMessages = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WebNotificationsInfo timestamp.
         * @member {number|Long} timestamp
         * @memberof Message.WebNotificationsInfo
         * @instance
         */
        WebNotificationsInfo.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * WebNotificationsInfo unreadChats.
         * @member {number} unreadChats
         * @memberof Message.WebNotificationsInfo
         * @instance
         */
        WebNotificationsInfo.prototype.unreadChats = 0;

        /**
         * WebNotificationsInfo notifyMessageCount.
         * @member {number} notifyMessageCount
         * @memberof Message.WebNotificationsInfo
         * @instance
         */
        WebNotificationsInfo.prototype.notifyMessageCount = 0;

        /**
         * WebNotificationsInfo notifyMessages.
         * @member {Array.<Message.IWebMessageInfo>} notifyMessages
         * @memberof Message.WebNotificationsInfo
         * @instance
         */
        WebNotificationsInfo.prototype.notifyMessages = $util.emptyArray;

        /**
         * Creates a new WebNotificationsInfo instance using the specified properties.
         * @function create
         * @memberof Message.WebNotificationsInfo
         * @static
         * @param {Message.IWebNotificationsInfo=} [properties] Properties to set
         * @returns {Message.WebNotificationsInfo} WebNotificationsInfo instance
         */
        WebNotificationsInfo.create = function create(properties) {
            return new WebNotificationsInfo(properties);
        };

        /**
         * Encodes the specified WebNotificationsInfo message. Does not implicitly {@link Message.WebNotificationsInfo.verify|verify} messages.
         * @function encode
         * @memberof Message.WebNotificationsInfo
         * @static
         * @param {Message.IWebNotificationsInfo} message WebNotificationsInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebNotificationsInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp);
            if (message.unreadChats != null && Object.hasOwnProperty.call(message, "unreadChats"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.unreadChats);
            if (message.notifyMessageCount != null && Object.hasOwnProperty.call(message, "notifyMessageCount"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.notifyMessageCount);
            if (message.notifyMessages != null && message.notifyMessages.length)
                for (var i = 0; i < message.notifyMessages.length; ++i)
                    $root.Message.WebMessageInfo.encode(message.notifyMessages[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WebNotificationsInfo message, length delimited. Does not implicitly {@link Message.WebNotificationsInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.WebNotificationsInfo
         * @static
         * @param {Message.IWebNotificationsInfo} message WebNotificationsInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebNotificationsInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WebNotificationsInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Message.WebNotificationsInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.WebNotificationsInfo} WebNotificationsInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebNotificationsInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.WebNotificationsInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.timestamp = reader.uint64();
                    break;
                case 3:
                    message.unreadChats = reader.uint32();
                    break;
                case 4:
                    message.notifyMessageCount = reader.uint32();
                    break;
                case 5:
                    if (!(message.notifyMessages && message.notifyMessages.length))
                        message.notifyMessages = [];
                    message.notifyMessages.push($root.Message.WebMessageInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WebNotificationsInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.WebNotificationsInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.WebNotificationsInfo} WebNotificationsInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebNotificationsInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WebNotificationsInfo message.
         * @function verify
         * @memberof Message.WebNotificationsInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WebNotificationsInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.unreadChats != null && message.hasOwnProperty("unreadChats"))
                if (!$util.isInteger(message.unreadChats))
                    return "unreadChats: integer expected";
            if (message.notifyMessageCount != null && message.hasOwnProperty("notifyMessageCount"))
                if (!$util.isInteger(message.notifyMessageCount))
                    return "notifyMessageCount: integer expected";
            if (message.notifyMessages != null && message.hasOwnProperty("notifyMessages")) {
                if (!Array.isArray(message.notifyMessages))
                    return "notifyMessages: array expected";
                for (var i = 0; i < message.notifyMessages.length; ++i) {
                    var error = $root.Message.WebMessageInfo.verify(message.notifyMessages[i]);
                    if (error)
                        return "notifyMessages." + error;
                }
            }
            return null;
        };

        /**
         * Creates a WebNotificationsInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.WebNotificationsInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.WebNotificationsInfo} WebNotificationsInfo
         */
        WebNotificationsInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.WebNotificationsInfo)
                return object;
            var message = new $root.Message.WebNotificationsInfo();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            if (object.unreadChats != null)
                message.unreadChats = object.unreadChats >>> 0;
            if (object.notifyMessageCount != null)
                message.notifyMessageCount = object.notifyMessageCount >>> 0;
            if (object.notifyMessages) {
                if (!Array.isArray(object.notifyMessages))
                    throw TypeError(".Message.WebNotificationsInfo.notifyMessages: array expected");
                message.notifyMessages = [];
                for (var i = 0; i < object.notifyMessages.length; ++i) {
                    if (typeof object.notifyMessages[i] !== "object")
                        throw TypeError(".Message.WebNotificationsInfo.notifyMessages: object expected");
                    message.notifyMessages[i] = $root.Message.WebMessageInfo.fromObject(object.notifyMessages[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a WebNotificationsInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.WebNotificationsInfo
         * @static
         * @param {Message.WebNotificationsInfo} message WebNotificationsInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WebNotificationsInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.notifyMessages = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.unreadChats = 0;
                object.notifyMessageCount = 0;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            if (message.unreadChats != null && message.hasOwnProperty("unreadChats"))
                object.unreadChats = message.unreadChats;
            if (message.notifyMessageCount != null && message.hasOwnProperty("notifyMessageCount"))
                object.notifyMessageCount = message.notifyMessageCount;
            if (message.notifyMessages && message.notifyMessages.length) {
                object.notifyMessages = [];
                for (var j = 0; j < message.notifyMessages.length; ++j)
                    object.notifyMessages[j] = $root.Message.WebMessageInfo.toObject(message.notifyMessages[j], options);
            }
            return object;
        };

        /**
         * Converts this WebNotificationsInfo to JSON.
         * @function toJSON
         * @memberof Message.WebNotificationsInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WebNotificationsInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WebNotificationsInfo;
    })();

    Message.PaymentInfo = (function() {

        /**
         * Properties of a PaymentInfo.
         * @memberof Message
         * @interface IPaymentInfo
         * @property {Message.PaymentInfo.PAYMENT_INFO_CURRENCY|null} [currencyDeprecated] PaymentInfo currencyDeprecated
         * @property {number|Long|null} [amount1000] PaymentInfo amount1000
         * @property {string|null} [receiverJid] PaymentInfo receiverJid
         * @property {Message.PaymentInfo.PAYMENT_INFO_STATUS|null} [status] PaymentInfo status
         * @property {number|Long|null} [transactionTimestamp] PaymentInfo transactionTimestamp
         * @property {Message.IMessageKey|null} [requestMessageKey] PaymentInfo requestMessageKey
         * @property {number|Long|null} [expiryTimestamp] PaymentInfo expiryTimestamp
         * @property {boolean|null} [futureproofed] PaymentInfo futureproofed
         * @property {string|null} [currency] PaymentInfo currency
         * @property {Message.PaymentInfo.PAYMENT_INFO_TXNSTATUS|null} [txnStatus] PaymentInfo txnStatus
         */

        /**
         * Constructs a new PaymentInfo.
         * @memberof Message
         * @classdesc Represents a PaymentInfo.
         * @implements IPaymentInfo
         * @constructor
         * @param {Message.IPaymentInfo=} [properties] Properties to set
         */
        function PaymentInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PaymentInfo currencyDeprecated.
         * @member {Message.PaymentInfo.PAYMENT_INFO_CURRENCY} currencyDeprecated
         * @memberof Message.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.currencyDeprecated = 0;

        /**
         * PaymentInfo amount1000.
         * @member {number|Long} amount1000
         * @memberof Message.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.amount1000 = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PaymentInfo receiverJid.
         * @member {string} receiverJid
         * @memberof Message.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.receiverJid = "";

        /**
         * PaymentInfo status.
         * @member {Message.PaymentInfo.PAYMENT_INFO_STATUS} status
         * @memberof Message.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.status = 0;

        /**
         * PaymentInfo transactionTimestamp.
         * @member {number|Long} transactionTimestamp
         * @memberof Message.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.transactionTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PaymentInfo requestMessageKey.
         * @member {Message.IMessageKey|null|undefined} requestMessageKey
         * @memberof Message.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.requestMessageKey = null;

        /**
         * PaymentInfo expiryTimestamp.
         * @member {number|Long} expiryTimestamp
         * @memberof Message.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.expiryTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PaymentInfo futureproofed.
         * @member {boolean} futureproofed
         * @memberof Message.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.futureproofed = false;

        /**
         * PaymentInfo currency.
         * @member {string} currency
         * @memberof Message.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.currency = "";

        /**
         * PaymentInfo txnStatus.
         * @member {Message.PaymentInfo.PAYMENT_INFO_TXNSTATUS} txnStatus
         * @memberof Message.PaymentInfo
         * @instance
         */
        PaymentInfo.prototype.txnStatus = 0;

        /**
         * Creates a new PaymentInfo instance using the specified properties.
         * @function create
         * @memberof Message.PaymentInfo
         * @static
         * @param {Message.IPaymentInfo=} [properties] Properties to set
         * @returns {Message.PaymentInfo} PaymentInfo instance
         */
        PaymentInfo.create = function create(properties) {
            return new PaymentInfo(properties);
        };

        /**
         * Encodes the specified PaymentInfo message. Does not implicitly {@link Message.PaymentInfo.verify|verify} messages.
         * @function encode
         * @memberof Message.PaymentInfo
         * @static
         * @param {Message.IPaymentInfo} message PaymentInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currencyDeprecated != null && Object.hasOwnProperty.call(message, "currencyDeprecated"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.currencyDeprecated);
            if (message.amount1000 != null && Object.hasOwnProperty.call(message, "amount1000"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.amount1000);
            if (message.receiverJid != null && Object.hasOwnProperty.call(message, "receiverJid"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.receiverJid);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.status);
            if (message.transactionTimestamp != null && Object.hasOwnProperty.call(message, "transactionTimestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.transactionTimestamp);
            if (message.requestMessageKey != null && Object.hasOwnProperty.call(message, "requestMessageKey"))
                $root.Message.MessageKey.encode(message.requestMessageKey, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.expiryTimestamp != null && Object.hasOwnProperty.call(message, "expiryTimestamp"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.expiryTimestamp);
            if (message.futureproofed != null && Object.hasOwnProperty.call(message, "futureproofed"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.futureproofed);
            if (message.currency != null && Object.hasOwnProperty.call(message, "currency"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.currency);
            if (message.txnStatus != null && Object.hasOwnProperty.call(message, "txnStatus"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.txnStatus);
            return writer;
        };

        /**
         * Encodes the specified PaymentInfo message, length delimited. Does not implicitly {@link Message.PaymentInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.PaymentInfo
         * @static
         * @param {Message.IPaymentInfo} message PaymentInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PaymentInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Message.PaymentInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.PaymentInfo} PaymentInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.PaymentInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.currencyDeprecated = reader.int32();
                    break;
                case 2:
                    message.amount1000 = reader.uint64();
                    break;
                case 3:
                    message.receiverJid = reader.string();
                    break;
                case 4:
                    message.status = reader.int32();
                    break;
                case 5:
                    message.transactionTimestamp = reader.uint64();
                    break;
                case 6:
                    message.requestMessageKey = $root.Message.MessageKey.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.expiryTimestamp = reader.uint64();
                    break;
                case 8:
                    message.futureproofed = reader.bool();
                    break;
                case 9:
                    message.currency = reader.string();
                    break;
                case 10:
                    message.txnStatus = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PaymentInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.PaymentInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.PaymentInfo} PaymentInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PaymentInfo message.
         * @function verify
         * @memberof Message.PaymentInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PaymentInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currencyDeprecated != null && message.hasOwnProperty("currencyDeprecated"))
                switch (message.currencyDeprecated) {
                default:
                    return "currencyDeprecated: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.amount1000 != null && message.hasOwnProperty("amount1000"))
                if (!$util.isInteger(message.amount1000) && !(message.amount1000 && $util.isInteger(message.amount1000.low) && $util.isInteger(message.amount1000.high)))
                    return "amount1000: integer|Long expected";
            if (message.receiverJid != null && message.hasOwnProperty("receiverJid"))
                if (!$util.isString(message.receiverJid))
                    return "receiverJid: string expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                    break;
                }
            if (message.transactionTimestamp != null && message.hasOwnProperty("transactionTimestamp"))
                if (!$util.isInteger(message.transactionTimestamp) && !(message.transactionTimestamp && $util.isInteger(message.transactionTimestamp.low) && $util.isInteger(message.transactionTimestamp.high)))
                    return "transactionTimestamp: integer|Long expected";
            if (message.requestMessageKey != null && message.hasOwnProperty("requestMessageKey")) {
                var error = $root.Message.MessageKey.verify(message.requestMessageKey);
                if (error)
                    return "requestMessageKey." + error;
            }
            if (message.expiryTimestamp != null && message.hasOwnProperty("expiryTimestamp"))
                if (!$util.isInteger(message.expiryTimestamp) && !(message.expiryTimestamp && $util.isInteger(message.expiryTimestamp.low) && $util.isInteger(message.expiryTimestamp.high)))
                    return "expiryTimestamp: integer|Long expected";
            if (message.futureproofed != null && message.hasOwnProperty("futureproofed"))
                if (typeof message.futureproofed !== "boolean")
                    return "futureproofed: boolean expected";
            if (message.currency != null && message.hasOwnProperty("currency"))
                if (!$util.isString(message.currency))
                    return "currency: string expected";
            if (message.txnStatus != null && message.hasOwnProperty("txnStatus"))
                switch (message.txnStatus) {
                default:
                    return "txnStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                    break;
                }
            return null;
        };

        /**
         * Creates a PaymentInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.PaymentInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.PaymentInfo} PaymentInfo
         */
        PaymentInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.PaymentInfo)
                return object;
            var message = new $root.Message.PaymentInfo();
            switch (object.currencyDeprecated) {
            case "UNKNOWN_CURRENCY":
            case 0:
                message.currencyDeprecated = 0;
                break;
            case "INR":
            case 1:
                message.currencyDeprecated = 1;
                break;
            }
            if (object.amount1000 != null)
                if ($util.Long)
                    (message.amount1000 = $util.Long.fromValue(object.amount1000)).unsigned = true;
                else if (typeof object.amount1000 === "string")
                    message.amount1000 = parseInt(object.amount1000, 10);
                else if (typeof object.amount1000 === "number")
                    message.amount1000 = object.amount1000;
                else if (typeof object.amount1000 === "object")
                    message.amount1000 = new $util.LongBits(object.amount1000.low >>> 0, object.amount1000.high >>> 0).toNumber(true);
            if (object.receiverJid != null)
                message.receiverJid = String(object.receiverJid);
            switch (object.status) {
            case "UNKNOWN_STATUS":
            case 0:
                message.status = 0;
                break;
            case "PROCESSING":
            case 1:
                message.status = 1;
                break;
            case "SENT":
            case 2:
                message.status = 2;
                break;
            case "NEED_TO_ACCEPT":
            case 3:
                message.status = 3;
                break;
            case "COMPLETE":
            case 4:
                message.status = 4;
                break;
            case "COULD_NOT_COMPLETE":
            case 5:
                message.status = 5;
                break;
            case "REFUNDED":
            case 6:
                message.status = 6;
                break;
            case "EXPIRED":
            case 7:
                message.status = 7;
                break;
            case "REJECTED":
            case 8:
                message.status = 8;
                break;
            case "CANCELLED":
            case 9:
                message.status = 9;
                break;
            case "WAITING_FOR_PAYER":
            case 10:
                message.status = 10;
                break;
            case "WAITING":
            case 11:
                message.status = 11;
                break;
            }
            if (object.transactionTimestamp != null)
                if ($util.Long)
                    (message.transactionTimestamp = $util.Long.fromValue(object.transactionTimestamp)).unsigned = true;
                else if (typeof object.transactionTimestamp === "string")
                    message.transactionTimestamp = parseInt(object.transactionTimestamp, 10);
                else if (typeof object.transactionTimestamp === "number")
                    message.transactionTimestamp = object.transactionTimestamp;
                else if (typeof object.transactionTimestamp === "object")
                    message.transactionTimestamp = new $util.LongBits(object.transactionTimestamp.low >>> 0, object.transactionTimestamp.high >>> 0).toNumber(true);
            if (object.requestMessageKey != null) {
                if (typeof object.requestMessageKey !== "object")
                    throw TypeError(".Message.PaymentInfo.requestMessageKey: object expected");
                message.requestMessageKey = $root.Message.MessageKey.fromObject(object.requestMessageKey);
            }
            if (object.expiryTimestamp != null)
                if ($util.Long)
                    (message.expiryTimestamp = $util.Long.fromValue(object.expiryTimestamp)).unsigned = true;
                else if (typeof object.expiryTimestamp === "string")
                    message.expiryTimestamp = parseInt(object.expiryTimestamp, 10);
                else if (typeof object.expiryTimestamp === "number")
                    message.expiryTimestamp = object.expiryTimestamp;
                else if (typeof object.expiryTimestamp === "object")
                    message.expiryTimestamp = new $util.LongBits(object.expiryTimestamp.low >>> 0, object.expiryTimestamp.high >>> 0).toNumber(true);
            if (object.futureproofed != null)
                message.futureproofed = Boolean(object.futureproofed);
            if (object.currency != null)
                message.currency = String(object.currency);
            switch (object.txnStatus) {
            case "UNKNOWN":
            case 0:
                message.txnStatus = 0;
                break;
            case "PENDING_SETUP":
            case 1:
                message.txnStatus = 1;
                break;
            case "PENDING_RECEIVER_SETUP":
            case 2:
                message.txnStatus = 2;
                break;
            case "INIT":
            case 3:
                message.txnStatus = 3;
                break;
            case "SUCCESS":
            case 4:
                message.txnStatus = 4;
                break;
            case "COMPLETED":
            case 5:
                message.txnStatus = 5;
                break;
            case "FAILED":
            case 6:
                message.txnStatus = 6;
                break;
            case "FAILED_RISK":
            case 7:
                message.txnStatus = 7;
                break;
            case "FAILED_PROCESSING":
            case 8:
                message.txnStatus = 8;
                break;
            case "FAILED_RECEIVER_PROCESSING":
            case 9:
                message.txnStatus = 9;
                break;
            case "FAILED_DA":
            case 10:
                message.txnStatus = 10;
                break;
            case "FAILED_DA_FINAL":
            case 11:
                message.txnStatus = 11;
                break;
            case "REFUNDED_TXN":
            case 12:
                message.txnStatus = 12;
                break;
            case "REFUND_FAILED":
            case 13:
                message.txnStatus = 13;
                break;
            case "REFUND_FAILED_PROCESSING":
            case 14:
                message.txnStatus = 14;
                break;
            case "REFUND_FAILED_DA":
            case 15:
                message.txnStatus = 15;
                break;
            case "EXPIRED_TXN":
            case 16:
                message.txnStatus = 16;
                break;
            case "AUTH_CANCELED":
            case 17:
                message.txnStatus = 17;
                break;
            case "AUTH_CANCEL_FAILED_PROCESSING":
            case 18:
                message.txnStatus = 18;
                break;
            case "AUTH_CANCEL_FAILED":
            case 19:
                message.txnStatus = 19;
                break;
            case "COLLECT_INIT":
            case 20:
                message.txnStatus = 20;
                break;
            case "COLLECT_SUCCESS":
            case 21:
                message.txnStatus = 21;
                break;
            case "COLLECT_FAILED":
            case 22:
                message.txnStatus = 22;
                break;
            case "COLLECT_FAILED_RISK":
            case 23:
                message.txnStatus = 23;
                break;
            case "COLLECT_REJECTED":
            case 24:
                message.txnStatus = 24;
                break;
            case "COLLECT_EXPIRED":
            case 25:
                message.txnStatus = 25;
                break;
            case "COLLECT_CANCELED":
            case 26:
                message.txnStatus = 26;
                break;
            case "COLLECT_CANCELLING":
            case 27:
                message.txnStatus = 27;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a PaymentInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.PaymentInfo
         * @static
         * @param {Message.PaymentInfo} message PaymentInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PaymentInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.currencyDeprecated = options.enums === String ? "UNKNOWN_CURRENCY" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.amount1000 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount1000 = options.longs === String ? "0" : 0;
                object.receiverJid = "";
                object.status = options.enums === String ? "UNKNOWN_STATUS" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.transactionTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.transactionTimestamp = options.longs === String ? "0" : 0;
                object.requestMessageKey = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.expiryTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiryTimestamp = options.longs === String ? "0" : 0;
                object.futureproofed = false;
                object.currency = "";
                object.txnStatus = options.enums === String ? "UNKNOWN" : 0;
            }
            if (message.currencyDeprecated != null && message.hasOwnProperty("currencyDeprecated"))
                object.currencyDeprecated = options.enums === String ? $root.Message.PaymentInfo.PAYMENT_INFO_CURRENCY[message.currencyDeprecated] : message.currencyDeprecated;
            if (message.amount1000 != null && message.hasOwnProperty("amount1000"))
                if (typeof message.amount1000 === "number")
                    object.amount1000 = options.longs === String ? String(message.amount1000) : message.amount1000;
                else
                    object.amount1000 = options.longs === String ? $util.Long.prototype.toString.call(message.amount1000) : options.longs === Number ? new $util.LongBits(message.amount1000.low >>> 0, message.amount1000.high >>> 0).toNumber(true) : message.amount1000;
            if (message.receiverJid != null && message.hasOwnProperty("receiverJid"))
                object.receiverJid = message.receiverJid;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.Message.PaymentInfo.PAYMENT_INFO_STATUS[message.status] : message.status;
            if (message.transactionTimestamp != null && message.hasOwnProperty("transactionTimestamp"))
                if (typeof message.transactionTimestamp === "number")
                    object.transactionTimestamp = options.longs === String ? String(message.transactionTimestamp) : message.transactionTimestamp;
                else
                    object.transactionTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.transactionTimestamp) : options.longs === Number ? new $util.LongBits(message.transactionTimestamp.low >>> 0, message.transactionTimestamp.high >>> 0).toNumber(true) : message.transactionTimestamp;
            if (message.requestMessageKey != null && message.hasOwnProperty("requestMessageKey"))
                object.requestMessageKey = $root.Message.MessageKey.toObject(message.requestMessageKey, options);
            if (message.expiryTimestamp != null && message.hasOwnProperty("expiryTimestamp"))
                if (typeof message.expiryTimestamp === "number")
                    object.expiryTimestamp = options.longs === String ? String(message.expiryTimestamp) : message.expiryTimestamp;
                else
                    object.expiryTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.expiryTimestamp) : options.longs === Number ? new $util.LongBits(message.expiryTimestamp.low >>> 0, message.expiryTimestamp.high >>> 0).toNumber(true) : message.expiryTimestamp;
            if (message.futureproofed != null && message.hasOwnProperty("futureproofed"))
                object.futureproofed = message.futureproofed;
            if (message.currency != null && message.hasOwnProperty("currency"))
                object.currency = message.currency;
            if (message.txnStatus != null && message.hasOwnProperty("txnStatus"))
                object.txnStatus = options.enums === String ? $root.Message.PaymentInfo.PAYMENT_INFO_TXNSTATUS[message.txnStatus] : message.txnStatus;
            return object;
        };

        /**
         * Converts this PaymentInfo to JSON.
         * @function toJSON
         * @memberof Message.PaymentInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PaymentInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * PAYMENT_INFO_CURRENCY enum.
         * @name Message.PaymentInfo.PAYMENT_INFO_CURRENCY
         * @enum {number}
         * @property {number} UNKNOWN_CURRENCY=0 UNKNOWN_CURRENCY value
         * @property {number} INR=1 INR value
         */
        PaymentInfo.PAYMENT_INFO_CURRENCY = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_CURRENCY"] = 0;
            values[valuesById[1] = "INR"] = 1;
            return values;
        })();

        /**
         * PAYMENT_INFO_STATUS enum.
         * @name Message.PaymentInfo.PAYMENT_INFO_STATUS
         * @enum {number}
         * @property {number} UNKNOWN_STATUS=0 UNKNOWN_STATUS value
         * @property {number} PROCESSING=1 PROCESSING value
         * @property {number} SENT=2 SENT value
         * @property {number} NEED_TO_ACCEPT=3 NEED_TO_ACCEPT value
         * @property {number} COMPLETE=4 COMPLETE value
         * @property {number} COULD_NOT_COMPLETE=5 COULD_NOT_COMPLETE value
         * @property {number} REFUNDED=6 REFUNDED value
         * @property {number} EXPIRED=7 EXPIRED value
         * @property {number} REJECTED=8 REJECTED value
         * @property {number} CANCELLED=9 CANCELLED value
         * @property {number} WAITING_FOR_PAYER=10 WAITING_FOR_PAYER value
         * @property {number} WAITING=11 WAITING value
         */
        PaymentInfo.PAYMENT_INFO_STATUS = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_STATUS"] = 0;
            values[valuesById[1] = "PROCESSING"] = 1;
            values[valuesById[2] = "SENT"] = 2;
            values[valuesById[3] = "NEED_TO_ACCEPT"] = 3;
            values[valuesById[4] = "COMPLETE"] = 4;
            values[valuesById[5] = "COULD_NOT_COMPLETE"] = 5;
            values[valuesById[6] = "REFUNDED"] = 6;
            values[valuesById[7] = "EXPIRED"] = 7;
            values[valuesById[8] = "REJECTED"] = 8;
            values[valuesById[9] = "CANCELLED"] = 9;
            values[valuesById[10] = "WAITING_FOR_PAYER"] = 10;
            values[valuesById[11] = "WAITING"] = 11;
            return values;
        })();

        /**
         * PAYMENT_INFO_TXNSTATUS enum.
         * @name Message.PaymentInfo.PAYMENT_INFO_TXNSTATUS
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} PENDING_SETUP=1 PENDING_SETUP value
         * @property {number} PENDING_RECEIVER_SETUP=2 PENDING_RECEIVER_SETUP value
         * @property {number} INIT=3 INIT value
         * @property {number} SUCCESS=4 SUCCESS value
         * @property {number} COMPLETED=5 COMPLETED value
         * @property {number} FAILED=6 FAILED value
         * @property {number} FAILED_RISK=7 FAILED_RISK value
         * @property {number} FAILED_PROCESSING=8 FAILED_PROCESSING value
         * @property {number} FAILED_RECEIVER_PROCESSING=9 FAILED_RECEIVER_PROCESSING value
         * @property {number} FAILED_DA=10 FAILED_DA value
         * @property {number} FAILED_DA_FINAL=11 FAILED_DA_FINAL value
         * @property {number} REFUNDED_TXN=12 REFUNDED_TXN value
         * @property {number} REFUND_FAILED=13 REFUND_FAILED value
         * @property {number} REFUND_FAILED_PROCESSING=14 REFUND_FAILED_PROCESSING value
         * @property {number} REFUND_FAILED_DA=15 REFUND_FAILED_DA value
         * @property {number} EXPIRED_TXN=16 EXPIRED_TXN value
         * @property {number} AUTH_CANCELED=17 AUTH_CANCELED value
         * @property {number} AUTH_CANCEL_FAILED_PROCESSING=18 AUTH_CANCEL_FAILED_PROCESSING value
         * @property {number} AUTH_CANCEL_FAILED=19 AUTH_CANCEL_FAILED value
         * @property {number} COLLECT_INIT=20 COLLECT_INIT value
         * @property {number} COLLECT_SUCCESS=21 COLLECT_SUCCESS value
         * @property {number} COLLECT_FAILED=22 COLLECT_FAILED value
         * @property {number} COLLECT_FAILED_RISK=23 COLLECT_FAILED_RISK value
         * @property {number} COLLECT_REJECTED=24 COLLECT_REJECTED value
         * @property {number} COLLECT_EXPIRED=25 COLLECT_EXPIRED value
         * @property {number} COLLECT_CANCELED=26 COLLECT_CANCELED value
         * @property {number} COLLECT_CANCELLING=27 COLLECT_CANCELLING value
         */
        PaymentInfo.PAYMENT_INFO_TXNSTATUS = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "PENDING_SETUP"] = 1;
            values[valuesById[2] = "PENDING_RECEIVER_SETUP"] = 2;
            values[valuesById[3] = "INIT"] = 3;
            values[valuesById[4] = "SUCCESS"] = 4;
            values[valuesById[5] = "COMPLETED"] = 5;
            values[valuesById[6] = "FAILED"] = 6;
            values[valuesById[7] = "FAILED_RISK"] = 7;
            values[valuesById[8] = "FAILED_PROCESSING"] = 8;
            values[valuesById[9] = "FAILED_RECEIVER_PROCESSING"] = 9;
            values[valuesById[10] = "FAILED_DA"] = 10;
            values[valuesById[11] = "FAILED_DA_FINAL"] = 11;
            values[valuesById[12] = "REFUNDED_TXN"] = 12;
            values[valuesById[13] = "REFUND_FAILED"] = 13;
            values[valuesById[14] = "REFUND_FAILED_PROCESSING"] = 14;
            values[valuesById[15] = "REFUND_FAILED_DA"] = 15;
            values[valuesById[16] = "EXPIRED_TXN"] = 16;
            values[valuesById[17] = "AUTH_CANCELED"] = 17;
            values[valuesById[18] = "AUTH_CANCEL_FAILED_PROCESSING"] = 18;
            values[valuesById[19] = "AUTH_CANCEL_FAILED"] = 19;
            values[valuesById[20] = "COLLECT_INIT"] = 20;
            values[valuesById[21] = "COLLECT_SUCCESS"] = 21;
            values[valuesById[22] = "COLLECT_FAILED"] = 22;
            values[valuesById[23] = "COLLECT_FAILED_RISK"] = 23;
            values[valuesById[24] = "COLLECT_REJECTED"] = 24;
            values[valuesById[25] = "COLLECT_EXPIRED"] = 25;
            values[valuesById[26] = "COLLECT_CANCELED"] = 26;
            values[valuesById[27] = "COLLECT_CANCELLING"] = 27;
            return values;
        })();

        return PaymentInfo;
    })();

    Message.WebMessageInfo = (function() {

        /**
         * Properties of a WebMessageInfo.
         * @memberof Message
         * @interface IWebMessageInfo
         * @property {Message.IMessageKey} key WebMessageInfo key
         * @property {Message.IMessage|null} [message] WebMessageInfo message
         * @property {number|Long|null} [messageTimestamp] WebMessageInfo messageTimestamp
         * @property {Message.WebMessageInfo.WEB_MESSAGE_INFO_STATUS|null} [status] WebMessageInfo status
         * @property {string|null} [participant] WebMessageInfo participant
         * @property {boolean|null} [ignore] WebMessageInfo ignore
         * @property {boolean|null} [starred] WebMessageInfo starred
         * @property {boolean|null} [broadcast] WebMessageInfo broadcast
         * @property {string|null} [pushName] WebMessageInfo pushName
         * @property {Uint8Array|null} [mediaCiphertextSha256] WebMessageInfo mediaCiphertextSha256
         * @property {boolean|null} [multicast] WebMessageInfo multicast
         * @property {boolean|null} [urlText] WebMessageInfo urlText
         * @property {boolean|null} [urlNumber] WebMessageInfo urlNumber
         * @property {Message.WebMessageInfo.WEB_MESSAGE_INFO_STUBTYPE|null} [messageStubType] WebMessageInfo messageStubType
         * @property {boolean|null} [clearMedia] WebMessageInfo clearMedia
         * @property {Array.<string>|null} [messageStubParameters] WebMessageInfo messageStubParameters
         * @property {number|null} [duration] WebMessageInfo duration
         * @property {Array.<string>|null} [labels] WebMessageInfo labels
         * @property {Message.IPaymentInfo|null} [paymentInfo] WebMessageInfo paymentInfo
         * @property {Message.ILiveLocationMessage|null} [finalLiveLocation] WebMessageInfo finalLiveLocation
         * @property {Message.IPaymentInfo|null} [quotedPaymentInfo] WebMessageInfo quotedPaymentInfo
         * @property {number|Long|null} [ephemeralStartTimestamp] WebMessageInfo ephemeralStartTimestamp
         * @property {number|null} [ephemeralDuration] WebMessageInfo ephemeralDuration
         * @property {boolean|null} [ephemeralOffToOn] WebMessageInfo ephemeralOffToOn
         */

        /**
         * Constructs a new WebMessageInfo.
         * @memberof Message
         * @classdesc Represents a WebMessageInfo.
         * @implements IWebMessageInfo
         * @constructor
         * @param {Message.IWebMessageInfo=} [properties] Properties to set
         */
        function WebMessageInfo(properties) {
            this.messageStubParameters = [];
            this.labels = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WebMessageInfo key.
         * @member {Message.IMessageKey} key
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.key = null;

        /**
         * WebMessageInfo message.
         * @member {Message.IMessage|null|undefined} message
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.message = null;

        /**
         * WebMessageInfo messageTimestamp.
         * @member {number|Long} messageTimestamp
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.messageTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * WebMessageInfo status.
         * @member {Message.WebMessageInfo.WEB_MESSAGE_INFO_STATUS} status
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.status = 0;

        /**
         * WebMessageInfo participant.
         * @member {string} participant
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.participant = "";

        /**
         * WebMessageInfo ignore.
         * @member {boolean} ignore
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.ignore = false;

        /**
         * WebMessageInfo starred.
         * @member {boolean} starred
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.starred = false;

        /**
         * WebMessageInfo broadcast.
         * @member {boolean} broadcast
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.broadcast = false;

        /**
         * WebMessageInfo pushName.
         * @member {string} pushName
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.pushName = "";

        /**
         * WebMessageInfo mediaCiphertextSha256.
         * @member {Uint8Array} mediaCiphertextSha256
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.mediaCiphertextSha256 = $util.newBuffer([]);

        /**
         * WebMessageInfo multicast.
         * @member {boolean} multicast
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.multicast = false;

        /**
         * WebMessageInfo urlText.
         * @member {boolean} urlText
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.urlText = false;

        /**
         * WebMessageInfo urlNumber.
         * @member {boolean} urlNumber
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.urlNumber = false;

        /**
         * WebMessageInfo messageStubType.
         * @member {Message.WebMessageInfo.WEB_MESSAGE_INFO_STUBTYPE} messageStubType
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.messageStubType = 0;

        /**
         * WebMessageInfo clearMedia.
         * @member {boolean} clearMedia
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.clearMedia = false;

        /**
         * WebMessageInfo messageStubParameters.
         * @member {Array.<string>} messageStubParameters
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.messageStubParameters = $util.emptyArray;

        /**
         * WebMessageInfo duration.
         * @member {number} duration
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.duration = 0;

        /**
         * WebMessageInfo labels.
         * @member {Array.<string>} labels
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.labels = $util.emptyArray;

        /**
         * WebMessageInfo paymentInfo.
         * @member {Message.IPaymentInfo|null|undefined} paymentInfo
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.paymentInfo = null;

        /**
         * WebMessageInfo finalLiveLocation.
         * @member {Message.ILiveLocationMessage|null|undefined} finalLiveLocation
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.finalLiveLocation = null;

        /**
         * WebMessageInfo quotedPaymentInfo.
         * @member {Message.IPaymentInfo|null|undefined} quotedPaymentInfo
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.quotedPaymentInfo = null;

        /**
         * WebMessageInfo ephemeralStartTimestamp.
         * @member {number|Long} ephemeralStartTimestamp
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.ephemeralStartTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * WebMessageInfo ephemeralDuration.
         * @member {number} ephemeralDuration
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.ephemeralDuration = 0;

        /**
         * WebMessageInfo ephemeralOffToOn.
         * @member {boolean} ephemeralOffToOn
         * @memberof Message.WebMessageInfo
         * @instance
         */
        WebMessageInfo.prototype.ephemeralOffToOn = false;

        /**
         * Creates a new WebMessageInfo instance using the specified properties.
         * @function create
         * @memberof Message.WebMessageInfo
         * @static
         * @param {Message.IWebMessageInfo=} [properties] Properties to set
         * @returns {Message.WebMessageInfo} WebMessageInfo instance
         */
        WebMessageInfo.create = function create(properties) {
            return new WebMessageInfo(properties);
        };

        /**
         * Encodes the specified WebMessageInfo message. Does not implicitly {@link Message.WebMessageInfo.verify|verify} messages.
         * @function encode
         * @memberof Message.WebMessageInfo
         * @static
         * @param {Message.IWebMessageInfo} message WebMessageInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebMessageInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.Message.MessageKey.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                $root.Message.Message.encode(message.message, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.messageTimestamp != null && Object.hasOwnProperty.call(message, "messageTimestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageTimestamp);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.status);
            if (message.participant != null && Object.hasOwnProperty.call(message, "participant"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.participant);
            if (message.ignore != null && Object.hasOwnProperty.call(message, "ignore"))
                writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ignore);
            if (message.starred != null && Object.hasOwnProperty.call(message, "starred"))
                writer.uint32(/* id 17, wireType 0 =*/136).bool(message.starred);
            if (message.broadcast != null && Object.hasOwnProperty.call(message, "broadcast"))
                writer.uint32(/* id 18, wireType 0 =*/144).bool(message.broadcast);
            if (message.pushName != null && Object.hasOwnProperty.call(message, "pushName"))
                writer.uint32(/* id 19, wireType 2 =*/154).string(message.pushName);
            if (message.mediaCiphertextSha256 != null && Object.hasOwnProperty.call(message, "mediaCiphertextSha256"))
                writer.uint32(/* id 20, wireType 2 =*/162).bytes(message.mediaCiphertextSha256);
            if (message.multicast != null && Object.hasOwnProperty.call(message, "multicast"))
                writer.uint32(/* id 21, wireType 0 =*/168).bool(message.multicast);
            if (message.urlText != null && Object.hasOwnProperty.call(message, "urlText"))
                writer.uint32(/* id 22, wireType 0 =*/176).bool(message.urlText);
            if (message.urlNumber != null && Object.hasOwnProperty.call(message, "urlNumber"))
                writer.uint32(/* id 23, wireType 0 =*/184).bool(message.urlNumber);
            if (message.messageStubType != null && Object.hasOwnProperty.call(message, "messageStubType"))
                writer.uint32(/* id 24, wireType 0 =*/192).int32(message.messageStubType);
            if (message.clearMedia != null && Object.hasOwnProperty.call(message, "clearMedia"))
                writer.uint32(/* id 25, wireType 0 =*/200).bool(message.clearMedia);
            if (message.messageStubParameters != null && message.messageStubParameters.length)
                for (var i = 0; i < message.messageStubParameters.length; ++i)
                    writer.uint32(/* id 26, wireType 2 =*/210).string(message.messageStubParameters[i]);
            if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                writer.uint32(/* id 27, wireType 0 =*/216).uint32(message.duration);
            if (message.labels != null && message.labels.length)
                for (var i = 0; i < message.labels.length; ++i)
                    writer.uint32(/* id 28, wireType 2 =*/226).string(message.labels[i]);
            if (message.paymentInfo != null && Object.hasOwnProperty.call(message, "paymentInfo"))
                $root.Message.PaymentInfo.encode(message.paymentInfo, writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
            if (message.finalLiveLocation != null && Object.hasOwnProperty.call(message, "finalLiveLocation"))
                $root.Message.LiveLocationMessage.encode(message.finalLiveLocation, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
            if (message.quotedPaymentInfo != null && Object.hasOwnProperty.call(message, "quotedPaymentInfo"))
                $root.Message.PaymentInfo.encode(message.quotedPaymentInfo, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
            if (message.ephemeralStartTimestamp != null && Object.hasOwnProperty.call(message, "ephemeralStartTimestamp"))
                writer.uint32(/* id 32, wireType 0 =*/256).uint64(message.ephemeralStartTimestamp);
            if (message.ephemeralDuration != null && Object.hasOwnProperty.call(message, "ephemeralDuration"))
                writer.uint32(/* id 33, wireType 0 =*/264).uint32(message.ephemeralDuration);
            if (message.ephemeralOffToOn != null && Object.hasOwnProperty.call(message, "ephemeralOffToOn"))
                writer.uint32(/* id 34, wireType 0 =*/272).bool(message.ephemeralOffToOn);
            return writer;
        };

        /**
         * Encodes the specified WebMessageInfo message, length delimited. Does not implicitly {@link Message.WebMessageInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Message.WebMessageInfo
         * @static
         * @param {Message.IWebMessageInfo} message WebMessageInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WebMessageInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WebMessageInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Message.WebMessageInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Message.WebMessageInfo} WebMessageInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebMessageInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Message.WebMessageInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = $root.Message.MessageKey.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.message = $root.Message.Message.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.messageTimestamp = reader.uint64();
                    break;
                case 4:
                    message.status = reader.int32();
                    break;
                case 5:
                    message.participant = reader.string();
                    break;
                case 16:
                    message.ignore = reader.bool();
                    break;
                case 17:
                    message.starred = reader.bool();
                    break;
                case 18:
                    message.broadcast = reader.bool();
                    break;
                case 19:
                    message.pushName = reader.string();
                    break;
                case 20:
                    message.mediaCiphertextSha256 = reader.bytes();
                    break;
                case 21:
                    message.multicast = reader.bool();
                    break;
                case 22:
                    message.urlText = reader.bool();
                    break;
                case 23:
                    message.urlNumber = reader.bool();
                    break;
                case 24:
                    message.messageStubType = reader.int32();
                    break;
                case 25:
                    message.clearMedia = reader.bool();
                    break;
                case 26:
                    if (!(message.messageStubParameters && message.messageStubParameters.length))
                        message.messageStubParameters = [];
                    message.messageStubParameters.push(reader.string());
                    break;
                case 27:
                    message.duration = reader.uint32();
                    break;
                case 28:
                    if (!(message.labels && message.labels.length))
                        message.labels = [];
                    message.labels.push(reader.string());
                    break;
                case 29:
                    message.paymentInfo = $root.Message.PaymentInfo.decode(reader, reader.uint32());
                    break;
                case 30:
                    message.finalLiveLocation = $root.Message.LiveLocationMessage.decode(reader, reader.uint32());
                    break;
                case 31:
                    message.quotedPaymentInfo = $root.Message.PaymentInfo.decode(reader, reader.uint32());
                    break;
                case 32:
                    message.ephemeralStartTimestamp = reader.uint64();
                    break;
                case 33:
                    message.ephemeralDuration = reader.uint32();
                    break;
                case 34:
                    message.ephemeralOffToOn = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("key"))
                throw $util.ProtocolError("missing required 'key'", { instance: message });
            return message;
        };

        /**
         * Decodes a WebMessageInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Message.WebMessageInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Message.WebMessageInfo} WebMessageInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WebMessageInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WebMessageInfo message.
         * @function verify
         * @memberof Message.WebMessageInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WebMessageInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.Message.MessageKey.verify(message.key);
                if (error)
                    return "key." + error;
            }
            if (message.message != null && message.hasOwnProperty("message")) {
                var error = $root.Message.Message.verify(message.message);
                if (error)
                    return "message." + error;
            }
            if (message.messageTimestamp != null && message.hasOwnProperty("messageTimestamp"))
                if (!$util.isInteger(message.messageTimestamp) && !(message.messageTimestamp && $util.isInteger(message.messageTimestamp.low) && $util.isInteger(message.messageTimestamp.high)))
                    return "messageTimestamp: integer|Long expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.participant != null && message.hasOwnProperty("participant"))
                if (!$util.isString(message.participant))
                    return "participant: string expected";
            if (message.ignore != null && message.hasOwnProperty("ignore"))
                if (typeof message.ignore !== "boolean")
                    return "ignore: boolean expected";
            if (message.starred != null && message.hasOwnProperty("starred"))
                if (typeof message.starred !== "boolean")
                    return "starred: boolean expected";
            if (message.broadcast != null && message.hasOwnProperty("broadcast"))
                if (typeof message.broadcast !== "boolean")
                    return "broadcast: boolean expected";
            if (message.pushName != null && message.hasOwnProperty("pushName"))
                if (!$util.isString(message.pushName))
                    return "pushName: string expected";
            if (message.mediaCiphertextSha256 != null && message.hasOwnProperty("mediaCiphertextSha256"))
                if (!(message.mediaCiphertextSha256 && typeof message.mediaCiphertextSha256.length === "number" || $util.isString(message.mediaCiphertextSha256)))
                    return "mediaCiphertextSha256: buffer expected";
            if (message.multicast != null && message.hasOwnProperty("multicast"))
                if (typeof message.multicast !== "boolean")
                    return "multicast: boolean expected";
            if (message.urlText != null && message.hasOwnProperty("urlText"))
                if (typeof message.urlText !== "boolean")
                    return "urlText: boolean expected";
            if (message.urlNumber != null && message.hasOwnProperty("urlNumber"))
                if (typeof message.urlNumber !== "boolean")
                    return "urlNumber: boolean expected";
            if (message.messageStubType != null && message.hasOwnProperty("messageStubType"))
                switch (message.messageStubType) {
                default:
                    return "messageStubType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 70:
                case 71:
                case 72:
                    break;
                }
            if (message.clearMedia != null && message.hasOwnProperty("clearMedia"))
                if (typeof message.clearMedia !== "boolean")
                    return "clearMedia: boolean expected";
            if (message.messageStubParameters != null && message.hasOwnProperty("messageStubParameters")) {
                if (!Array.isArray(message.messageStubParameters))
                    return "messageStubParameters: array expected";
                for (var i = 0; i < message.messageStubParameters.length; ++i)
                    if (!$util.isString(message.messageStubParameters[i]))
                        return "messageStubParameters: string[] expected";
            }
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (!$util.isInteger(message.duration))
                    return "duration: integer expected";
            if (message.labels != null && message.hasOwnProperty("labels")) {
                if (!Array.isArray(message.labels))
                    return "labels: array expected";
                for (var i = 0; i < message.labels.length; ++i)
                    if (!$util.isString(message.labels[i]))
                        return "labels: string[] expected";
            }
            if (message.paymentInfo != null && message.hasOwnProperty("paymentInfo")) {
                var error = $root.Message.PaymentInfo.verify(message.paymentInfo);
                if (error)
                    return "paymentInfo." + error;
            }
            if (message.finalLiveLocation != null && message.hasOwnProperty("finalLiveLocation")) {
                var error = $root.Message.LiveLocationMessage.verify(message.finalLiveLocation);
                if (error)
                    return "finalLiveLocation." + error;
            }
            if (message.quotedPaymentInfo != null && message.hasOwnProperty("quotedPaymentInfo")) {
                var error = $root.Message.PaymentInfo.verify(message.quotedPaymentInfo);
                if (error)
                    return "quotedPaymentInfo." + error;
            }
            if (message.ephemeralStartTimestamp != null && message.hasOwnProperty("ephemeralStartTimestamp"))
                if (!$util.isInteger(message.ephemeralStartTimestamp) && !(message.ephemeralStartTimestamp && $util.isInteger(message.ephemeralStartTimestamp.low) && $util.isInteger(message.ephemeralStartTimestamp.high)))
                    return "ephemeralStartTimestamp: integer|Long expected";
            if (message.ephemeralDuration != null && message.hasOwnProperty("ephemeralDuration"))
                if (!$util.isInteger(message.ephemeralDuration))
                    return "ephemeralDuration: integer expected";
            if (message.ephemeralOffToOn != null && message.hasOwnProperty("ephemeralOffToOn"))
                if (typeof message.ephemeralOffToOn !== "boolean")
                    return "ephemeralOffToOn: boolean expected";
            return null;
        };

        /**
         * Creates a WebMessageInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Message.WebMessageInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Message.WebMessageInfo} WebMessageInfo
         */
        WebMessageInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Message.WebMessageInfo)
                return object;
            var message = new $root.Message.WebMessageInfo();
            if (object.key != null) {
                if (typeof object.key !== "object")
                    throw TypeError(".Message.WebMessageInfo.key: object expected");
                message.key = $root.Message.MessageKey.fromObject(object.key);
            }
            if (object.message != null) {
                if (typeof object.message !== "object")
                    throw TypeError(".Message.WebMessageInfo.message: object expected");
                message.message = $root.Message.Message.fromObject(object.message);
            }
            if (object.messageTimestamp != null)
                if ($util.Long)
                    (message.messageTimestamp = $util.Long.fromValue(object.messageTimestamp)).unsigned = true;
                else if (typeof object.messageTimestamp === "string")
                    message.messageTimestamp = parseInt(object.messageTimestamp, 10);
                else if (typeof object.messageTimestamp === "number")
                    message.messageTimestamp = object.messageTimestamp;
                else if (typeof object.messageTimestamp === "object")
                    message.messageTimestamp = new $util.LongBits(object.messageTimestamp.low >>> 0, object.messageTimestamp.high >>> 0).toNumber(true);
            switch (object.status) {
            case "ERROR":
            case 0:
                message.status = 0;
                break;
            case "PENDING":
            case 1:
                message.status = 1;
                break;
            case "SERVER_ACK":
            case 2:
                message.status = 2;
                break;
            case "DELIVERY_ACK":
            case 3:
                message.status = 3;
                break;
            case "READ":
            case 4:
                message.status = 4;
                break;
            case "PLAYED":
            case 5:
                message.status = 5;
                break;
            }
            if (object.participant != null)
                message.participant = String(object.participant);
            if (object.ignore != null)
                message.ignore = Boolean(object.ignore);
            if (object.starred != null)
                message.starred = Boolean(object.starred);
            if (object.broadcast != null)
                message.broadcast = Boolean(object.broadcast);
            if (object.pushName != null)
                message.pushName = String(object.pushName);
            if (object.mediaCiphertextSha256 != null)
                if (typeof object.mediaCiphertextSha256 === "string")
                    $util.base64.decode(object.mediaCiphertextSha256, message.mediaCiphertextSha256 = $util.newBuffer($util.base64.length(object.mediaCiphertextSha256)), 0);
                else if (object.mediaCiphertextSha256.length)
                    message.mediaCiphertextSha256 = object.mediaCiphertextSha256;
            if (object.multicast != null)
                message.multicast = Boolean(object.multicast);
            if (object.urlText != null)
                message.urlText = Boolean(object.urlText);
            if (object.urlNumber != null)
                message.urlNumber = Boolean(object.urlNumber);
            switch (object.messageStubType) {
            case "UNKNOWN":
            case 0:
                message.messageStubType = 0;
                break;
            case "REVOKE":
            case 1:
                message.messageStubType = 1;
                break;
            case "CIPHERTEXT":
            case 2:
                message.messageStubType = 2;
                break;
            case "FUTUREPROOF":
            case 3:
                message.messageStubType = 3;
                break;
            case "NON_VERIFIED_TRANSITION":
            case 4:
                message.messageStubType = 4;
                break;
            case "UNVERIFIED_TRANSITION":
            case 5:
                message.messageStubType = 5;
                break;
            case "VERIFIED_TRANSITION":
            case 6:
                message.messageStubType = 6;
                break;
            case "VERIFIED_LOW_UNKNOWN":
            case 7:
                message.messageStubType = 7;
                break;
            case "VERIFIED_HIGH":
            case 8:
                message.messageStubType = 8;
                break;
            case "VERIFIED_INITIAL_UNKNOWN":
            case 9:
                message.messageStubType = 9;
                break;
            case "VERIFIED_INITIAL_LOW":
            case 10:
                message.messageStubType = 10;
                break;
            case "VERIFIED_INITIAL_HIGH":
            case 11:
                message.messageStubType = 11;
                break;
            case "VERIFIED_TRANSITION_ANY_TO_NONE":
            case 12:
                message.messageStubType = 12;
                break;
            case "VERIFIED_TRANSITION_ANY_TO_HIGH":
            case 13:
                message.messageStubType = 13;
                break;
            case "VERIFIED_TRANSITION_HIGH_TO_LOW":
            case 14:
                message.messageStubType = 14;
                break;
            case "VERIFIED_TRANSITION_HIGH_TO_UNKNOWN":
            case 15:
                message.messageStubType = 15;
                break;
            case "VERIFIED_TRANSITION_UNKNOWN_TO_LOW":
            case 16:
                message.messageStubType = 16;
                break;
            case "VERIFIED_TRANSITION_LOW_TO_UNKNOWN":
            case 17:
                message.messageStubType = 17;
                break;
            case "VERIFIED_TRANSITION_NONE_TO_LOW":
            case 18:
                message.messageStubType = 18;
                break;
            case "VERIFIED_TRANSITION_NONE_TO_UNKNOWN":
            case 19:
                message.messageStubType = 19;
                break;
            case "GROUP_CREATE":
            case 20:
                message.messageStubType = 20;
                break;
            case "GROUP_CHANGE_SUBJECT":
            case 21:
                message.messageStubType = 21;
                break;
            case "GROUP_CHANGE_ICON":
            case 22:
                message.messageStubType = 22;
                break;
            case "GROUP_CHANGE_INVITE_LINK":
            case 23:
                message.messageStubType = 23;
                break;
            case "GROUP_CHANGE_DESCRIPTION":
            case 24:
                message.messageStubType = 24;
                break;
            case "GROUP_CHANGE_RESTRICT":
            case 25:
                message.messageStubType = 25;
                break;
            case "GROUP_CHANGE_ANNOUNCE":
            case 26:
                message.messageStubType = 26;
                break;
            case "GROUP_PARTICIPANT_ADD":
            case 27:
                message.messageStubType = 27;
                break;
            case "GROUP_PARTICIPANT_REMOVE":
            case 28:
                message.messageStubType = 28;
                break;
            case "GROUP_PARTICIPANT_PROMOTE":
            case 29:
                message.messageStubType = 29;
                break;
            case "GROUP_PARTICIPANT_DEMOTE":
            case 30:
                message.messageStubType = 30;
                break;
            case "GROUP_PARTICIPANT_INVITE":
            case 31:
                message.messageStubType = 31;
                break;
            case "GROUP_PARTICIPANT_LEAVE":
            case 32:
                message.messageStubType = 32;
                break;
            case "GROUP_PARTICIPANT_CHANGE_NUMBER":
            case 33:
                message.messageStubType = 33;
                break;
            case "BROADCAST_CREATE":
            case 34:
                message.messageStubType = 34;
                break;
            case "BROADCAST_ADD":
            case 35:
                message.messageStubType = 35;
                break;
            case "BROADCAST_REMOVE":
            case 36:
                message.messageStubType = 36;
                break;
            case "GENERIC_NOTIFICATION":
            case 37:
                message.messageStubType = 37;
                break;
            case "E2E_IDENTITY_CHANGED":
            case 38:
                message.messageStubType = 38;
                break;
            case "E2E_ENCRYPTED":
            case 39:
                message.messageStubType = 39;
                break;
            case "CALL_MISSED_VOICE":
            case 40:
                message.messageStubType = 40;
                break;
            case "CALL_MISSED_VIDEO":
            case 41:
                message.messageStubType = 41;
                break;
            case "INDIVIDUAL_CHANGE_NUMBER":
            case 42:
                message.messageStubType = 42;
                break;
            case "GROUP_DELETE":
            case 43:
                message.messageStubType = 43;
                break;
            case "GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE":
            case 44:
                message.messageStubType = 44;
                break;
            case "CALL_MISSED_GROUP_VOICE":
            case 45:
                message.messageStubType = 45;
                break;
            case "CALL_MISSED_GROUP_VIDEO":
            case 46:
                message.messageStubType = 46;
                break;
            case "PAYMENT_CIPHERTEXT":
            case 47:
                message.messageStubType = 47;
                break;
            case "PAYMENT_FUTUREPROOF":
            case 48:
                message.messageStubType = 48;
                break;
            case "PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED":
            case 49:
                message.messageStubType = 49;
                break;
            case "PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED":
            case 50:
                message.messageStubType = 50;
                break;
            case "PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED":
            case 51:
                message.messageStubType = 51;
                break;
            case "PAYMENT_TRANSACTION_STATUS_RECEIVER_PENDING_SETUP":
            case 52:
                message.messageStubType = 52;
                break;
            case "PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_HICCUP":
            case 53:
                message.messageStubType = 53;
                break;
            case "PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER":
            case 54:
                message.messageStubType = 54;
                break;
            case "PAYMENT_ACTION_SEND_PAYMENT_REMINDER":
            case 55:
                message.messageStubType = 55;
                break;
            case "PAYMENT_ACTION_SEND_PAYMENT_INVITATION":
            case 56:
                message.messageStubType = 56;
                break;
            case "PAYMENT_ACTION_REQUEST_DECLINED":
            case 57:
                message.messageStubType = 57;
                break;
            case "PAYMENT_ACTION_REQUEST_EXPIRED":
            case 58:
                message.messageStubType = 58;
                break;
            case "PAYMENT_ACTION_REQUEST_CANCELLED":
            case 59:
                message.messageStubType = 59;
                break;
            case "BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM":
            case 60:
                message.messageStubType = 60;
                break;
            case "BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP":
            case 61:
                message.messageStubType = 61;
                break;
            case "BIZ_INTRO_TOP":
            case 62:
                message.messageStubType = 62;
                break;
            case "BIZ_INTRO_BOTTOM":
            case 63:
                message.messageStubType = 63;
                break;
            case "BIZ_NAME_CHANGE":
            case 64:
                message.messageStubType = 64;
                break;
            case "BIZ_MOVE_TO_CONSUMER_APP":
            case 65:
                message.messageStubType = 65;
                break;
            case "BIZ_TWO_TIER_MIGRATION_TOP":
            case 66:
                message.messageStubType = 66;
                break;
            case "BIZ_TWO_TIER_MIGRATION_BOTTOM":
            case 67:
                message.messageStubType = 67;
                break;
            case "OVERSIZED":
            case 68:
                message.messageStubType = 68;
                break;
            case "GROUP_CHANGE_NO_FREQUENTLY_FORWARDED":
            case 69:
                message.messageStubType = 69;
                break;
            case "GROUP_V4_ADD_INVITE_SENT":
            case 70:
                message.messageStubType = 70;
                break;
            case "GROUP_PARTICIPANT_ADD_REQUEST_JOIN":
            case 71:
                message.messageStubType = 71;
                break;
            case "CHANGE_EPHEMERAL_SETTING":
            case 72:
                message.messageStubType = 72;
                break;
            }
            if (object.clearMedia != null)
                message.clearMedia = Boolean(object.clearMedia);
            if (object.messageStubParameters) {
                if (!Array.isArray(object.messageStubParameters))
                    throw TypeError(".Message.WebMessageInfo.messageStubParameters: array expected");
                message.messageStubParameters = [];
                for (var i = 0; i < object.messageStubParameters.length; ++i)
                    message.messageStubParameters[i] = String(object.messageStubParameters[i]);
            }
            if (object.duration != null)
                message.duration = object.duration >>> 0;
            if (object.labels) {
                if (!Array.isArray(object.labels))
                    throw TypeError(".Message.WebMessageInfo.labels: array expected");
                message.labels = [];
                for (var i = 0; i < object.labels.length; ++i)
                    message.labels[i] = String(object.labels[i]);
            }
            if (object.paymentInfo != null) {
                if (typeof object.paymentInfo !== "object")
                    throw TypeError(".Message.WebMessageInfo.paymentInfo: object expected");
                message.paymentInfo = $root.Message.PaymentInfo.fromObject(object.paymentInfo);
            }
            if (object.finalLiveLocation != null) {
                if (typeof object.finalLiveLocation !== "object")
                    throw TypeError(".Message.WebMessageInfo.finalLiveLocation: object expected");
                message.finalLiveLocation = $root.Message.LiveLocationMessage.fromObject(object.finalLiveLocation);
            }
            if (object.quotedPaymentInfo != null) {
                if (typeof object.quotedPaymentInfo !== "object")
                    throw TypeError(".Message.WebMessageInfo.quotedPaymentInfo: object expected");
                message.quotedPaymentInfo = $root.Message.PaymentInfo.fromObject(object.quotedPaymentInfo);
            }
            if (object.ephemeralStartTimestamp != null)
                if ($util.Long)
                    (message.ephemeralStartTimestamp = $util.Long.fromValue(object.ephemeralStartTimestamp)).unsigned = true;
                else if (typeof object.ephemeralStartTimestamp === "string")
                    message.ephemeralStartTimestamp = parseInt(object.ephemeralStartTimestamp, 10);
                else if (typeof object.ephemeralStartTimestamp === "number")
                    message.ephemeralStartTimestamp = object.ephemeralStartTimestamp;
                else if (typeof object.ephemeralStartTimestamp === "object")
                    message.ephemeralStartTimestamp = new $util.LongBits(object.ephemeralStartTimestamp.low >>> 0, object.ephemeralStartTimestamp.high >>> 0).toNumber(true);
            if (object.ephemeralDuration != null)
                message.ephemeralDuration = object.ephemeralDuration >>> 0;
            if (object.ephemeralOffToOn != null)
                message.ephemeralOffToOn = Boolean(object.ephemeralOffToOn);
            return message;
        };

        /**
         * Creates a plain object from a WebMessageInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Message.WebMessageInfo
         * @static
         * @param {Message.WebMessageInfo} message WebMessageInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WebMessageInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.messageStubParameters = [];
                object.labels = [];
            }
            if (options.defaults) {
                object.key = null;
                object.message = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.messageTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.messageTimestamp = options.longs === String ? "0" : 0;
                object.status = options.enums === String ? "ERROR" : 0;
                object.participant = "";
                object.ignore = false;
                object.starred = false;
                object.broadcast = false;
                object.pushName = "";
                if (options.bytes === String)
                    object.mediaCiphertextSha256 = "";
                else {
                    object.mediaCiphertextSha256 = [];
                    if (options.bytes !== Array)
                        object.mediaCiphertextSha256 = $util.newBuffer(object.mediaCiphertextSha256);
                }
                object.multicast = false;
                object.urlText = false;
                object.urlNumber = false;
                object.messageStubType = options.enums === String ? "UNKNOWN" : 0;
                object.clearMedia = false;
                object.duration = 0;
                object.paymentInfo = null;
                object.finalLiveLocation = null;
                object.quotedPaymentInfo = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.ephemeralStartTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ephemeralStartTimestamp = options.longs === String ? "0" : 0;
                object.ephemeralDuration = 0;
                object.ephemeralOffToOn = false;
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = $root.Message.MessageKey.toObject(message.key, options);
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = $root.Message.Message.toObject(message.message, options);
            if (message.messageTimestamp != null && message.hasOwnProperty("messageTimestamp"))
                if (typeof message.messageTimestamp === "number")
                    object.messageTimestamp = options.longs === String ? String(message.messageTimestamp) : message.messageTimestamp;
                else
                    object.messageTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.messageTimestamp) : options.longs === Number ? new $util.LongBits(message.messageTimestamp.low >>> 0, message.messageTimestamp.high >>> 0).toNumber(true) : message.messageTimestamp;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.Message.WebMessageInfo.WEB_MESSAGE_INFO_STATUS[message.status] : message.status;
            if (message.participant != null && message.hasOwnProperty("participant"))
                object.participant = message.participant;
            if (message.ignore != null && message.hasOwnProperty("ignore"))
                object.ignore = message.ignore;
            if (message.starred != null && message.hasOwnProperty("starred"))
                object.starred = message.starred;
            if (message.broadcast != null && message.hasOwnProperty("broadcast"))
                object.broadcast = message.broadcast;
            if (message.pushName != null && message.hasOwnProperty("pushName"))
                object.pushName = message.pushName;
            if (message.mediaCiphertextSha256 != null && message.hasOwnProperty("mediaCiphertextSha256"))
                object.mediaCiphertextSha256 = options.bytes === String ? $util.base64.encode(message.mediaCiphertextSha256, 0, message.mediaCiphertextSha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.mediaCiphertextSha256) : message.mediaCiphertextSha256;
            if (message.multicast != null && message.hasOwnProperty("multicast"))
                object.multicast = message.multicast;
            if (message.urlText != null && message.hasOwnProperty("urlText"))
                object.urlText = message.urlText;
            if (message.urlNumber != null && message.hasOwnProperty("urlNumber"))
                object.urlNumber = message.urlNumber;
            if (message.messageStubType != null && message.hasOwnProperty("messageStubType"))
                object.messageStubType = options.enums === String ? $root.Message.WebMessageInfo.WEB_MESSAGE_INFO_STUBTYPE[message.messageStubType] : message.messageStubType;
            if (message.clearMedia != null && message.hasOwnProperty("clearMedia"))
                object.clearMedia = message.clearMedia;
            if (message.messageStubParameters && message.messageStubParameters.length) {
                object.messageStubParameters = [];
                for (var j = 0; j < message.messageStubParameters.length; ++j)
                    object.messageStubParameters[j] = message.messageStubParameters[j];
            }
            if (message.duration != null && message.hasOwnProperty("duration"))
                object.duration = message.duration;
            if (message.labels && message.labels.length) {
                object.labels = [];
                for (var j = 0; j < message.labels.length; ++j)
                    object.labels[j] = message.labels[j];
            }
            if (message.paymentInfo != null && message.hasOwnProperty("paymentInfo"))
                object.paymentInfo = $root.Message.PaymentInfo.toObject(message.paymentInfo, options);
            if (message.finalLiveLocation != null && message.hasOwnProperty("finalLiveLocation"))
                object.finalLiveLocation = $root.Message.LiveLocationMessage.toObject(message.finalLiveLocation, options);
            if (message.quotedPaymentInfo != null && message.hasOwnProperty("quotedPaymentInfo"))
                object.quotedPaymentInfo = $root.Message.PaymentInfo.toObject(message.quotedPaymentInfo, options);
            if (message.ephemeralStartTimestamp != null && message.hasOwnProperty("ephemeralStartTimestamp"))
                if (typeof message.ephemeralStartTimestamp === "number")
                    object.ephemeralStartTimestamp = options.longs === String ? String(message.ephemeralStartTimestamp) : message.ephemeralStartTimestamp;
                else
                    object.ephemeralStartTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.ephemeralStartTimestamp) : options.longs === Number ? new $util.LongBits(message.ephemeralStartTimestamp.low >>> 0, message.ephemeralStartTimestamp.high >>> 0).toNumber(true) : message.ephemeralStartTimestamp;
            if (message.ephemeralDuration != null && message.hasOwnProperty("ephemeralDuration"))
                object.ephemeralDuration = message.ephemeralDuration;
            if (message.ephemeralOffToOn != null && message.hasOwnProperty("ephemeralOffToOn"))
                object.ephemeralOffToOn = message.ephemeralOffToOn;
            return object;
        };

        /**
         * Converts this WebMessageInfo to JSON.
         * @function toJSON
         * @memberof Message.WebMessageInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WebMessageInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * WEB_MESSAGE_INFO_STATUS enum.
         * @name Message.WebMessageInfo.WEB_MESSAGE_INFO_STATUS
         * @enum {number}
         * @property {number} ERROR=0 ERROR value
         * @property {number} PENDING=1 PENDING value
         * @property {number} SERVER_ACK=2 SERVER_ACK value
         * @property {number} DELIVERY_ACK=3 DELIVERY_ACK value
         * @property {number} READ=4 READ value
         * @property {number} PLAYED=5 PLAYED value
         */
        WebMessageInfo.WEB_MESSAGE_INFO_STATUS = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ERROR"] = 0;
            values[valuesById[1] = "PENDING"] = 1;
            values[valuesById[2] = "SERVER_ACK"] = 2;
            values[valuesById[3] = "DELIVERY_ACK"] = 3;
            values[valuesById[4] = "READ"] = 4;
            values[valuesById[5] = "PLAYED"] = 5;
            return values;
        })();

        /**
         * WEB_MESSAGE_INFO_STUBTYPE enum.
         * @name Message.WebMessageInfo.WEB_MESSAGE_INFO_STUBTYPE
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} REVOKE=1 REVOKE value
         * @property {number} CIPHERTEXT=2 CIPHERTEXT value
         * @property {number} FUTUREPROOF=3 FUTUREPROOF value
         * @property {number} NON_VERIFIED_TRANSITION=4 NON_VERIFIED_TRANSITION value
         * @property {number} UNVERIFIED_TRANSITION=5 UNVERIFIED_TRANSITION value
         * @property {number} VERIFIED_TRANSITION=6 VERIFIED_TRANSITION value
         * @property {number} VERIFIED_LOW_UNKNOWN=7 VERIFIED_LOW_UNKNOWN value
         * @property {number} VERIFIED_HIGH=8 VERIFIED_HIGH value
         * @property {number} VERIFIED_INITIAL_UNKNOWN=9 VERIFIED_INITIAL_UNKNOWN value
         * @property {number} VERIFIED_INITIAL_LOW=10 VERIFIED_INITIAL_LOW value
         * @property {number} VERIFIED_INITIAL_HIGH=11 VERIFIED_INITIAL_HIGH value
         * @property {number} VERIFIED_TRANSITION_ANY_TO_NONE=12 VERIFIED_TRANSITION_ANY_TO_NONE value
         * @property {number} VERIFIED_TRANSITION_ANY_TO_HIGH=13 VERIFIED_TRANSITION_ANY_TO_HIGH value
         * @property {number} VERIFIED_TRANSITION_HIGH_TO_LOW=14 VERIFIED_TRANSITION_HIGH_TO_LOW value
         * @property {number} VERIFIED_TRANSITION_HIGH_TO_UNKNOWN=15 VERIFIED_TRANSITION_HIGH_TO_UNKNOWN value
         * @property {number} VERIFIED_TRANSITION_UNKNOWN_TO_LOW=16 VERIFIED_TRANSITION_UNKNOWN_TO_LOW value
         * @property {number} VERIFIED_TRANSITION_LOW_TO_UNKNOWN=17 VERIFIED_TRANSITION_LOW_TO_UNKNOWN value
         * @property {number} VERIFIED_TRANSITION_NONE_TO_LOW=18 VERIFIED_TRANSITION_NONE_TO_LOW value
         * @property {number} VERIFIED_TRANSITION_NONE_TO_UNKNOWN=19 VERIFIED_TRANSITION_NONE_TO_UNKNOWN value
         * @property {number} GROUP_CREATE=20 GROUP_CREATE value
         * @property {number} GROUP_CHANGE_SUBJECT=21 GROUP_CHANGE_SUBJECT value
         * @property {number} GROUP_CHANGE_ICON=22 GROUP_CHANGE_ICON value
         * @property {number} GROUP_CHANGE_INVITE_LINK=23 GROUP_CHANGE_INVITE_LINK value
         * @property {number} GROUP_CHANGE_DESCRIPTION=24 GROUP_CHANGE_DESCRIPTION value
         * @property {number} GROUP_CHANGE_RESTRICT=25 GROUP_CHANGE_RESTRICT value
         * @property {number} GROUP_CHANGE_ANNOUNCE=26 GROUP_CHANGE_ANNOUNCE value
         * @property {number} GROUP_PARTICIPANT_ADD=27 GROUP_PARTICIPANT_ADD value
         * @property {number} GROUP_PARTICIPANT_REMOVE=28 GROUP_PARTICIPANT_REMOVE value
         * @property {number} GROUP_PARTICIPANT_PROMOTE=29 GROUP_PARTICIPANT_PROMOTE value
         * @property {number} GROUP_PARTICIPANT_DEMOTE=30 GROUP_PARTICIPANT_DEMOTE value
         * @property {number} GROUP_PARTICIPANT_INVITE=31 GROUP_PARTICIPANT_INVITE value
         * @property {number} GROUP_PARTICIPANT_LEAVE=32 GROUP_PARTICIPANT_LEAVE value
         * @property {number} GROUP_PARTICIPANT_CHANGE_NUMBER=33 GROUP_PARTICIPANT_CHANGE_NUMBER value
         * @property {number} BROADCAST_CREATE=34 BROADCAST_CREATE value
         * @property {number} BROADCAST_ADD=35 BROADCAST_ADD value
         * @property {number} BROADCAST_REMOVE=36 BROADCAST_REMOVE value
         * @property {number} GENERIC_NOTIFICATION=37 GENERIC_NOTIFICATION value
         * @property {number} E2E_IDENTITY_CHANGED=38 E2E_IDENTITY_CHANGED value
         * @property {number} E2E_ENCRYPTED=39 E2E_ENCRYPTED value
         * @property {number} CALL_MISSED_VOICE=40 CALL_MISSED_VOICE value
         * @property {number} CALL_MISSED_VIDEO=41 CALL_MISSED_VIDEO value
         * @property {number} INDIVIDUAL_CHANGE_NUMBER=42 INDIVIDUAL_CHANGE_NUMBER value
         * @property {number} GROUP_DELETE=43 GROUP_DELETE value
         * @property {number} GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE=44 GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE value
         * @property {number} CALL_MISSED_GROUP_VOICE=45 CALL_MISSED_GROUP_VOICE value
         * @property {number} CALL_MISSED_GROUP_VIDEO=46 CALL_MISSED_GROUP_VIDEO value
         * @property {number} PAYMENT_CIPHERTEXT=47 PAYMENT_CIPHERTEXT value
         * @property {number} PAYMENT_FUTUREPROOF=48 PAYMENT_FUTUREPROOF value
         * @property {number} PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED=49 PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED value
         * @property {number} PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED=50 PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED value
         * @property {number} PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED=51 PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED value
         * @property {number} PAYMENT_TRANSACTION_STATUS_RECEIVER_PENDING_SETUP=52 PAYMENT_TRANSACTION_STATUS_RECEIVER_PENDING_SETUP value
         * @property {number} PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_HICCUP=53 PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_HICCUP value
         * @property {number} PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER=54 PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER value
         * @property {number} PAYMENT_ACTION_SEND_PAYMENT_REMINDER=55 PAYMENT_ACTION_SEND_PAYMENT_REMINDER value
         * @property {number} PAYMENT_ACTION_SEND_PAYMENT_INVITATION=56 PAYMENT_ACTION_SEND_PAYMENT_INVITATION value
         * @property {number} PAYMENT_ACTION_REQUEST_DECLINED=57 PAYMENT_ACTION_REQUEST_DECLINED value
         * @property {number} PAYMENT_ACTION_REQUEST_EXPIRED=58 PAYMENT_ACTION_REQUEST_EXPIRED value
         * @property {number} PAYMENT_ACTION_REQUEST_CANCELLED=59 PAYMENT_ACTION_REQUEST_CANCELLED value
         * @property {number} BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM=60 BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM value
         * @property {number} BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP=61 BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP value
         * @property {number} BIZ_INTRO_TOP=62 BIZ_INTRO_TOP value
         * @property {number} BIZ_INTRO_BOTTOM=63 BIZ_INTRO_BOTTOM value
         * @property {number} BIZ_NAME_CHANGE=64 BIZ_NAME_CHANGE value
         * @property {number} BIZ_MOVE_TO_CONSUMER_APP=65 BIZ_MOVE_TO_CONSUMER_APP value
         * @property {number} BIZ_TWO_TIER_MIGRATION_TOP=66 BIZ_TWO_TIER_MIGRATION_TOP value
         * @property {number} BIZ_TWO_TIER_MIGRATION_BOTTOM=67 BIZ_TWO_TIER_MIGRATION_BOTTOM value
         * @property {number} OVERSIZED=68 OVERSIZED value
         * @property {number} GROUP_CHANGE_NO_FREQUENTLY_FORWARDED=69 GROUP_CHANGE_NO_FREQUENTLY_FORWARDED value
         * @property {number} GROUP_V4_ADD_INVITE_SENT=70 GROUP_V4_ADD_INVITE_SENT value
         * @property {number} GROUP_PARTICIPANT_ADD_REQUEST_JOIN=71 GROUP_PARTICIPANT_ADD_REQUEST_JOIN value
         * @property {number} CHANGE_EPHEMERAL_SETTING=72 CHANGE_EPHEMERAL_SETTING value
         */
        WebMessageInfo.WEB_MESSAGE_INFO_STUBTYPE = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "REVOKE"] = 1;
            values[valuesById[2] = "CIPHERTEXT"] = 2;
            values[valuesById[3] = "FUTUREPROOF"] = 3;
            values[valuesById[4] = "NON_VERIFIED_TRANSITION"] = 4;
            values[valuesById[5] = "UNVERIFIED_TRANSITION"] = 5;
            values[valuesById[6] = "VERIFIED_TRANSITION"] = 6;
            values[valuesById[7] = "VERIFIED_LOW_UNKNOWN"] = 7;
            values[valuesById[8] = "VERIFIED_HIGH"] = 8;
            values[valuesById[9] = "VERIFIED_INITIAL_UNKNOWN"] = 9;
            values[valuesById[10] = "VERIFIED_INITIAL_LOW"] = 10;
            values[valuesById[11] = "VERIFIED_INITIAL_HIGH"] = 11;
            values[valuesById[12] = "VERIFIED_TRANSITION_ANY_TO_NONE"] = 12;
            values[valuesById[13] = "VERIFIED_TRANSITION_ANY_TO_HIGH"] = 13;
            values[valuesById[14] = "VERIFIED_TRANSITION_HIGH_TO_LOW"] = 14;
            values[valuesById[15] = "VERIFIED_TRANSITION_HIGH_TO_UNKNOWN"] = 15;
            values[valuesById[16] = "VERIFIED_TRANSITION_UNKNOWN_TO_LOW"] = 16;
            values[valuesById[17] = "VERIFIED_TRANSITION_LOW_TO_UNKNOWN"] = 17;
            values[valuesById[18] = "VERIFIED_TRANSITION_NONE_TO_LOW"] = 18;
            values[valuesById[19] = "VERIFIED_TRANSITION_NONE_TO_UNKNOWN"] = 19;
            values[valuesById[20] = "GROUP_CREATE"] = 20;
            values[valuesById[21] = "GROUP_CHANGE_SUBJECT"] = 21;
            values[valuesById[22] = "GROUP_CHANGE_ICON"] = 22;
            values[valuesById[23] = "GROUP_CHANGE_INVITE_LINK"] = 23;
            values[valuesById[24] = "GROUP_CHANGE_DESCRIPTION"] = 24;
            values[valuesById[25] = "GROUP_CHANGE_RESTRICT"] = 25;
            values[valuesById[26] = "GROUP_CHANGE_ANNOUNCE"] = 26;
            values[valuesById[27] = "GROUP_PARTICIPANT_ADD"] = 27;
            values[valuesById[28] = "GROUP_PARTICIPANT_REMOVE"] = 28;
            values[valuesById[29] = "GROUP_PARTICIPANT_PROMOTE"] = 29;
            values[valuesById[30] = "GROUP_PARTICIPANT_DEMOTE"] = 30;
            values[valuesById[31] = "GROUP_PARTICIPANT_INVITE"] = 31;
            values[valuesById[32] = "GROUP_PARTICIPANT_LEAVE"] = 32;
            values[valuesById[33] = "GROUP_PARTICIPANT_CHANGE_NUMBER"] = 33;
            values[valuesById[34] = "BROADCAST_CREATE"] = 34;
            values[valuesById[35] = "BROADCAST_ADD"] = 35;
            values[valuesById[36] = "BROADCAST_REMOVE"] = 36;
            values[valuesById[37] = "GENERIC_NOTIFICATION"] = 37;
            values[valuesById[38] = "E2E_IDENTITY_CHANGED"] = 38;
            values[valuesById[39] = "E2E_ENCRYPTED"] = 39;
            values[valuesById[40] = "CALL_MISSED_VOICE"] = 40;
            values[valuesById[41] = "CALL_MISSED_VIDEO"] = 41;
            values[valuesById[42] = "INDIVIDUAL_CHANGE_NUMBER"] = 42;
            values[valuesById[43] = "GROUP_DELETE"] = 43;
            values[valuesById[44] = "GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE"] = 44;
            values[valuesById[45] = "CALL_MISSED_GROUP_VOICE"] = 45;
            values[valuesById[46] = "CALL_MISSED_GROUP_VIDEO"] = 46;
            values[valuesById[47] = "PAYMENT_CIPHERTEXT"] = 47;
            values[valuesById[48] = "PAYMENT_FUTUREPROOF"] = 48;
            values[valuesById[49] = "PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED"] = 49;
            values[valuesById[50] = "PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED"] = 50;
            values[valuesById[51] = "PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED"] = 51;
            values[valuesById[52] = "PAYMENT_TRANSACTION_STATUS_RECEIVER_PENDING_SETUP"] = 52;
            values[valuesById[53] = "PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_HICCUP"] = 53;
            values[valuesById[54] = "PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER"] = 54;
            values[valuesById[55] = "PAYMENT_ACTION_SEND_PAYMENT_REMINDER"] = 55;
            values[valuesById[56] = "PAYMENT_ACTION_SEND_PAYMENT_INVITATION"] = 56;
            values[valuesById[57] = "PAYMENT_ACTION_REQUEST_DECLINED"] = 57;
            values[valuesById[58] = "PAYMENT_ACTION_REQUEST_EXPIRED"] = 58;
            values[valuesById[59] = "PAYMENT_ACTION_REQUEST_CANCELLED"] = 59;
            values[valuesById[60] = "BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM"] = 60;
            values[valuesById[61] = "BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP"] = 61;
            values[valuesById[62] = "BIZ_INTRO_TOP"] = 62;
            values[valuesById[63] = "BIZ_INTRO_BOTTOM"] = 63;
            values[valuesById[64] = "BIZ_NAME_CHANGE"] = 64;
            values[valuesById[65] = "BIZ_MOVE_TO_CONSUMER_APP"] = 65;
            values[valuesById[66] = "BIZ_TWO_TIER_MIGRATION_TOP"] = 66;
            values[valuesById[67] = "BIZ_TWO_TIER_MIGRATION_BOTTOM"] = 67;
            values[valuesById[68] = "OVERSIZED"] = 68;
            values[valuesById[69] = "GROUP_CHANGE_NO_FREQUENTLY_FORWARDED"] = 69;
            values[valuesById[70] = "GROUP_V4_ADD_INVITE_SENT"] = 70;
            values[valuesById[71] = "GROUP_PARTICIPANT_ADD_REQUEST_JOIN"] = 71;
            values[valuesById[72] = "CHANGE_EPHEMERAL_SETTING"] = 72;
            return values;
        })();

        return WebMessageInfo;
    })();

    return Message;
})();

$root.SessionStructure = (function() {

    /**
     * Namespace SessionStructure.
     * @exports SessionStructure
     * @namespace
     */
    var SessionStructure = {};

    SessionStructure.SessionStructure = (function() {

        /**
         * Properties of a SessionStructure.
         * @memberof SessionStructure
         * @interface ISessionStructure
         * @property {number|null} [sessionVersion] SessionStructure sessionVersion
         * @property {Uint8Array|null} [localIdentityPublic] SessionStructure localIdentityPublic
         * @property {Uint8Array|null} [remoteIdentityPublic] SessionStructure remoteIdentityPublic
         * @property {Uint8Array|null} [rootKey] SessionStructure rootKey
         * @property {number|null} [previousCounter] SessionStructure previousCounter
         * @property {SessionStructure.SessionStructure.IChain|null} [senderChain] SessionStructure senderChain
         * @property {Array.<SessionStructure.SessionStructure.IChain>|null} [receiverChains] SessionStructure receiverChains
         * @property {SessionStructure.SessionStructure.IPendingKeyExchange|null} [pendingKeyExchange] SessionStructure pendingKeyExchange
         * @property {SessionStructure.SessionStructure.IPendingPreKey|null} [pendingPreKey] SessionStructure pendingPreKey
         * @property {number|null} [remoteRegistrationId] SessionStructure remoteRegistrationId
         * @property {number|null} [localRegistrationId] SessionStructure localRegistrationId
         * @property {boolean|null} [needsRefresh] SessionStructure needsRefresh
         * @property {Uint8Array|null} [aliceBaseKey] SessionStructure aliceBaseKey
         */

        /**
         * Constructs a new SessionStructure.
         * @memberof SessionStructure
         * @classdesc Represents a SessionStructure.
         * @implements ISessionStructure
         * @constructor
         * @param {SessionStructure.ISessionStructure=} [properties] Properties to set
         */
        function SessionStructure(properties) {
            this.receiverChains = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionStructure sessionVersion.
         * @member {number} sessionVersion
         * @memberof SessionStructure.SessionStructure
         * @instance
         */
        SessionStructure.prototype.sessionVersion = 0;

        /**
         * SessionStructure localIdentityPublic.
         * @member {Uint8Array} localIdentityPublic
         * @memberof SessionStructure.SessionStructure
         * @instance
         */
        SessionStructure.prototype.localIdentityPublic = $util.newBuffer([]);

        /**
         * SessionStructure remoteIdentityPublic.
         * @member {Uint8Array} remoteIdentityPublic
         * @memberof SessionStructure.SessionStructure
         * @instance
         */
        SessionStructure.prototype.remoteIdentityPublic = $util.newBuffer([]);

        /**
         * SessionStructure rootKey.
         * @member {Uint8Array} rootKey
         * @memberof SessionStructure.SessionStructure
         * @instance
         */
        SessionStructure.prototype.rootKey = $util.newBuffer([]);

        /**
         * SessionStructure previousCounter.
         * @member {number} previousCounter
         * @memberof SessionStructure.SessionStructure
         * @instance
         */
        SessionStructure.prototype.previousCounter = 0;

        /**
         * SessionStructure senderChain.
         * @member {SessionStructure.SessionStructure.IChain|null|undefined} senderChain
         * @memberof SessionStructure.SessionStructure
         * @instance
         */
        SessionStructure.prototype.senderChain = null;

        /**
         * SessionStructure receiverChains.
         * @member {Array.<SessionStructure.SessionStructure.IChain>} receiverChains
         * @memberof SessionStructure.SessionStructure
         * @instance
         */
        SessionStructure.prototype.receiverChains = $util.emptyArray;

        /**
         * SessionStructure pendingKeyExchange.
         * @member {SessionStructure.SessionStructure.IPendingKeyExchange|null|undefined} pendingKeyExchange
         * @memberof SessionStructure.SessionStructure
         * @instance
         */
        SessionStructure.prototype.pendingKeyExchange = null;

        /**
         * SessionStructure pendingPreKey.
         * @member {SessionStructure.SessionStructure.IPendingPreKey|null|undefined} pendingPreKey
         * @memberof SessionStructure.SessionStructure
         * @instance
         */
        SessionStructure.prototype.pendingPreKey = null;

        /**
         * SessionStructure remoteRegistrationId.
         * @member {number} remoteRegistrationId
         * @memberof SessionStructure.SessionStructure
         * @instance
         */
        SessionStructure.prototype.remoteRegistrationId = 0;

        /**
         * SessionStructure localRegistrationId.
         * @member {number} localRegistrationId
         * @memberof SessionStructure.SessionStructure
         * @instance
         */
        SessionStructure.prototype.localRegistrationId = 0;

        /**
         * SessionStructure needsRefresh.
         * @member {boolean} needsRefresh
         * @memberof SessionStructure.SessionStructure
         * @instance
         */
        SessionStructure.prototype.needsRefresh = false;

        /**
         * SessionStructure aliceBaseKey.
         * @member {Uint8Array} aliceBaseKey
         * @memberof SessionStructure.SessionStructure
         * @instance
         */
        SessionStructure.prototype.aliceBaseKey = $util.newBuffer([]);

        /**
         * Creates a new SessionStructure instance using the specified properties.
         * @function create
         * @memberof SessionStructure.SessionStructure
         * @static
         * @param {SessionStructure.ISessionStructure=} [properties] Properties to set
         * @returns {SessionStructure.SessionStructure} SessionStructure instance
         */
        SessionStructure.create = function create(properties) {
            return new SessionStructure(properties);
        };

        /**
         * Encodes the specified SessionStructure message. Does not implicitly {@link SessionStructure.SessionStructure.verify|verify} messages.
         * @function encode
         * @memberof SessionStructure.SessionStructure
         * @static
         * @param {SessionStructure.ISessionStructure} message SessionStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionStructure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sessionVersion != null && Object.hasOwnProperty.call(message, "sessionVersion"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.sessionVersion);
            if (message.localIdentityPublic != null && Object.hasOwnProperty.call(message, "localIdentityPublic"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.localIdentityPublic);
            if (message.remoteIdentityPublic != null && Object.hasOwnProperty.call(message, "remoteIdentityPublic"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.remoteIdentityPublic);
            if (message.rootKey != null && Object.hasOwnProperty.call(message, "rootKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.rootKey);
            if (message.previousCounter != null && Object.hasOwnProperty.call(message, "previousCounter"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.previousCounter);
            if (message.senderChain != null && Object.hasOwnProperty.call(message, "senderChain"))
                $root.SessionStructure.SessionStructure.Chain.encode(message.senderChain, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.receiverChains != null && message.receiverChains.length)
                for (var i = 0; i < message.receiverChains.length; ++i)
                    $root.SessionStructure.SessionStructure.Chain.encode(message.receiverChains[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.pendingKeyExchange != null && Object.hasOwnProperty.call(message, "pendingKeyExchange"))
                $root.SessionStructure.SessionStructure.PendingKeyExchange.encode(message.pendingKeyExchange, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.pendingPreKey != null && Object.hasOwnProperty.call(message, "pendingPreKey"))
                $root.SessionStructure.SessionStructure.PendingPreKey.encode(message.pendingPreKey, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.remoteRegistrationId != null && Object.hasOwnProperty.call(message, "remoteRegistrationId"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.remoteRegistrationId);
            if (message.localRegistrationId != null && Object.hasOwnProperty.call(message, "localRegistrationId"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.localRegistrationId);
            if (message.needsRefresh != null && Object.hasOwnProperty.call(message, "needsRefresh"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.needsRefresh);
            if (message.aliceBaseKey != null && Object.hasOwnProperty.call(message, "aliceBaseKey"))
                writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.aliceBaseKey);
            return writer;
        };

        /**
         * Encodes the specified SessionStructure message, length delimited. Does not implicitly {@link SessionStructure.SessionStructure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SessionStructure.SessionStructure
         * @static
         * @param {SessionStructure.ISessionStructure} message SessionStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionStructure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionStructure message from the specified reader or buffer.
         * @function decode
         * @memberof SessionStructure.SessionStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SessionStructure.SessionStructure} SessionStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionStructure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionStructure.SessionStructure();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sessionVersion = reader.uint32();
                    break;
                case 2:
                    message.localIdentityPublic = reader.bytes();
                    break;
                case 3:
                    message.remoteIdentityPublic = reader.bytes();
                    break;
                case 4:
                    message.rootKey = reader.bytes();
                    break;
                case 5:
                    message.previousCounter = reader.uint32();
                    break;
                case 6:
                    message.senderChain = $root.SessionStructure.SessionStructure.Chain.decode(reader, reader.uint32());
                    break;
                case 7:
                    if (!(message.receiverChains && message.receiverChains.length))
                        message.receiverChains = [];
                    message.receiverChains.push($root.SessionStructure.SessionStructure.Chain.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.pendingKeyExchange = $root.SessionStructure.SessionStructure.PendingKeyExchange.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.pendingPreKey = $root.SessionStructure.SessionStructure.PendingPreKey.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.remoteRegistrationId = reader.uint32();
                    break;
                case 11:
                    message.localRegistrationId = reader.uint32();
                    break;
                case 12:
                    message.needsRefresh = reader.bool();
                    break;
                case 13:
                    message.aliceBaseKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionStructure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SessionStructure.SessionStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SessionStructure.SessionStructure} SessionStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionStructure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionStructure message.
         * @function verify
         * @memberof SessionStructure.SessionStructure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionStructure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sessionVersion != null && message.hasOwnProperty("sessionVersion"))
                if (!$util.isInteger(message.sessionVersion))
                    return "sessionVersion: integer expected";
            if (message.localIdentityPublic != null && message.hasOwnProperty("localIdentityPublic"))
                if (!(message.localIdentityPublic && typeof message.localIdentityPublic.length === "number" || $util.isString(message.localIdentityPublic)))
                    return "localIdentityPublic: buffer expected";
            if (message.remoteIdentityPublic != null && message.hasOwnProperty("remoteIdentityPublic"))
                if (!(message.remoteIdentityPublic && typeof message.remoteIdentityPublic.length === "number" || $util.isString(message.remoteIdentityPublic)))
                    return "remoteIdentityPublic: buffer expected";
            if (message.rootKey != null && message.hasOwnProperty("rootKey"))
                if (!(message.rootKey && typeof message.rootKey.length === "number" || $util.isString(message.rootKey)))
                    return "rootKey: buffer expected";
            if (message.previousCounter != null && message.hasOwnProperty("previousCounter"))
                if (!$util.isInteger(message.previousCounter))
                    return "previousCounter: integer expected";
            if (message.senderChain != null && message.hasOwnProperty("senderChain")) {
                var error = $root.SessionStructure.SessionStructure.Chain.verify(message.senderChain);
                if (error)
                    return "senderChain." + error;
            }
            if (message.receiverChains != null && message.hasOwnProperty("receiverChains")) {
                if (!Array.isArray(message.receiverChains))
                    return "receiverChains: array expected";
                for (var i = 0; i < message.receiverChains.length; ++i) {
                    var error = $root.SessionStructure.SessionStructure.Chain.verify(message.receiverChains[i]);
                    if (error)
                        return "receiverChains." + error;
                }
            }
            if (message.pendingKeyExchange != null && message.hasOwnProperty("pendingKeyExchange")) {
                var error = $root.SessionStructure.SessionStructure.PendingKeyExchange.verify(message.pendingKeyExchange);
                if (error)
                    return "pendingKeyExchange." + error;
            }
            if (message.pendingPreKey != null && message.hasOwnProperty("pendingPreKey")) {
                var error = $root.SessionStructure.SessionStructure.PendingPreKey.verify(message.pendingPreKey);
                if (error)
                    return "pendingPreKey." + error;
            }
            if (message.remoteRegistrationId != null && message.hasOwnProperty("remoteRegistrationId"))
                if (!$util.isInteger(message.remoteRegistrationId))
                    return "remoteRegistrationId: integer expected";
            if (message.localRegistrationId != null && message.hasOwnProperty("localRegistrationId"))
                if (!$util.isInteger(message.localRegistrationId))
                    return "localRegistrationId: integer expected";
            if (message.needsRefresh != null && message.hasOwnProperty("needsRefresh"))
                if (typeof message.needsRefresh !== "boolean")
                    return "needsRefresh: boolean expected";
            if (message.aliceBaseKey != null && message.hasOwnProperty("aliceBaseKey"))
                if (!(message.aliceBaseKey && typeof message.aliceBaseKey.length === "number" || $util.isString(message.aliceBaseKey)))
                    return "aliceBaseKey: buffer expected";
            return null;
        };

        /**
         * Creates a SessionStructure message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SessionStructure.SessionStructure
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SessionStructure.SessionStructure} SessionStructure
         */
        SessionStructure.fromObject = function fromObject(object) {
            if (object instanceof $root.SessionStructure.SessionStructure)
                return object;
            var message = new $root.SessionStructure.SessionStructure();
            if (object.sessionVersion != null)
                message.sessionVersion = object.sessionVersion >>> 0;
            if (object.localIdentityPublic != null)
                if (typeof object.localIdentityPublic === "string")
                    $util.base64.decode(object.localIdentityPublic, message.localIdentityPublic = $util.newBuffer($util.base64.length(object.localIdentityPublic)), 0);
                else if (object.localIdentityPublic.length)
                    message.localIdentityPublic = object.localIdentityPublic;
            if (object.remoteIdentityPublic != null)
                if (typeof object.remoteIdentityPublic === "string")
                    $util.base64.decode(object.remoteIdentityPublic, message.remoteIdentityPublic = $util.newBuffer($util.base64.length(object.remoteIdentityPublic)), 0);
                else if (object.remoteIdentityPublic.length)
                    message.remoteIdentityPublic = object.remoteIdentityPublic;
            if (object.rootKey != null)
                if (typeof object.rootKey === "string")
                    $util.base64.decode(object.rootKey, message.rootKey = $util.newBuffer($util.base64.length(object.rootKey)), 0);
                else if (object.rootKey.length)
                    message.rootKey = object.rootKey;
            if (object.previousCounter != null)
                message.previousCounter = object.previousCounter >>> 0;
            if (object.senderChain != null) {
                if (typeof object.senderChain !== "object")
                    throw TypeError(".SessionStructure.SessionStructure.senderChain: object expected");
                message.senderChain = $root.SessionStructure.SessionStructure.Chain.fromObject(object.senderChain);
            }
            if (object.receiverChains) {
                if (!Array.isArray(object.receiverChains))
                    throw TypeError(".SessionStructure.SessionStructure.receiverChains: array expected");
                message.receiverChains = [];
                for (var i = 0; i < object.receiverChains.length; ++i) {
                    if (typeof object.receiverChains[i] !== "object")
                        throw TypeError(".SessionStructure.SessionStructure.receiverChains: object expected");
                    message.receiverChains[i] = $root.SessionStructure.SessionStructure.Chain.fromObject(object.receiverChains[i]);
                }
            }
            if (object.pendingKeyExchange != null) {
                if (typeof object.pendingKeyExchange !== "object")
                    throw TypeError(".SessionStructure.SessionStructure.pendingKeyExchange: object expected");
                message.pendingKeyExchange = $root.SessionStructure.SessionStructure.PendingKeyExchange.fromObject(object.pendingKeyExchange);
            }
            if (object.pendingPreKey != null) {
                if (typeof object.pendingPreKey !== "object")
                    throw TypeError(".SessionStructure.SessionStructure.pendingPreKey: object expected");
                message.pendingPreKey = $root.SessionStructure.SessionStructure.PendingPreKey.fromObject(object.pendingPreKey);
            }
            if (object.remoteRegistrationId != null)
                message.remoteRegistrationId = object.remoteRegistrationId >>> 0;
            if (object.localRegistrationId != null)
                message.localRegistrationId = object.localRegistrationId >>> 0;
            if (object.needsRefresh != null)
                message.needsRefresh = Boolean(object.needsRefresh);
            if (object.aliceBaseKey != null)
                if (typeof object.aliceBaseKey === "string")
                    $util.base64.decode(object.aliceBaseKey, message.aliceBaseKey = $util.newBuffer($util.base64.length(object.aliceBaseKey)), 0);
                else if (object.aliceBaseKey.length)
                    message.aliceBaseKey = object.aliceBaseKey;
            return message;
        };

        /**
         * Creates a plain object from a SessionStructure message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SessionStructure.SessionStructure
         * @static
         * @param {SessionStructure.SessionStructure} message SessionStructure
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionStructure.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.receiverChains = [];
            if (options.defaults) {
                object.sessionVersion = 0;
                if (options.bytes === String)
                    object.localIdentityPublic = "";
                else {
                    object.localIdentityPublic = [];
                    if (options.bytes !== Array)
                        object.localIdentityPublic = $util.newBuffer(object.localIdentityPublic);
                }
                if (options.bytes === String)
                    object.remoteIdentityPublic = "";
                else {
                    object.remoteIdentityPublic = [];
                    if (options.bytes !== Array)
                        object.remoteIdentityPublic = $util.newBuffer(object.remoteIdentityPublic);
                }
                if (options.bytes === String)
                    object.rootKey = "";
                else {
                    object.rootKey = [];
                    if (options.bytes !== Array)
                        object.rootKey = $util.newBuffer(object.rootKey);
                }
                object.previousCounter = 0;
                object.senderChain = null;
                object.pendingKeyExchange = null;
                object.pendingPreKey = null;
                object.remoteRegistrationId = 0;
                object.localRegistrationId = 0;
                object.needsRefresh = false;
                if (options.bytes === String)
                    object.aliceBaseKey = "";
                else {
                    object.aliceBaseKey = [];
                    if (options.bytes !== Array)
                        object.aliceBaseKey = $util.newBuffer(object.aliceBaseKey);
                }
            }
            if (message.sessionVersion != null && message.hasOwnProperty("sessionVersion"))
                object.sessionVersion = message.sessionVersion;
            if (message.localIdentityPublic != null && message.hasOwnProperty("localIdentityPublic"))
                object.localIdentityPublic = options.bytes === String ? $util.base64.encode(message.localIdentityPublic, 0, message.localIdentityPublic.length) : options.bytes === Array ? Array.prototype.slice.call(message.localIdentityPublic) : message.localIdentityPublic;
            if (message.remoteIdentityPublic != null && message.hasOwnProperty("remoteIdentityPublic"))
                object.remoteIdentityPublic = options.bytes === String ? $util.base64.encode(message.remoteIdentityPublic, 0, message.remoteIdentityPublic.length) : options.bytes === Array ? Array.prototype.slice.call(message.remoteIdentityPublic) : message.remoteIdentityPublic;
            if (message.rootKey != null && message.hasOwnProperty("rootKey"))
                object.rootKey = options.bytes === String ? $util.base64.encode(message.rootKey, 0, message.rootKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.rootKey) : message.rootKey;
            if (message.previousCounter != null && message.hasOwnProperty("previousCounter"))
                object.previousCounter = message.previousCounter;
            if (message.senderChain != null && message.hasOwnProperty("senderChain"))
                object.senderChain = $root.SessionStructure.SessionStructure.Chain.toObject(message.senderChain, options);
            if (message.receiverChains && message.receiverChains.length) {
                object.receiverChains = [];
                for (var j = 0; j < message.receiverChains.length; ++j)
                    object.receiverChains[j] = $root.SessionStructure.SessionStructure.Chain.toObject(message.receiverChains[j], options);
            }
            if (message.pendingKeyExchange != null && message.hasOwnProperty("pendingKeyExchange"))
                object.pendingKeyExchange = $root.SessionStructure.SessionStructure.PendingKeyExchange.toObject(message.pendingKeyExchange, options);
            if (message.pendingPreKey != null && message.hasOwnProperty("pendingPreKey"))
                object.pendingPreKey = $root.SessionStructure.SessionStructure.PendingPreKey.toObject(message.pendingPreKey, options);
            if (message.remoteRegistrationId != null && message.hasOwnProperty("remoteRegistrationId"))
                object.remoteRegistrationId = message.remoteRegistrationId;
            if (message.localRegistrationId != null && message.hasOwnProperty("localRegistrationId"))
                object.localRegistrationId = message.localRegistrationId;
            if (message.needsRefresh != null && message.hasOwnProperty("needsRefresh"))
                object.needsRefresh = message.needsRefresh;
            if (message.aliceBaseKey != null && message.hasOwnProperty("aliceBaseKey"))
                object.aliceBaseKey = options.bytes === String ? $util.base64.encode(message.aliceBaseKey, 0, message.aliceBaseKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.aliceBaseKey) : message.aliceBaseKey;
            return object;
        };

        /**
         * Converts this SessionStructure to JSON.
         * @function toJSON
         * @memberof SessionStructure.SessionStructure
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionStructure.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        SessionStructure.Chain = (function() {

            /**
             * Properties of a Chain.
             * @memberof SessionStructure.SessionStructure
             * @interface IChain
             * @property {Uint8Array|null} [senderRatchetKey] Chain senderRatchetKey
             * @property {Uint8Array|null} [senderRatchetKeyPrivate] Chain senderRatchetKeyPrivate
             * @property {SessionStructure.SessionStructure.Chain.IChainKey|null} [chainKey] Chain chainKey
             * @property {Array.<SessionStructure.SessionStructure.Chain.IMessageKey>|null} [messageKeys] Chain messageKeys
             */

            /**
             * Constructs a new Chain.
             * @memberof SessionStructure.SessionStructure
             * @classdesc Represents a Chain.
             * @implements IChain
             * @constructor
             * @param {SessionStructure.SessionStructure.IChain=} [properties] Properties to set
             */
            function Chain(properties) {
                this.messageKeys = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Chain senderRatchetKey.
             * @member {Uint8Array} senderRatchetKey
             * @memberof SessionStructure.SessionStructure.Chain
             * @instance
             */
            Chain.prototype.senderRatchetKey = $util.newBuffer([]);

            /**
             * Chain senderRatchetKeyPrivate.
             * @member {Uint8Array} senderRatchetKeyPrivate
             * @memberof SessionStructure.SessionStructure.Chain
             * @instance
             */
            Chain.prototype.senderRatchetKeyPrivate = $util.newBuffer([]);

            /**
             * Chain chainKey.
             * @member {SessionStructure.SessionStructure.Chain.IChainKey|null|undefined} chainKey
             * @memberof SessionStructure.SessionStructure.Chain
             * @instance
             */
            Chain.prototype.chainKey = null;

            /**
             * Chain messageKeys.
             * @member {Array.<SessionStructure.SessionStructure.Chain.IMessageKey>} messageKeys
             * @memberof SessionStructure.SessionStructure.Chain
             * @instance
             */
            Chain.prototype.messageKeys = $util.emptyArray;

            /**
             * Creates a new Chain instance using the specified properties.
             * @function create
             * @memberof SessionStructure.SessionStructure.Chain
             * @static
             * @param {SessionStructure.SessionStructure.IChain=} [properties] Properties to set
             * @returns {SessionStructure.SessionStructure.Chain} Chain instance
             */
            Chain.create = function create(properties) {
                return new Chain(properties);
            };

            /**
             * Encodes the specified Chain message. Does not implicitly {@link SessionStructure.SessionStructure.Chain.verify|verify} messages.
             * @function encode
             * @memberof SessionStructure.SessionStructure.Chain
             * @static
             * @param {SessionStructure.SessionStructure.IChain} message Chain message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Chain.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.senderRatchetKey != null && Object.hasOwnProperty.call(message, "senderRatchetKey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.senderRatchetKey);
                if (message.senderRatchetKeyPrivate != null && Object.hasOwnProperty.call(message, "senderRatchetKeyPrivate"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.senderRatchetKeyPrivate);
                if (message.chainKey != null && Object.hasOwnProperty.call(message, "chainKey"))
                    $root.SessionStructure.SessionStructure.Chain.ChainKey.encode(message.chainKey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.messageKeys != null && message.messageKeys.length)
                    for (var i = 0; i < message.messageKeys.length; ++i)
                        $root.SessionStructure.SessionStructure.Chain.MessageKey.encode(message.messageKeys[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Chain message, length delimited. Does not implicitly {@link SessionStructure.SessionStructure.Chain.verify|verify} messages.
             * @function encodeDelimited
             * @memberof SessionStructure.SessionStructure.Chain
             * @static
             * @param {SessionStructure.SessionStructure.IChain} message Chain message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Chain.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Chain message from the specified reader or buffer.
             * @function decode
             * @memberof SessionStructure.SessionStructure.Chain
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {SessionStructure.SessionStructure.Chain} Chain
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Chain.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionStructure.SessionStructure.Chain();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.senderRatchetKey = reader.bytes();
                        break;
                    case 2:
                        message.senderRatchetKeyPrivate = reader.bytes();
                        break;
                    case 3:
                        message.chainKey = $root.SessionStructure.SessionStructure.Chain.ChainKey.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.messageKeys && message.messageKeys.length))
                            message.messageKeys = [];
                        message.messageKeys.push($root.SessionStructure.SessionStructure.Chain.MessageKey.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Chain message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof SessionStructure.SessionStructure.Chain
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {SessionStructure.SessionStructure.Chain} Chain
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Chain.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Chain message.
             * @function verify
             * @memberof SessionStructure.SessionStructure.Chain
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Chain.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.senderRatchetKey != null && message.hasOwnProperty("senderRatchetKey"))
                    if (!(message.senderRatchetKey && typeof message.senderRatchetKey.length === "number" || $util.isString(message.senderRatchetKey)))
                        return "senderRatchetKey: buffer expected";
                if (message.senderRatchetKeyPrivate != null && message.hasOwnProperty("senderRatchetKeyPrivate"))
                    if (!(message.senderRatchetKeyPrivate && typeof message.senderRatchetKeyPrivate.length === "number" || $util.isString(message.senderRatchetKeyPrivate)))
                        return "senderRatchetKeyPrivate: buffer expected";
                if (message.chainKey != null && message.hasOwnProperty("chainKey")) {
                    var error = $root.SessionStructure.SessionStructure.Chain.ChainKey.verify(message.chainKey);
                    if (error)
                        return "chainKey." + error;
                }
                if (message.messageKeys != null && message.hasOwnProperty("messageKeys")) {
                    if (!Array.isArray(message.messageKeys))
                        return "messageKeys: array expected";
                    for (var i = 0; i < message.messageKeys.length; ++i) {
                        var error = $root.SessionStructure.SessionStructure.Chain.MessageKey.verify(message.messageKeys[i]);
                        if (error)
                            return "messageKeys." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Chain message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof SessionStructure.SessionStructure.Chain
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {SessionStructure.SessionStructure.Chain} Chain
             */
            Chain.fromObject = function fromObject(object) {
                if (object instanceof $root.SessionStructure.SessionStructure.Chain)
                    return object;
                var message = new $root.SessionStructure.SessionStructure.Chain();
                if (object.senderRatchetKey != null)
                    if (typeof object.senderRatchetKey === "string")
                        $util.base64.decode(object.senderRatchetKey, message.senderRatchetKey = $util.newBuffer($util.base64.length(object.senderRatchetKey)), 0);
                    else if (object.senderRatchetKey.length)
                        message.senderRatchetKey = object.senderRatchetKey;
                if (object.senderRatchetKeyPrivate != null)
                    if (typeof object.senderRatchetKeyPrivate === "string")
                        $util.base64.decode(object.senderRatchetKeyPrivate, message.senderRatchetKeyPrivate = $util.newBuffer($util.base64.length(object.senderRatchetKeyPrivate)), 0);
                    else if (object.senderRatchetKeyPrivate.length)
                        message.senderRatchetKeyPrivate = object.senderRatchetKeyPrivate;
                if (object.chainKey != null) {
                    if (typeof object.chainKey !== "object")
                        throw TypeError(".SessionStructure.SessionStructure.Chain.chainKey: object expected");
                    message.chainKey = $root.SessionStructure.SessionStructure.Chain.ChainKey.fromObject(object.chainKey);
                }
                if (object.messageKeys) {
                    if (!Array.isArray(object.messageKeys))
                        throw TypeError(".SessionStructure.SessionStructure.Chain.messageKeys: array expected");
                    message.messageKeys = [];
                    for (var i = 0; i < object.messageKeys.length; ++i) {
                        if (typeof object.messageKeys[i] !== "object")
                            throw TypeError(".SessionStructure.SessionStructure.Chain.messageKeys: object expected");
                        message.messageKeys[i] = $root.SessionStructure.SessionStructure.Chain.MessageKey.fromObject(object.messageKeys[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Chain message. Also converts values to other types if specified.
             * @function toObject
             * @memberof SessionStructure.SessionStructure.Chain
             * @static
             * @param {SessionStructure.SessionStructure.Chain} message Chain
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Chain.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.messageKeys = [];
                if (options.defaults) {
                    if (options.bytes === String)
                        object.senderRatchetKey = "";
                    else {
                        object.senderRatchetKey = [];
                        if (options.bytes !== Array)
                            object.senderRatchetKey = $util.newBuffer(object.senderRatchetKey);
                    }
                    if (options.bytes === String)
                        object.senderRatchetKeyPrivate = "";
                    else {
                        object.senderRatchetKeyPrivate = [];
                        if (options.bytes !== Array)
                            object.senderRatchetKeyPrivate = $util.newBuffer(object.senderRatchetKeyPrivate);
                    }
                    object.chainKey = null;
                }
                if (message.senderRatchetKey != null && message.hasOwnProperty("senderRatchetKey"))
                    object.senderRatchetKey = options.bytes === String ? $util.base64.encode(message.senderRatchetKey, 0, message.senderRatchetKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderRatchetKey) : message.senderRatchetKey;
                if (message.senderRatchetKeyPrivate != null && message.hasOwnProperty("senderRatchetKeyPrivate"))
                    object.senderRatchetKeyPrivate = options.bytes === String ? $util.base64.encode(message.senderRatchetKeyPrivate, 0, message.senderRatchetKeyPrivate.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderRatchetKeyPrivate) : message.senderRatchetKeyPrivate;
                if (message.chainKey != null && message.hasOwnProperty("chainKey"))
                    object.chainKey = $root.SessionStructure.SessionStructure.Chain.ChainKey.toObject(message.chainKey, options);
                if (message.messageKeys && message.messageKeys.length) {
                    object.messageKeys = [];
                    for (var j = 0; j < message.messageKeys.length; ++j)
                        object.messageKeys[j] = $root.SessionStructure.SessionStructure.Chain.MessageKey.toObject(message.messageKeys[j], options);
                }
                return object;
            };

            /**
             * Converts this Chain to JSON.
             * @function toJSON
             * @memberof SessionStructure.SessionStructure.Chain
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Chain.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Chain.ChainKey = (function() {

                /**
                 * Properties of a ChainKey.
                 * @memberof SessionStructure.SessionStructure.Chain
                 * @interface IChainKey
                 * @property {number|null} [index] ChainKey index
                 * @property {Uint8Array|null} [key] ChainKey key
                 */

                /**
                 * Constructs a new ChainKey.
                 * @memberof SessionStructure.SessionStructure.Chain
                 * @classdesc Represents a ChainKey.
                 * @implements IChainKey
                 * @constructor
                 * @param {SessionStructure.SessionStructure.Chain.IChainKey=} [properties] Properties to set
                 */
                function ChainKey(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ChainKey index.
                 * @member {number} index
                 * @memberof SessionStructure.SessionStructure.Chain.ChainKey
                 * @instance
                 */
                ChainKey.prototype.index = 0;

                /**
                 * ChainKey key.
                 * @member {Uint8Array} key
                 * @memberof SessionStructure.SessionStructure.Chain.ChainKey
                 * @instance
                 */
                ChainKey.prototype.key = $util.newBuffer([]);

                /**
                 * Creates a new ChainKey instance using the specified properties.
                 * @function create
                 * @memberof SessionStructure.SessionStructure.Chain.ChainKey
                 * @static
                 * @param {SessionStructure.SessionStructure.Chain.IChainKey=} [properties] Properties to set
                 * @returns {SessionStructure.SessionStructure.Chain.ChainKey} ChainKey instance
                 */
                ChainKey.create = function create(properties) {
                    return new ChainKey(properties);
                };

                /**
                 * Encodes the specified ChainKey message. Does not implicitly {@link SessionStructure.SessionStructure.Chain.ChainKey.verify|verify} messages.
                 * @function encode
                 * @memberof SessionStructure.SessionStructure.Chain.ChainKey
                 * @static
                 * @param {SessionStructure.SessionStructure.Chain.IChainKey} message ChainKey message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChainKey.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
                    return writer;
                };

                /**
                 * Encodes the specified ChainKey message, length delimited. Does not implicitly {@link SessionStructure.SessionStructure.Chain.ChainKey.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof SessionStructure.SessionStructure.Chain.ChainKey
                 * @static
                 * @param {SessionStructure.SessionStructure.Chain.IChainKey} message ChainKey message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChainKey.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ChainKey message from the specified reader or buffer.
                 * @function decode
                 * @memberof SessionStructure.SessionStructure.Chain.ChainKey
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {SessionStructure.SessionStructure.Chain.ChainKey} ChainKey
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChainKey.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionStructure.SessionStructure.Chain.ChainKey();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.index = reader.uint32();
                            break;
                        case 2:
                            message.key = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ChainKey message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof SessionStructure.SessionStructure.Chain.ChainKey
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {SessionStructure.SessionStructure.Chain.ChainKey} ChainKey
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChainKey.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ChainKey message.
                 * @function verify
                 * @memberof SessionStructure.SessionStructure.Chain.ChainKey
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ChainKey.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.index != null && message.hasOwnProperty("index"))
                        if (!$util.isInteger(message.index))
                            return "index: integer expected";
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                            return "key: buffer expected";
                    return null;
                };

                /**
                 * Creates a ChainKey message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof SessionStructure.SessionStructure.Chain.ChainKey
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {SessionStructure.SessionStructure.Chain.ChainKey} ChainKey
                 */
                ChainKey.fromObject = function fromObject(object) {
                    if (object instanceof $root.SessionStructure.SessionStructure.Chain.ChainKey)
                        return object;
                    var message = new $root.SessionStructure.SessionStructure.Chain.ChainKey();
                    if (object.index != null)
                        message.index = object.index >>> 0;
                    if (object.key != null)
                        if (typeof object.key === "string")
                            $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                        else if (object.key.length)
                            message.key = object.key;
                    return message;
                };

                /**
                 * Creates a plain object from a ChainKey message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof SessionStructure.SessionStructure.Chain.ChainKey
                 * @static
                 * @param {SessionStructure.SessionStructure.Chain.ChainKey} message ChainKey
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ChainKey.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.index = 0;
                        if (options.bytes === String)
                            object.key = "";
                        else {
                            object.key = [];
                            if (options.bytes !== Array)
                                object.key = $util.newBuffer(object.key);
                        }
                    }
                    if (message.index != null && message.hasOwnProperty("index"))
                        object.index = message.index;
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                    return object;
                };

                /**
                 * Converts this ChainKey to JSON.
                 * @function toJSON
                 * @memberof SessionStructure.SessionStructure.Chain.ChainKey
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ChainKey.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ChainKey;
            })();

            Chain.MessageKey = (function() {

                /**
                 * Properties of a MessageKey.
                 * @memberof SessionStructure.SessionStructure.Chain
                 * @interface IMessageKey
                 * @property {number|null} [index] MessageKey index
                 * @property {Uint8Array|null} [cipherKey] MessageKey cipherKey
                 * @property {Uint8Array|null} [macKey] MessageKey macKey
                 * @property {Uint8Array|null} [iv] MessageKey iv
                 */

                /**
                 * Constructs a new MessageKey.
                 * @memberof SessionStructure.SessionStructure.Chain
                 * @classdesc Represents a MessageKey.
                 * @implements IMessageKey
                 * @constructor
                 * @param {SessionStructure.SessionStructure.Chain.IMessageKey=} [properties] Properties to set
                 */
                function MessageKey(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MessageKey index.
                 * @member {number} index
                 * @memberof SessionStructure.SessionStructure.Chain.MessageKey
                 * @instance
                 */
                MessageKey.prototype.index = 0;

                /**
                 * MessageKey cipherKey.
                 * @member {Uint8Array} cipherKey
                 * @memberof SessionStructure.SessionStructure.Chain.MessageKey
                 * @instance
                 */
                MessageKey.prototype.cipherKey = $util.newBuffer([]);

                /**
                 * MessageKey macKey.
                 * @member {Uint8Array} macKey
                 * @memberof SessionStructure.SessionStructure.Chain.MessageKey
                 * @instance
                 */
                MessageKey.prototype.macKey = $util.newBuffer([]);

                /**
                 * MessageKey iv.
                 * @member {Uint8Array} iv
                 * @memberof SessionStructure.SessionStructure.Chain.MessageKey
                 * @instance
                 */
                MessageKey.prototype.iv = $util.newBuffer([]);

                /**
                 * Creates a new MessageKey instance using the specified properties.
                 * @function create
                 * @memberof SessionStructure.SessionStructure.Chain.MessageKey
                 * @static
                 * @param {SessionStructure.SessionStructure.Chain.IMessageKey=} [properties] Properties to set
                 * @returns {SessionStructure.SessionStructure.Chain.MessageKey} MessageKey instance
                 */
                MessageKey.create = function create(properties) {
                    return new MessageKey(properties);
                };

                /**
                 * Encodes the specified MessageKey message. Does not implicitly {@link SessionStructure.SessionStructure.Chain.MessageKey.verify|verify} messages.
                 * @function encode
                 * @memberof SessionStructure.SessionStructure.Chain.MessageKey
                 * @static
                 * @param {SessionStructure.SessionStructure.Chain.IMessageKey} message MessageKey message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageKey.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);
                    if (message.cipherKey != null && Object.hasOwnProperty.call(message, "cipherKey"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.cipherKey);
                    if (message.macKey != null && Object.hasOwnProperty.call(message, "macKey"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.macKey);
                    if (message.iv != null && Object.hasOwnProperty.call(message, "iv"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.iv);
                    return writer;
                };

                /**
                 * Encodes the specified MessageKey message, length delimited. Does not implicitly {@link SessionStructure.SessionStructure.Chain.MessageKey.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof SessionStructure.SessionStructure.Chain.MessageKey
                 * @static
                 * @param {SessionStructure.SessionStructure.Chain.IMessageKey} message MessageKey message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageKey.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MessageKey message from the specified reader or buffer.
                 * @function decode
                 * @memberof SessionStructure.SessionStructure.Chain.MessageKey
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {SessionStructure.SessionStructure.Chain.MessageKey} MessageKey
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageKey.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionStructure.SessionStructure.Chain.MessageKey();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.index = reader.uint32();
                            break;
                        case 2:
                            message.cipherKey = reader.bytes();
                            break;
                        case 3:
                            message.macKey = reader.bytes();
                            break;
                        case 4:
                            message.iv = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MessageKey message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof SessionStructure.SessionStructure.Chain.MessageKey
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {SessionStructure.SessionStructure.Chain.MessageKey} MessageKey
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageKey.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MessageKey message.
                 * @function verify
                 * @memberof SessionStructure.SessionStructure.Chain.MessageKey
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageKey.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.index != null && message.hasOwnProperty("index"))
                        if (!$util.isInteger(message.index))
                            return "index: integer expected";
                    if (message.cipherKey != null && message.hasOwnProperty("cipherKey"))
                        if (!(message.cipherKey && typeof message.cipherKey.length === "number" || $util.isString(message.cipherKey)))
                            return "cipherKey: buffer expected";
                    if (message.macKey != null && message.hasOwnProperty("macKey"))
                        if (!(message.macKey && typeof message.macKey.length === "number" || $util.isString(message.macKey)))
                            return "macKey: buffer expected";
                    if (message.iv != null && message.hasOwnProperty("iv"))
                        if (!(message.iv && typeof message.iv.length === "number" || $util.isString(message.iv)))
                            return "iv: buffer expected";
                    return null;
                };

                /**
                 * Creates a MessageKey message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof SessionStructure.SessionStructure.Chain.MessageKey
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {SessionStructure.SessionStructure.Chain.MessageKey} MessageKey
                 */
                MessageKey.fromObject = function fromObject(object) {
                    if (object instanceof $root.SessionStructure.SessionStructure.Chain.MessageKey)
                        return object;
                    var message = new $root.SessionStructure.SessionStructure.Chain.MessageKey();
                    if (object.index != null)
                        message.index = object.index >>> 0;
                    if (object.cipherKey != null)
                        if (typeof object.cipherKey === "string")
                            $util.base64.decode(object.cipherKey, message.cipherKey = $util.newBuffer($util.base64.length(object.cipherKey)), 0);
                        else if (object.cipherKey.length)
                            message.cipherKey = object.cipherKey;
                    if (object.macKey != null)
                        if (typeof object.macKey === "string")
                            $util.base64.decode(object.macKey, message.macKey = $util.newBuffer($util.base64.length(object.macKey)), 0);
                        else if (object.macKey.length)
                            message.macKey = object.macKey;
                    if (object.iv != null)
                        if (typeof object.iv === "string")
                            $util.base64.decode(object.iv, message.iv = $util.newBuffer($util.base64.length(object.iv)), 0);
                        else if (object.iv.length)
                            message.iv = object.iv;
                    return message;
                };

                /**
                 * Creates a plain object from a MessageKey message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof SessionStructure.SessionStructure.Chain.MessageKey
                 * @static
                 * @param {SessionStructure.SessionStructure.Chain.MessageKey} message MessageKey
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageKey.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.index = 0;
                        if (options.bytes === String)
                            object.cipherKey = "";
                        else {
                            object.cipherKey = [];
                            if (options.bytes !== Array)
                                object.cipherKey = $util.newBuffer(object.cipherKey);
                        }
                        if (options.bytes === String)
                            object.macKey = "";
                        else {
                            object.macKey = [];
                            if (options.bytes !== Array)
                                object.macKey = $util.newBuffer(object.macKey);
                        }
                        if (options.bytes === String)
                            object.iv = "";
                        else {
                            object.iv = [];
                            if (options.bytes !== Array)
                                object.iv = $util.newBuffer(object.iv);
                        }
                    }
                    if (message.index != null && message.hasOwnProperty("index"))
                        object.index = message.index;
                    if (message.cipherKey != null && message.hasOwnProperty("cipherKey"))
                        object.cipherKey = options.bytes === String ? $util.base64.encode(message.cipherKey, 0, message.cipherKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.cipherKey) : message.cipherKey;
                    if (message.macKey != null && message.hasOwnProperty("macKey"))
                        object.macKey = options.bytes === String ? $util.base64.encode(message.macKey, 0, message.macKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.macKey) : message.macKey;
                    if (message.iv != null && message.hasOwnProperty("iv"))
                        object.iv = options.bytes === String ? $util.base64.encode(message.iv, 0, message.iv.length) : options.bytes === Array ? Array.prototype.slice.call(message.iv) : message.iv;
                    return object;
                };

                /**
                 * Converts this MessageKey to JSON.
                 * @function toJSON
                 * @memberof SessionStructure.SessionStructure.Chain.MessageKey
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageKey.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MessageKey;
            })();

            return Chain;
        })();

        SessionStructure.PendingKeyExchange = (function() {

            /**
             * Properties of a PendingKeyExchange.
             * @memberof SessionStructure.SessionStructure
             * @interface IPendingKeyExchange
             * @property {number|null} [sequence] PendingKeyExchange sequence
             * @property {Uint8Array|null} [localBaseKey] PendingKeyExchange localBaseKey
             * @property {Uint8Array|null} [localBaseKeyPrivate] PendingKeyExchange localBaseKeyPrivate
             * @property {Uint8Array|null} [localRatchetKey] PendingKeyExchange localRatchetKey
             * @property {Uint8Array|null} [localRatchetKeyPrivate] PendingKeyExchange localRatchetKeyPrivate
             * @property {Uint8Array|null} [localIdentityKey] PendingKeyExchange localIdentityKey
             * @property {Uint8Array|null} [localIdentityKeyPrivate] PendingKeyExchange localIdentityKeyPrivate
             */

            /**
             * Constructs a new PendingKeyExchange.
             * @memberof SessionStructure.SessionStructure
             * @classdesc Represents a PendingKeyExchange.
             * @implements IPendingKeyExchange
             * @constructor
             * @param {SessionStructure.SessionStructure.IPendingKeyExchange=} [properties] Properties to set
             */
            function PendingKeyExchange(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PendingKeyExchange sequence.
             * @member {number} sequence
             * @memberof SessionStructure.SessionStructure.PendingKeyExchange
             * @instance
             */
            PendingKeyExchange.prototype.sequence = 0;

            /**
             * PendingKeyExchange localBaseKey.
             * @member {Uint8Array} localBaseKey
             * @memberof SessionStructure.SessionStructure.PendingKeyExchange
             * @instance
             */
            PendingKeyExchange.prototype.localBaseKey = $util.newBuffer([]);

            /**
             * PendingKeyExchange localBaseKeyPrivate.
             * @member {Uint8Array} localBaseKeyPrivate
             * @memberof SessionStructure.SessionStructure.PendingKeyExchange
             * @instance
             */
            PendingKeyExchange.prototype.localBaseKeyPrivate = $util.newBuffer([]);

            /**
             * PendingKeyExchange localRatchetKey.
             * @member {Uint8Array} localRatchetKey
             * @memberof SessionStructure.SessionStructure.PendingKeyExchange
             * @instance
             */
            PendingKeyExchange.prototype.localRatchetKey = $util.newBuffer([]);

            /**
             * PendingKeyExchange localRatchetKeyPrivate.
             * @member {Uint8Array} localRatchetKeyPrivate
             * @memberof SessionStructure.SessionStructure.PendingKeyExchange
             * @instance
             */
            PendingKeyExchange.prototype.localRatchetKeyPrivate = $util.newBuffer([]);

            /**
             * PendingKeyExchange localIdentityKey.
             * @member {Uint8Array} localIdentityKey
             * @memberof SessionStructure.SessionStructure.PendingKeyExchange
             * @instance
             */
            PendingKeyExchange.prototype.localIdentityKey = $util.newBuffer([]);

            /**
             * PendingKeyExchange localIdentityKeyPrivate.
             * @member {Uint8Array} localIdentityKeyPrivate
             * @memberof SessionStructure.SessionStructure.PendingKeyExchange
             * @instance
             */
            PendingKeyExchange.prototype.localIdentityKeyPrivate = $util.newBuffer([]);

            /**
             * Creates a new PendingKeyExchange instance using the specified properties.
             * @function create
             * @memberof SessionStructure.SessionStructure.PendingKeyExchange
             * @static
             * @param {SessionStructure.SessionStructure.IPendingKeyExchange=} [properties] Properties to set
             * @returns {SessionStructure.SessionStructure.PendingKeyExchange} PendingKeyExchange instance
             */
            PendingKeyExchange.create = function create(properties) {
                return new PendingKeyExchange(properties);
            };

            /**
             * Encodes the specified PendingKeyExchange message. Does not implicitly {@link SessionStructure.SessionStructure.PendingKeyExchange.verify|verify} messages.
             * @function encode
             * @memberof SessionStructure.SessionStructure.PendingKeyExchange
             * @static
             * @param {SessionStructure.SessionStructure.IPendingKeyExchange} message PendingKeyExchange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PendingKeyExchange.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.sequence);
                if (message.localBaseKey != null && Object.hasOwnProperty.call(message, "localBaseKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.localBaseKey);
                if (message.localBaseKeyPrivate != null && Object.hasOwnProperty.call(message, "localBaseKeyPrivate"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.localBaseKeyPrivate);
                if (message.localRatchetKey != null && Object.hasOwnProperty.call(message, "localRatchetKey"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.localRatchetKey);
                if (message.localRatchetKeyPrivate != null && Object.hasOwnProperty.call(message, "localRatchetKeyPrivate"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.localRatchetKeyPrivate);
                if (message.localIdentityKey != null && Object.hasOwnProperty.call(message, "localIdentityKey"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.localIdentityKey);
                if (message.localIdentityKeyPrivate != null && Object.hasOwnProperty.call(message, "localIdentityKeyPrivate"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.localIdentityKeyPrivate);
                return writer;
            };

            /**
             * Encodes the specified PendingKeyExchange message, length delimited. Does not implicitly {@link SessionStructure.SessionStructure.PendingKeyExchange.verify|verify} messages.
             * @function encodeDelimited
             * @memberof SessionStructure.SessionStructure.PendingKeyExchange
             * @static
             * @param {SessionStructure.SessionStructure.IPendingKeyExchange} message PendingKeyExchange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PendingKeyExchange.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PendingKeyExchange message from the specified reader or buffer.
             * @function decode
             * @memberof SessionStructure.SessionStructure.PendingKeyExchange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {SessionStructure.SessionStructure.PendingKeyExchange} PendingKeyExchange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PendingKeyExchange.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionStructure.SessionStructure.PendingKeyExchange();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sequence = reader.uint32();
                        break;
                    case 2:
                        message.localBaseKey = reader.bytes();
                        break;
                    case 3:
                        message.localBaseKeyPrivate = reader.bytes();
                        break;
                    case 4:
                        message.localRatchetKey = reader.bytes();
                        break;
                    case 5:
                        message.localRatchetKeyPrivate = reader.bytes();
                        break;
                    case 7:
                        message.localIdentityKey = reader.bytes();
                        break;
                    case 8:
                        message.localIdentityKeyPrivate = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PendingKeyExchange message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof SessionStructure.SessionStructure.PendingKeyExchange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {SessionStructure.SessionStructure.PendingKeyExchange} PendingKeyExchange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PendingKeyExchange.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PendingKeyExchange message.
             * @function verify
             * @memberof SessionStructure.SessionStructure.PendingKeyExchange
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PendingKeyExchange.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    if (!$util.isInteger(message.sequence))
                        return "sequence: integer expected";
                if (message.localBaseKey != null && message.hasOwnProperty("localBaseKey"))
                    if (!(message.localBaseKey && typeof message.localBaseKey.length === "number" || $util.isString(message.localBaseKey)))
                        return "localBaseKey: buffer expected";
                if (message.localBaseKeyPrivate != null && message.hasOwnProperty("localBaseKeyPrivate"))
                    if (!(message.localBaseKeyPrivate && typeof message.localBaseKeyPrivate.length === "number" || $util.isString(message.localBaseKeyPrivate)))
                        return "localBaseKeyPrivate: buffer expected";
                if (message.localRatchetKey != null && message.hasOwnProperty("localRatchetKey"))
                    if (!(message.localRatchetKey && typeof message.localRatchetKey.length === "number" || $util.isString(message.localRatchetKey)))
                        return "localRatchetKey: buffer expected";
                if (message.localRatchetKeyPrivate != null && message.hasOwnProperty("localRatchetKeyPrivate"))
                    if (!(message.localRatchetKeyPrivate && typeof message.localRatchetKeyPrivate.length === "number" || $util.isString(message.localRatchetKeyPrivate)))
                        return "localRatchetKeyPrivate: buffer expected";
                if (message.localIdentityKey != null && message.hasOwnProperty("localIdentityKey"))
                    if (!(message.localIdentityKey && typeof message.localIdentityKey.length === "number" || $util.isString(message.localIdentityKey)))
                        return "localIdentityKey: buffer expected";
                if (message.localIdentityKeyPrivate != null && message.hasOwnProperty("localIdentityKeyPrivate"))
                    if (!(message.localIdentityKeyPrivate && typeof message.localIdentityKeyPrivate.length === "number" || $util.isString(message.localIdentityKeyPrivate)))
                        return "localIdentityKeyPrivate: buffer expected";
                return null;
            };

            /**
             * Creates a PendingKeyExchange message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof SessionStructure.SessionStructure.PendingKeyExchange
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {SessionStructure.SessionStructure.PendingKeyExchange} PendingKeyExchange
             */
            PendingKeyExchange.fromObject = function fromObject(object) {
                if (object instanceof $root.SessionStructure.SessionStructure.PendingKeyExchange)
                    return object;
                var message = new $root.SessionStructure.SessionStructure.PendingKeyExchange();
                if (object.sequence != null)
                    message.sequence = object.sequence >>> 0;
                if (object.localBaseKey != null)
                    if (typeof object.localBaseKey === "string")
                        $util.base64.decode(object.localBaseKey, message.localBaseKey = $util.newBuffer($util.base64.length(object.localBaseKey)), 0);
                    else if (object.localBaseKey.length)
                        message.localBaseKey = object.localBaseKey;
                if (object.localBaseKeyPrivate != null)
                    if (typeof object.localBaseKeyPrivate === "string")
                        $util.base64.decode(object.localBaseKeyPrivate, message.localBaseKeyPrivate = $util.newBuffer($util.base64.length(object.localBaseKeyPrivate)), 0);
                    else if (object.localBaseKeyPrivate.length)
                        message.localBaseKeyPrivate = object.localBaseKeyPrivate;
                if (object.localRatchetKey != null)
                    if (typeof object.localRatchetKey === "string")
                        $util.base64.decode(object.localRatchetKey, message.localRatchetKey = $util.newBuffer($util.base64.length(object.localRatchetKey)), 0);
                    else if (object.localRatchetKey.length)
                        message.localRatchetKey = object.localRatchetKey;
                if (object.localRatchetKeyPrivate != null)
                    if (typeof object.localRatchetKeyPrivate === "string")
                        $util.base64.decode(object.localRatchetKeyPrivate, message.localRatchetKeyPrivate = $util.newBuffer($util.base64.length(object.localRatchetKeyPrivate)), 0);
                    else if (object.localRatchetKeyPrivate.length)
                        message.localRatchetKeyPrivate = object.localRatchetKeyPrivate;
                if (object.localIdentityKey != null)
                    if (typeof object.localIdentityKey === "string")
                        $util.base64.decode(object.localIdentityKey, message.localIdentityKey = $util.newBuffer($util.base64.length(object.localIdentityKey)), 0);
                    else if (object.localIdentityKey.length)
                        message.localIdentityKey = object.localIdentityKey;
                if (object.localIdentityKeyPrivate != null)
                    if (typeof object.localIdentityKeyPrivate === "string")
                        $util.base64.decode(object.localIdentityKeyPrivate, message.localIdentityKeyPrivate = $util.newBuffer($util.base64.length(object.localIdentityKeyPrivate)), 0);
                    else if (object.localIdentityKeyPrivate.length)
                        message.localIdentityKeyPrivate = object.localIdentityKeyPrivate;
                return message;
            };

            /**
             * Creates a plain object from a PendingKeyExchange message. Also converts values to other types if specified.
             * @function toObject
             * @memberof SessionStructure.SessionStructure.PendingKeyExchange
             * @static
             * @param {SessionStructure.SessionStructure.PendingKeyExchange} message PendingKeyExchange
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PendingKeyExchange.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sequence = 0;
                    if (options.bytes === String)
                        object.localBaseKey = "";
                    else {
                        object.localBaseKey = [];
                        if (options.bytes !== Array)
                            object.localBaseKey = $util.newBuffer(object.localBaseKey);
                    }
                    if (options.bytes === String)
                        object.localBaseKeyPrivate = "";
                    else {
                        object.localBaseKeyPrivate = [];
                        if (options.bytes !== Array)
                            object.localBaseKeyPrivate = $util.newBuffer(object.localBaseKeyPrivate);
                    }
                    if (options.bytes === String)
                        object.localRatchetKey = "";
                    else {
                        object.localRatchetKey = [];
                        if (options.bytes !== Array)
                            object.localRatchetKey = $util.newBuffer(object.localRatchetKey);
                    }
                    if (options.bytes === String)
                        object.localRatchetKeyPrivate = "";
                    else {
                        object.localRatchetKeyPrivate = [];
                        if (options.bytes !== Array)
                            object.localRatchetKeyPrivate = $util.newBuffer(object.localRatchetKeyPrivate);
                    }
                    if (options.bytes === String)
                        object.localIdentityKey = "";
                    else {
                        object.localIdentityKey = [];
                        if (options.bytes !== Array)
                            object.localIdentityKey = $util.newBuffer(object.localIdentityKey);
                    }
                    if (options.bytes === String)
                        object.localIdentityKeyPrivate = "";
                    else {
                        object.localIdentityKeyPrivate = [];
                        if (options.bytes !== Array)
                            object.localIdentityKeyPrivate = $util.newBuffer(object.localIdentityKeyPrivate);
                    }
                }
                if (message.sequence != null && message.hasOwnProperty("sequence"))
                    object.sequence = message.sequence;
                if (message.localBaseKey != null && message.hasOwnProperty("localBaseKey"))
                    object.localBaseKey = options.bytes === String ? $util.base64.encode(message.localBaseKey, 0, message.localBaseKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.localBaseKey) : message.localBaseKey;
                if (message.localBaseKeyPrivate != null && message.hasOwnProperty("localBaseKeyPrivate"))
                    object.localBaseKeyPrivate = options.bytes === String ? $util.base64.encode(message.localBaseKeyPrivate, 0, message.localBaseKeyPrivate.length) : options.bytes === Array ? Array.prototype.slice.call(message.localBaseKeyPrivate) : message.localBaseKeyPrivate;
                if (message.localRatchetKey != null && message.hasOwnProperty("localRatchetKey"))
                    object.localRatchetKey = options.bytes === String ? $util.base64.encode(message.localRatchetKey, 0, message.localRatchetKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.localRatchetKey) : message.localRatchetKey;
                if (message.localRatchetKeyPrivate != null && message.hasOwnProperty("localRatchetKeyPrivate"))
                    object.localRatchetKeyPrivate = options.bytes === String ? $util.base64.encode(message.localRatchetKeyPrivate, 0, message.localRatchetKeyPrivate.length) : options.bytes === Array ? Array.prototype.slice.call(message.localRatchetKeyPrivate) : message.localRatchetKeyPrivate;
                if (message.localIdentityKey != null && message.hasOwnProperty("localIdentityKey"))
                    object.localIdentityKey = options.bytes === String ? $util.base64.encode(message.localIdentityKey, 0, message.localIdentityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.localIdentityKey) : message.localIdentityKey;
                if (message.localIdentityKeyPrivate != null && message.hasOwnProperty("localIdentityKeyPrivate"))
                    object.localIdentityKeyPrivate = options.bytes === String ? $util.base64.encode(message.localIdentityKeyPrivate, 0, message.localIdentityKeyPrivate.length) : options.bytes === Array ? Array.prototype.slice.call(message.localIdentityKeyPrivate) : message.localIdentityKeyPrivate;
                return object;
            };

            /**
             * Converts this PendingKeyExchange to JSON.
             * @function toJSON
             * @memberof SessionStructure.SessionStructure.PendingKeyExchange
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PendingKeyExchange.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PendingKeyExchange;
        })();

        SessionStructure.PendingPreKey = (function() {

            /**
             * Properties of a PendingPreKey.
             * @memberof SessionStructure.SessionStructure
             * @interface IPendingPreKey
             * @property {number|null} [preKeyId] PendingPreKey preKeyId
             * @property {number|null} [signedPreKeyId] PendingPreKey signedPreKeyId
             * @property {Uint8Array|null} [baseKey] PendingPreKey baseKey
             */

            /**
             * Constructs a new PendingPreKey.
             * @memberof SessionStructure.SessionStructure
             * @classdesc Represents a PendingPreKey.
             * @implements IPendingPreKey
             * @constructor
             * @param {SessionStructure.SessionStructure.IPendingPreKey=} [properties] Properties to set
             */
            function PendingPreKey(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PendingPreKey preKeyId.
             * @member {number} preKeyId
             * @memberof SessionStructure.SessionStructure.PendingPreKey
             * @instance
             */
            PendingPreKey.prototype.preKeyId = 0;

            /**
             * PendingPreKey signedPreKeyId.
             * @member {number} signedPreKeyId
             * @memberof SessionStructure.SessionStructure.PendingPreKey
             * @instance
             */
            PendingPreKey.prototype.signedPreKeyId = 0;

            /**
             * PendingPreKey baseKey.
             * @member {Uint8Array} baseKey
             * @memberof SessionStructure.SessionStructure.PendingPreKey
             * @instance
             */
            PendingPreKey.prototype.baseKey = $util.newBuffer([]);

            /**
             * Creates a new PendingPreKey instance using the specified properties.
             * @function create
             * @memberof SessionStructure.SessionStructure.PendingPreKey
             * @static
             * @param {SessionStructure.SessionStructure.IPendingPreKey=} [properties] Properties to set
             * @returns {SessionStructure.SessionStructure.PendingPreKey} PendingPreKey instance
             */
            PendingPreKey.create = function create(properties) {
                return new PendingPreKey(properties);
            };

            /**
             * Encodes the specified PendingPreKey message. Does not implicitly {@link SessionStructure.SessionStructure.PendingPreKey.verify|verify} messages.
             * @function encode
             * @memberof SessionStructure.SessionStructure.PendingPreKey
             * @static
             * @param {SessionStructure.SessionStructure.IPendingPreKey} message PendingPreKey message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PendingPreKey.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.preKeyId != null && Object.hasOwnProperty.call(message, "preKeyId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.preKeyId);
                if (message.baseKey != null && Object.hasOwnProperty.call(message, "baseKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.baseKey);
                if (message.signedPreKeyId != null && Object.hasOwnProperty.call(message, "signedPreKeyId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.signedPreKeyId);
                return writer;
            };

            /**
             * Encodes the specified PendingPreKey message, length delimited. Does not implicitly {@link SessionStructure.SessionStructure.PendingPreKey.verify|verify} messages.
             * @function encodeDelimited
             * @memberof SessionStructure.SessionStructure.PendingPreKey
             * @static
             * @param {SessionStructure.SessionStructure.IPendingPreKey} message PendingPreKey message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PendingPreKey.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PendingPreKey message from the specified reader or buffer.
             * @function decode
             * @memberof SessionStructure.SessionStructure.PendingPreKey
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {SessionStructure.SessionStructure.PendingPreKey} PendingPreKey
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PendingPreKey.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionStructure.SessionStructure.PendingPreKey();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.preKeyId = reader.uint32();
                        break;
                    case 3:
                        message.signedPreKeyId = reader.int32();
                        break;
                    case 2:
                        message.baseKey = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PendingPreKey message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof SessionStructure.SessionStructure.PendingPreKey
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {SessionStructure.SessionStructure.PendingPreKey} PendingPreKey
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PendingPreKey.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PendingPreKey message.
             * @function verify
             * @memberof SessionStructure.SessionStructure.PendingPreKey
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PendingPreKey.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.preKeyId != null && message.hasOwnProperty("preKeyId"))
                    if (!$util.isInteger(message.preKeyId))
                        return "preKeyId: integer expected";
                if (message.signedPreKeyId != null && message.hasOwnProperty("signedPreKeyId"))
                    if (!$util.isInteger(message.signedPreKeyId))
                        return "signedPreKeyId: integer expected";
                if (message.baseKey != null && message.hasOwnProperty("baseKey"))
                    if (!(message.baseKey && typeof message.baseKey.length === "number" || $util.isString(message.baseKey)))
                        return "baseKey: buffer expected";
                return null;
            };

            /**
             * Creates a PendingPreKey message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof SessionStructure.SessionStructure.PendingPreKey
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {SessionStructure.SessionStructure.PendingPreKey} PendingPreKey
             */
            PendingPreKey.fromObject = function fromObject(object) {
                if (object instanceof $root.SessionStructure.SessionStructure.PendingPreKey)
                    return object;
                var message = new $root.SessionStructure.SessionStructure.PendingPreKey();
                if (object.preKeyId != null)
                    message.preKeyId = object.preKeyId >>> 0;
                if (object.signedPreKeyId != null)
                    message.signedPreKeyId = object.signedPreKeyId | 0;
                if (object.baseKey != null)
                    if (typeof object.baseKey === "string")
                        $util.base64.decode(object.baseKey, message.baseKey = $util.newBuffer($util.base64.length(object.baseKey)), 0);
                    else if (object.baseKey.length)
                        message.baseKey = object.baseKey;
                return message;
            };

            /**
             * Creates a plain object from a PendingPreKey message. Also converts values to other types if specified.
             * @function toObject
             * @memberof SessionStructure.SessionStructure.PendingPreKey
             * @static
             * @param {SessionStructure.SessionStructure.PendingPreKey} message PendingPreKey
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PendingPreKey.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.preKeyId = 0;
                    if (options.bytes === String)
                        object.baseKey = "";
                    else {
                        object.baseKey = [];
                        if (options.bytes !== Array)
                            object.baseKey = $util.newBuffer(object.baseKey);
                    }
                    object.signedPreKeyId = 0;
                }
                if (message.preKeyId != null && message.hasOwnProperty("preKeyId"))
                    object.preKeyId = message.preKeyId;
                if (message.baseKey != null && message.hasOwnProperty("baseKey"))
                    object.baseKey = options.bytes === String ? $util.base64.encode(message.baseKey, 0, message.baseKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.baseKey) : message.baseKey;
                if (message.signedPreKeyId != null && message.hasOwnProperty("signedPreKeyId"))
                    object.signedPreKeyId = message.signedPreKeyId;
                return object;
            };

            /**
             * Converts this PendingPreKey to JSON.
             * @function toJSON
             * @memberof SessionStructure.SessionStructure.PendingPreKey
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PendingPreKey.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PendingPreKey;
        })();

        return SessionStructure;
    })();

    SessionStructure.RecordStructure = (function() {

        /**
         * Properties of a RecordStructure.
         * @memberof SessionStructure
         * @interface IRecordStructure
         * @property {SessionStructure.ISessionStructure|null} [currentSession] RecordStructure currentSession
         * @property {Array.<SessionStructure.ISessionStructure>|null} [previousSessions] RecordStructure previousSessions
         */

        /**
         * Constructs a new RecordStructure.
         * @memberof SessionStructure
         * @classdesc Represents a RecordStructure.
         * @implements IRecordStructure
         * @constructor
         * @param {SessionStructure.IRecordStructure=} [properties] Properties to set
         */
        function RecordStructure(properties) {
            this.previousSessions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecordStructure currentSession.
         * @member {SessionStructure.ISessionStructure|null|undefined} currentSession
         * @memberof SessionStructure.RecordStructure
         * @instance
         */
        RecordStructure.prototype.currentSession = null;

        /**
         * RecordStructure previousSessions.
         * @member {Array.<SessionStructure.ISessionStructure>} previousSessions
         * @memberof SessionStructure.RecordStructure
         * @instance
         */
        RecordStructure.prototype.previousSessions = $util.emptyArray;

        /**
         * Creates a new RecordStructure instance using the specified properties.
         * @function create
         * @memberof SessionStructure.RecordStructure
         * @static
         * @param {SessionStructure.IRecordStructure=} [properties] Properties to set
         * @returns {SessionStructure.RecordStructure} RecordStructure instance
         */
        RecordStructure.create = function create(properties) {
            return new RecordStructure(properties);
        };

        /**
         * Encodes the specified RecordStructure message. Does not implicitly {@link SessionStructure.RecordStructure.verify|verify} messages.
         * @function encode
         * @memberof SessionStructure.RecordStructure
         * @static
         * @param {SessionStructure.IRecordStructure} message RecordStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordStructure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentSession != null && Object.hasOwnProperty.call(message, "currentSession"))
                $root.SessionStructure.SessionStructure.encode(message.currentSession, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.previousSessions != null && message.previousSessions.length)
                for (var i = 0; i < message.previousSessions.length; ++i)
                    $root.SessionStructure.SessionStructure.encode(message.previousSessions[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RecordStructure message, length delimited. Does not implicitly {@link SessionStructure.RecordStructure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SessionStructure.RecordStructure
         * @static
         * @param {SessionStructure.IRecordStructure} message RecordStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordStructure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecordStructure message from the specified reader or buffer.
         * @function decode
         * @memberof SessionStructure.RecordStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SessionStructure.RecordStructure} RecordStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordStructure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionStructure.RecordStructure();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.currentSession = $root.SessionStructure.SessionStructure.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.previousSessions && message.previousSessions.length))
                        message.previousSessions = [];
                    message.previousSessions.push($root.SessionStructure.SessionStructure.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecordStructure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SessionStructure.RecordStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SessionStructure.RecordStructure} RecordStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordStructure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecordStructure message.
         * @function verify
         * @memberof SessionStructure.RecordStructure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecordStructure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentSession != null && message.hasOwnProperty("currentSession")) {
                var error = $root.SessionStructure.SessionStructure.verify(message.currentSession);
                if (error)
                    return "currentSession." + error;
            }
            if (message.previousSessions != null && message.hasOwnProperty("previousSessions")) {
                if (!Array.isArray(message.previousSessions))
                    return "previousSessions: array expected";
                for (var i = 0; i < message.previousSessions.length; ++i) {
                    var error = $root.SessionStructure.SessionStructure.verify(message.previousSessions[i]);
                    if (error)
                        return "previousSessions." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RecordStructure message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SessionStructure.RecordStructure
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SessionStructure.RecordStructure} RecordStructure
         */
        RecordStructure.fromObject = function fromObject(object) {
            if (object instanceof $root.SessionStructure.RecordStructure)
                return object;
            var message = new $root.SessionStructure.RecordStructure();
            if (object.currentSession != null) {
                if (typeof object.currentSession !== "object")
                    throw TypeError(".SessionStructure.RecordStructure.currentSession: object expected");
                message.currentSession = $root.SessionStructure.SessionStructure.fromObject(object.currentSession);
            }
            if (object.previousSessions) {
                if (!Array.isArray(object.previousSessions))
                    throw TypeError(".SessionStructure.RecordStructure.previousSessions: array expected");
                message.previousSessions = [];
                for (var i = 0; i < object.previousSessions.length; ++i) {
                    if (typeof object.previousSessions[i] !== "object")
                        throw TypeError(".SessionStructure.RecordStructure.previousSessions: object expected");
                    message.previousSessions[i] = $root.SessionStructure.SessionStructure.fromObject(object.previousSessions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RecordStructure message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SessionStructure.RecordStructure
         * @static
         * @param {SessionStructure.RecordStructure} message RecordStructure
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecordStructure.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.previousSessions = [];
            if (options.defaults)
                object.currentSession = null;
            if (message.currentSession != null && message.hasOwnProperty("currentSession"))
                object.currentSession = $root.SessionStructure.SessionStructure.toObject(message.currentSession, options);
            if (message.previousSessions && message.previousSessions.length) {
                object.previousSessions = [];
                for (var j = 0; j < message.previousSessions.length; ++j)
                    object.previousSessions[j] = $root.SessionStructure.SessionStructure.toObject(message.previousSessions[j], options);
            }
            return object;
        };

        /**
         * Converts this RecordStructure to JSON.
         * @function toJSON
         * @memberof SessionStructure.RecordStructure
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecordStructure.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RecordStructure;
    })();

    SessionStructure.PreKeyRecordStructure = (function() {

        /**
         * Properties of a PreKeyRecordStructure.
         * @memberof SessionStructure
         * @interface IPreKeyRecordStructure
         * @property {number|null} [id] PreKeyRecordStructure id
         * @property {Uint8Array|null} [publicKey] PreKeyRecordStructure publicKey
         * @property {Uint8Array|null} [privateKey] PreKeyRecordStructure privateKey
         */

        /**
         * Constructs a new PreKeyRecordStructure.
         * @memberof SessionStructure
         * @classdesc Represents a PreKeyRecordStructure.
         * @implements IPreKeyRecordStructure
         * @constructor
         * @param {SessionStructure.IPreKeyRecordStructure=} [properties] Properties to set
         */
        function PreKeyRecordStructure(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PreKeyRecordStructure id.
         * @member {number} id
         * @memberof SessionStructure.PreKeyRecordStructure
         * @instance
         */
        PreKeyRecordStructure.prototype.id = 0;

        /**
         * PreKeyRecordStructure publicKey.
         * @member {Uint8Array} publicKey
         * @memberof SessionStructure.PreKeyRecordStructure
         * @instance
         */
        PreKeyRecordStructure.prototype.publicKey = $util.newBuffer([]);

        /**
         * PreKeyRecordStructure privateKey.
         * @member {Uint8Array} privateKey
         * @memberof SessionStructure.PreKeyRecordStructure
         * @instance
         */
        PreKeyRecordStructure.prototype.privateKey = $util.newBuffer([]);

        /**
         * Creates a new PreKeyRecordStructure instance using the specified properties.
         * @function create
         * @memberof SessionStructure.PreKeyRecordStructure
         * @static
         * @param {SessionStructure.IPreKeyRecordStructure=} [properties] Properties to set
         * @returns {SessionStructure.PreKeyRecordStructure} PreKeyRecordStructure instance
         */
        PreKeyRecordStructure.create = function create(properties) {
            return new PreKeyRecordStructure(properties);
        };

        /**
         * Encodes the specified PreKeyRecordStructure message. Does not implicitly {@link SessionStructure.PreKeyRecordStructure.verify|verify} messages.
         * @function encode
         * @memberof SessionStructure.PreKeyRecordStructure
         * @static
         * @param {SessionStructure.IPreKeyRecordStructure} message PreKeyRecordStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreKeyRecordStructure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicKey);
            if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.privateKey);
            return writer;
        };

        /**
         * Encodes the specified PreKeyRecordStructure message, length delimited. Does not implicitly {@link SessionStructure.PreKeyRecordStructure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SessionStructure.PreKeyRecordStructure
         * @static
         * @param {SessionStructure.IPreKeyRecordStructure} message PreKeyRecordStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreKeyRecordStructure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PreKeyRecordStructure message from the specified reader or buffer.
         * @function decode
         * @memberof SessionStructure.PreKeyRecordStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SessionStructure.PreKeyRecordStructure} PreKeyRecordStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreKeyRecordStructure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionStructure.PreKeyRecordStructure();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint32();
                    break;
                case 2:
                    message.publicKey = reader.bytes();
                    break;
                case 3:
                    message.privateKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PreKeyRecordStructure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SessionStructure.PreKeyRecordStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SessionStructure.PreKeyRecordStructure} PreKeyRecordStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreKeyRecordStructure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PreKeyRecordStructure message.
         * @function verify
         * @memberof SessionStructure.PreKeyRecordStructure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PreKeyRecordStructure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                    return "privateKey: buffer expected";
            return null;
        };

        /**
         * Creates a PreKeyRecordStructure message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SessionStructure.PreKeyRecordStructure
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SessionStructure.PreKeyRecordStructure} PreKeyRecordStructure
         */
        PreKeyRecordStructure.fromObject = function fromObject(object) {
            if (object instanceof $root.SessionStructure.PreKeyRecordStructure)
                return object;
            var message = new $root.SessionStructure.PreKeyRecordStructure();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.privateKey != null)
                if (typeof object.privateKey === "string")
                    $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                else if (object.privateKey.length)
                    message.privateKey = object.privateKey;
            return message;
        };

        /**
         * Creates a plain object from a PreKeyRecordStructure message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SessionStructure.PreKeyRecordStructure
         * @static
         * @param {SessionStructure.PreKeyRecordStructure} message PreKeyRecordStructure
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PreKeyRecordStructure.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.privateKey = "";
                else {
                    object.privateKey = [];
                    if (options.bytes !== Array)
                        object.privateKey = $util.newBuffer(object.privateKey);
                }
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
            return object;
        };

        /**
         * Converts this PreKeyRecordStructure to JSON.
         * @function toJSON
         * @memberof SessionStructure.PreKeyRecordStructure
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PreKeyRecordStructure.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PreKeyRecordStructure;
    })();

    SessionStructure.SignedPreKeyRecordStructure = (function() {

        /**
         * Properties of a SignedPreKeyRecordStructure.
         * @memberof SessionStructure
         * @interface ISignedPreKeyRecordStructure
         * @property {number|null} [id] SignedPreKeyRecordStructure id
         * @property {Uint8Array|null} [publicKey] SignedPreKeyRecordStructure publicKey
         * @property {Uint8Array|null} [privateKey] SignedPreKeyRecordStructure privateKey
         * @property {Uint8Array|null} [signature] SignedPreKeyRecordStructure signature
         * @property {number|Long|null} [timestamp] SignedPreKeyRecordStructure timestamp
         */

        /**
         * Constructs a new SignedPreKeyRecordStructure.
         * @memberof SessionStructure
         * @classdesc Represents a SignedPreKeyRecordStructure.
         * @implements ISignedPreKeyRecordStructure
         * @constructor
         * @param {SessionStructure.ISignedPreKeyRecordStructure=} [properties] Properties to set
         */
        function SignedPreKeyRecordStructure(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignedPreKeyRecordStructure id.
         * @member {number} id
         * @memberof SessionStructure.SignedPreKeyRecordStructure
         * @instance
         */
        SignedPreKeyRecordStructure.prototype.id = 0;

        /**
         * SignedPreKeyRecordStructure publicKey.
         * @member {Uint8Array} publicKey
         * @memberof SessionStructure.SignedPreKeyRecordStructure
         * @instance
         */
        SignedPreKeyRecordStructure.prototype.publicKey = $util.newBuffer([]);

        /**
         * SignedPreKeyRecordStructure privateKey.
         * @member {Uint8Array} privateKey
         * @memberof SessionStructure.SignedPreKeyRecordStructure
         * @instance
         */
        SignedPreKeyRecordStructure.prototype.privateKey = $util.newBuffer([]);

        /**
         * SignedPreKeyRecordStructure signature.
         * @member {Uint8Array} signature
         * @memberof SessionStructure.SignedPreKeyRecordStructure
         * @instance
         */
        SignedPreKeyRecordStructure.prototype.signature = $util.newBuffer([]);

        /**
         * SignedPreKeyRecordStructure timestamp.
         * @member {number|Long} timestamp
         * @memberof SessionStructure.SignedPreKeyRecordStructure
         * @instance
         */
        SignedPreKeyRecordStructure.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new SignedPreKeyRecordStructure instance using the specified properties.
         * @function create
         * @memberof SessionStructure.SignedPreKeyRecordStructure
         * @static
         * @param {SessionStructure.ISignedPreKeyRecordStructure=} [properties] Properties to set
         * @returns {SessionStructure.SignedPreKeyRecordStructure} SignedPreKeyRecordStructure instance
         */
        SignedPreKeyRecordStructure.create = function create(properties) {
            return new SignedPreKeyRecordStructure(properties);
        };

        /**
         * Encodes the specified SignedPreKeyRecordStructure message. Does not implicitly {@link SessionStructure.SignedPreKeyRecordStructure.verify|verify} messages.
         * @function encode
         * @memberof SessionStructure.SignedPreKeyRecordStructure
         * @static
         * @param {SessionStructure.ISignedPreKeyRecordStructure} message SignedPreKeyRecordStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignedPreKeyRecordStructure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicKey);
            if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.privateKey);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signature);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 5, wireType 1 =*/41).fixed64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified SignedPreKeyRecordStructure message, length delimited. Does not implicitly {@link SessionStructure.SignedPreKeyRecordStructure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SessionStructure.SignedPreKeyRecordStructure
         * @static
         * @param {SessionStructure.ISignedPreKeyRecordStructure} message SignedPreKeyRecordStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignedPreKeyRecordStructure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SignedPreKeyRecordStructure message from the specified reader or buffer.
         * @function decode
         * @memberof SessionStructure.SignedPreKeyRecordStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SessionStructure.SignedPreKeyRecordStructure} SignedPreKeyRecordStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignedPreKeyRecordStructure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionStructure.SignedPreKeyRecordStructure();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint32();
                    break;
                case 2:
                    message.publicKey = reader.bytes();
                    break;
                case 3:
                    message.privateKey = reader.bytes();
                    break;
                case 4:
                    message.signature = reader.bytes();
                    break;
                case 5:
                    message.timestamp = reader.fixed64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SignedPreKeyRecordStructure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SessionStructure.SignedPreKeyRecordStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SessionStructure.SignedPreKeyRecordStructure} SignedPreKeyRecordStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignedPreKeyRecordStructure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SignedPreKeyRecordStructure message.
         * @function verify
         * @memberof SessionStructure.SignedPreKeyRecordStructure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SignedPreKeyRecordStructure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                    return "privateKey: buffer expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a SignedPreKeyRecordStructure message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SessionStructure.SignedPreKeyRecordStructure
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SessionStructure.SignedPreKeyRecordStructure} SignedPreKeyRecordStructure
         */
        SignedPreKeyRecordStructure.fromObject = function fromObject(object) {
            if (object instanceof $root.SessionStructure.SignedPreKeyRecordStructure)
                return object;
            var message = new $root.SessionStructure.SignedPreKeyRecordStructure();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.privateKey != null)
                if (typeof object.privateKey === "string")
                    $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                else if (object.privateKey.length)
                    message.privateKey = object.privateKey;
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a SignedPreKeyRecordStructure message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SessionStructure.SignedPreKeyRecordStructure
         * @static
         * @param {SessionStructure.SignedPreKeyRecordStructure} message SignedPreKeyRecordStructure
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SignedPreKeyRecordStructure.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.privateKey = "";
                else {
                    object.privateKey = [];
                    if (options.bytes !== Array)
                        object.privateKey = $util.newBuffer(object.privateKey);
                }
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this SignedPreKeyRecordStructure to JSON.
         * @function toJSON
         * @memberof SessionStructure.SignedPreKeyRecordStructure
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SignedPreKeyRecordStructure.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SignedPreKeyRecordStructure;
    })();

    SessionStructure.IdentityKeyPairStructure = (function() {

        /**
         * Properties of an IdentityKeyPairStructure.
         * @memberof SessionStructure
         * @interface IIdentityKeyPairStructure
         * @property {Uint8Array|null} [publicKey] IdentityKeyPairStructure publicKey
         * @property {Uint8Array|null} [privateKey] IdentityKeyPairStructure privateKey
         */

        /**
         * Constructs a new IdentityKeyPairStructure.
         * @memberof SessionStructure
         * @classdesc Represents an IdentityKeyPairStructure.
         * @implements IIdentityKeyPairStructure
         * @constructor
         * @param {SessionStructure.IIdentityKeyPairStructure=} [properties] Properties to set
         */
        function IdentityKeyPairStructure(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdentityKeyPairStructure publicKey.
         * @member {Uint8Array} publicKey
         * @memberof SessionStructure.IdentityKeyPairStructure
         * @instance
         */
        IdentityKeyPairStructure.prototype.publicKey = $util.newBuffer([]);

        /**
         * IdentityKeyPairStructure privateKey.
         * @member {Uint8Array} privateKey
         * @memberof SessionStructure.IdentityKeyPairStructure
         * @instance
         */
        IdentityKeyPairStructure.prototype.privateKey = $util.newBuffer([]);

        /**
         * Creates a new IdentityKeyPairStructure instance using the specified properties.
         * @function create
         * @memberof SessionStructure.IdentityKeyPairStructure
         * @static
         * @param {SessionStructure.IIdentityKeyPairStructure=} [properties] Properties to set
         * @returns {SessionStructure.IdentityKeyPairStructure} IdentityKeyPairStructure instance
         */
        IdentityKeyPairStructure.create = function create(properties) {
            return new IdentityKeyPairStructure(properties);
        };

        /**
         * Encodes the specified IdentityKeyPairStructure message. Does not implicitly {@link SessionStructure.IdentityKeyPairStructure.verify|verify} messages.
         * @function encode
         * @memberof SessionStructure.IdentityKeyPairStructure
         * @static
         * @param {SessionStructure.IIdentityKeyPairStructure} message IdentityKeyPairStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityKeyPairStructure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
            if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.privateKey);
            return writer;
        };

        /**
         * Encodes the specified IdentityKeyPairStructure message, length delimited. Does not implicitly {@link SessionStructure.IdentityKeyPairStructure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SessionStructure.IdentityKeyPairStructure
         * @static
         * @param {SessionStructure.IIdentityKeyPairStructure} message IdentityKeyPairStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentityKeyPairStructure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdentityKeyPairStructure message from the specified reader or buffer.
         * @function decode
         * @memberof SessionStructure.IdentityKeyPairStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SessionStructure.IdentityKeyPairStructure} IdentityKeyPairStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityKeyPairStructure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionStructure.IdentityKeyPairStructure();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.publicKey = reader.bytes();
                    break;
                case 2:
                    message.privateKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdentityKeyPairStructure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SessionStructure.IdentityKeyPairStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SessionStructure.IdentityKeyPairStructure} IdentityKeyPairStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentityKeyPairStructure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdentityKeyPairStructure message.
         * @function verify
         * @memberof SessionStructure.IdentityKeyPairStructure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentityKeyPairStructure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                    return "privateKey: buffer expected";
            return null;
        };

        /**
         * Creates an IdentityKeyPairStructure message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SessionStructure.IdentityKeyPairStructure
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SessionStructure.IdentityKeyPairStructure} IdentityKeyPairStructure
         */
        IdentityKeyPairStructure.fromObject = function fromObject(object) {
            if (object instanceof $root.SessionStructure.IdentityKeyPairStructure)
                return object;
            var message = new $root.SessionStructure.IdentityKeyPairStructure();
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.privateKey != null)
                if (typeof object.privateKey === "string")
                    $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                else if (object.privateKey.length)
                    message.privateKey = object.privateKey;
            return message;
        };

        /**
         * Creates a plain object from an IdentityKeyPairStructure message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SessionStructure.IdentityKeyPairStructure
         * @static
         * @param {SessionStructure.IdentityKeyPairStructure} message IdentityKeyPairStructure
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentityKeyPairStructure.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.privateKey = "";
                else {
                    object.privateKey = [];
                    if (options.bytes !== Array)
                        object.privateKey = $util.newBuffer(object.privateKey);
                }
            }
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
            return object;
        };

        /**
         * Converts this IdentityKeyPairStructure to JSON.
         * @function toJSON
         * @memberof SessionStructure.IdentityKeyPairStructure
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentityKeyPairStructure.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdentityKeyPairStructure;
    })();

    SessionStructure.SenderKeyStateStructure = (function() {

        /**
         * Properties of a SenderKeyStateStructure.
         * @memberof SessionStructure
         * @interface ISenderKeyStateStructure
         * @property {number|null} [senderKeyId] SenderKeyStateStructure senderKeyId
         * @property {SessionStructure.SenderKeyStateStructure.ISenderChainKey|null} [senderChainKey] SenderKeyStateStructure senderChainKey
         * @property {SessionStructure.SenderKeyStateStructure.ISenderSigningKey|null} [senderSigningKey] SenderKeyStateStructure senderSigningKey
         * @property {Array.<SessionStructure.SenderKeyStateStructure.ISenderMessageKey>|null} [senderMessageKeys] SenderKeyStateStructure senderMessageKeys
         */

        /**
         * Constructs a new SenderKeyStateStructure.
         * @memberof SessionStructure
         * @classdesc Represents a SenderKeyStateStructure.
         * @implements ISenderKeyStateStructure
         * @constructor
         * @param {SessionStructure.ISenderKeyStateStructure=} [properties] Properties to set
         */
        function SenderKeyStateStructure(properties) {
            this.senderMessageKeys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SenderKeyStateStructure senderKeyId.
         * @member {number} senderKeyId
         * @memberof SessionStructure.SenderKeyStateStructure
         * @instance
         */
        SenderKeyStateStructure.prototype.senderKeyId = 0;

        /**
         * SenderKeyStateStructure senderChainKey.
         * @member {SessionStructure.SenderKeyStateStructure.ISenderChainKey|null|undefined} senderChainKey
         * @memberof SessionStructure.SenderKeyStateStructure
         * @instance
         */
        SenderKeyStateStructure.prototype.senderChainKey = null;

        /**
         * SenderKeyStateStructure senderSigningKey.
         * @member {SessionStructure.SenderKeyStateStructure.ISenderSigningKey|null|undefined} senderSigningKey
         * @memberof SessionStructure.SenderKeyStateStructure
         * @instance
         */
        SenderKeyStateStructure.prototype.senderSigningKey = null;

        /**
         * SenderKeyStateStructure senderMessageKeys.
         * @member {Array.<SessionStructure.SenderKeyStateStructure.ISenderMessageKey>} senderMessageKeys
         * @memberof SessionStructure.SenderKeyStateStructure
         * @instance
         */
        SenderKeyStateStructure.prototype.senderMessageKeys = $util.emptyArray;

        /**
         * Creates a new SenderKeyStateStructure instance using the specified properties.
         * @function create
         * @memberof SessionStructure.SenderKeyStateStructure
         * @static
         * @param {SessionStructure.ISenderKeyStateStructure=} [properties] Properties to set
         * @returns {SessionStructure.SenderKeyStateStructure} SenderKeyStateStructure instance
         */
        SenderKeyStateStructure.create = function create(properties) {
            return new SenderKeyStateStructure(properties);
        };

        /**
         * Encodes the specified SenderKeyStateStructure message. Does not implicitly {@link SessionStructure.SenderKeyStateStructure.verify|verify} messages.
         * @function encode
         * @memberof SessionStructure.SenderKeyStateStructure
         * @static
         * @param {SessionStructure.ISenderKeyStateStructure} message SenderKeyStateStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderKeyStateStructure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.senderKeyId != null && Object.hasOwnProperty.call(message, "senderKeyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.senderKeyId);
            if (message.senderChainKey != null && Object.hasOwnProperty.call(message, "senderChainKey"))
                $root.SessionStructure.SenderKeyStateStructure.SenderChainKey.encode(message.senderChainKey, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.senderSigningKey != null && Object.hasOwnProperty.call(message, "senderSigningKey"))
                $root.SessionStructure.SenderKeyStateStructure.SenderSigningKey.encode(message.senderSigningKey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.senderMessageKeys != null && message.senderMessageKeys.length)
                for (var i = 0; i < message.senderMessageKeys.length; ++i)
                    $root.SessionStructure.SenderKeyStateStructure.SenderMessageKey.encode(message.senderMessageKeys[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SenderKeyStateStructure message, length delimited. Does not implicitly {@link SessionStructure.SenderKeyStateStructure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SessionStructure.SenderKeyStateStructure
         * @static
         * @param {SessionStructure.ISenderKeyStateStructure} message SenderKeyStateStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderKeyStateStructure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SenderKeyStateStructure message from the specified reader or buffer.
         * @function decode
         * @memberof SessionStructure.SenderKeyStateStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SessionStructure.SenderKeyStateStructure} SenderKeyStateStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderKeyStateStructure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionStructure.SenderKeyStateStructure();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.senderKeyId = reader.uint32();
                    break;
                case 2:
                    message.senderChainKey = $root.SessionStructure.SenderKeyStateStructure.SenderChainKey.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.senderSigningKey = $root.SessionStructure.SenderKeyStateStructure.SenderSigningKey.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.senderMessageKeys && message.senderMessageKeys.length))
                        message.senderMessageKeys = [];
                    message.senderMessageKeys.push($root.SessionStructure.SenderKeyStateStructure.SenderMessageKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SenderKeyStateStructure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SessionStructure.SenderKeyStateStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SessionStructure.SenderKeyStateStructure} SenderKeyStateStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderKeyStateStructure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SenderKeyStateStructure message.
         * @function verify
         * @memberof SessionStructure.SenderKeyStateStructure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SenderKeyStateStructure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.senderKeyId != null && message.hasOwnProperty("senderKeyId"))
                if (!$util.isInteger(message.senderKeyId))
                    return "senderKeyId: integer expected";
            if (message.senderChainKey != null && message.hasOwnProperty("senderChainKey")) {
                var error = $root.SessionStructure.SenderKeyStateStructure.SenderChainKey.verify(message.senderChainKey);
                if (error)
                    return "senderChainKey." + error;
            }
            if (message.senderSigningKey != null && message.hasOwnProperty("senderSigningKey")) {
                var error = $root.SessionStructure.SenderKeyStateStructure.SenderSigningKey.verify(message.senderSigningKey);
                if (error)
                    return "senderSigningKey." + error;
            }
            if (message.senderMessageKeys != null && message.hasOwnProperty("senderMessageKeys")) {
                if (!Array.isArray(message.senderMessageKeys))
                    return "senderMessageKeys: array expected";
                for (var i = 0; i < message.senderMessageKeys.length; ++i) {
                    var error = $root.SessionStructure.SenderKeyStateStructure.SenderMessageKey.verify(message.senderMessageKeys[i]);
                    if (error)
                        return "senderMessageKeys." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SenderKeyStateStructure message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SessionStructure.SenderKeyStateStructure
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SessionStructure.SenderKeyStateStructure} SenderKeyStateStructure
         */
        SenderKeyStateStructure.fromObject = function fromObject(object) {
            if (object instanceof $root.SessionStructure.SenderKeyStateStructure)
                return object;
            var message = new $root.SessionStructure.SenderKeyStateStructure();
            if (object.senderKeyId != null)
                message.senderKeyId = object.senderKeyId >>> 0;
            if (object.senderChainKey != null) {
                if (typeof object.senderChainKey !== "object")
                    throw TypeError(".SessionStructure.SenderKeyStateStructure.senderChainKey: object expected");
                message.senderChainKey = $root.SessionStructure.SenderKeyStateStructure.SenderChainKey.fromObject(object.senderChainKey);
            }
            if (object.senderSigningKey != null) {
                if (typeof object.senderSigningKey !== "object")
                    throw TypeError(".SessionStructure.SenderKeyStateStructure.senderSigningKey: object expected");
                message.senderSigningKey = $root.SessionStructure.SenderKeyStateStructure.SenderSigningKey.fromObject(object.senderSigningKey);
            }
            if (object.senderMessageKeys) {
                if (!Array.isArray(object.senderMessageKeys))
                    throw TypeError(".SessionStructure.SenderKeyStateStructure.senderMessageKeys: array expected");
                message.senderMessageKeys = [];
                for (var i = 0; i < object.senderMessageKeys.length; ++i) {
                    if (typeof object.senderMessageKeys[i] !== "object")
                        throw TypeError(".SessionStructure.SenderKeyStateStructure.senderMessageKeys: object expected");
                    message.senderMessageKeys[i] = $root.SessionStructure.SenderKeyStateStructure.SenderMessageKey.fromObject(object.senderMessageKeys[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SenderKeyStateStructure message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SessionStructure.SenderKeyStateStructure
         * @static
         * @param {SessionStructure.SenderKeyStateStructure} message SenderKeyStateStructure
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SenderKeyStateStructure.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.senderMessageKeys = [];
            if (options.defaults) {
                object.senderKeyId = 0;
                object.senderChainKey = null;
                object.senderSigningKey = null;
            }
            if (message.senderKeyId != null && message.hasOwnProperty("senderKeyId"))
                object.senderKeyId = message.senderKeyId;
            if (message.senderChainKey != null && message.hasOwnProperty("senderChainKey"))
                object.senderChainKey = $root.SessionStructure.SenderKeyStateStructure.SenderChainKey.toObject(message.senderChainKey, options);
            if (message.senderSigningKey != null && message.hasOwnProperty("senderSigningKey"))
                object.senderSigningKey = $root.SessionStructure.SenderKeyStateStructure.SenderSigningKey.toObject(message.senderSigningKey, options);
            if (message.senderMessageKeys && message.senderMessageKeys.length) {
                object.senderMessageKeys = [];
                for (var j = 0; j < message.senderMessageKeys.length; ++j)
                    object.senderMessageKeys[j] = $root.SessionStructure.SenderKeyStateStructure.SenderMessageKey.toObject(message.senderMessageKeys[j], options);
            }
            return object;
        };

        /**
         * Converts this SenderKeyStateStructure to JSON.
         * @function toJSON
         * @memberof SessionStructure.SenderKeyStateStructure
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SenderKeyStateStructure.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        SenderKeyStateStructure.SenderChainKey = (function() {

            /**
             * Properties of a SenderChainKey.
             * @memberof SessionStructure.SenderKeyStateStructure
             * @interface ISenderChainKey
             * @property {number|null} [iteration] SenderChainKey iteration
             * @property {Uint8Array|null} [seed] SenderChainKey seed
             */

            /**
             * Constructs a new SenderChainKey.
             * @memberof SessionStructure.SenderKeyStateStructure
             * @classdesc Represents a SenderChainKey.
             * @implements ISenderChainKey
             * @constructor
             * @param {SessionStructure.SenderKeyStateStructure.ISenderChainKey=} [properties] Properties to set
             */
            function SenderChainKey(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SenderChainKey iteration.
             * @member {number} iteration
             * @memberof SessionStructure.SenderKeyStateStructure.SenderChainKey
             * @instance
             */
            SenderChainKey.prototype.iteration = 0;

            /**
             * SenderChainKey seed.
             * @member {Uint8Array} seed
             * @memberof SessionStructure.SenderKeyStateStructure.SenderChainKey
             * @instance
             */
            SenderChainKey.prototype.seed = $util.newBuffer([]);

            /**
             * Creates a new SenderChainKey instance using the specified properties.
             * @function create
             * @memberof SessionStructure.SenderKeyStateStructure.SenderChainKey
             * @static
             * @param {SessionStructure.SenderKeyStateStructure.ISenderChainKey=} [properties] Properties to set
             * @returns {SessionStructure.SenderKeyStateStructure.SenderChainKey} SenderChainKey instance
             */
            SenderChainKey.create = function create(properties) {
                return new SenderChainKey(properties);
            };

            /**
             * Encodes the specified SenderChainKey message. Does not implicitly {@link SessionStructure.SenderKeyStateStructure.SenderChainKey.verify|verify} messages.
             * @function encode
             * @memberof SessionStructure.SenderKeyStateStructure.SenderChainKey
             * @static
             * @param {SessionStructure.SenderKeyStateStructure.ISenderChainKey} message SenderChainKey message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SenderChainKey.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.iteration != null && Object.hasOwnProperty.call(message, "iteration"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.iteration);
                if (message.seed != null && Object.hasOwnProperty.call(message, "seed"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.seed);
                return writer;
            };

            /**
             * Encodes the specified SenderChainKey message, length delimited. Does not implicitly {@link SessionStructure.SenderKeyStateStructure.SenderChainKey.verify|verify} messages.
             * @function encodeDelimited
             * @memberof SessionStructure.SenderKeyStateStructure.SenderChainKey
             * @static
             * @param {SessionStructure.SenderKeyStateStructure.ISenderChainKey} message SenderChainKey message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SenderChainKey.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SenderChainKey message from the specified reader or buffer.
             * @function decode
             * @memberof SessionStructure.SenderKeyStateStructure.SenderChainKey
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {SessionStructure.SenderKeyStateStructure.SenderChainKey} SenderChainKey
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SenderChainKey.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionStructure.SenderKeyStateStructure.SenderChainKey();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.iteration = reader.uint32();
                        break;
                    case 2:
                        message.seed = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SenderChainKey message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof SessionStructure.SenderKeyStateStructure.SenderChainKey
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {SessionStructure.SenderKeyStateStructure.SenderChainKey} SenderChainKey
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SenderChainKey.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SenderChainKey message.
             * @function verify
             * @memberof SessionStructure.SenderKeyStateStructure.SenderChainKey
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SenderChainKey.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.iteration != null && message.hasOwnProperty("iteration"))
                    if (!$util.isInteger(message.iteration))
                        return "iteration: integer expected";
                if (message.seed != null && message.hasOwnProperty("seed"))
                    if (!(message.seed && typeof message.seed.length === "number" || $util.isString(message.seed)))
                        return "seed: buffer expected";
                return null;
            };

            /**
             * Creates a SenderChainKey message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof SessionStructure.SenderKeyStateStructure.SenderChainKey
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {SessionStructure.SenderKeyStateStructure.SenderChainKey} SenderChainKey
             */
            SenderChainKey.fromObject = function fromObject(object) {
                if (object instanceof $root.SessionStructure.SenderKeyStateStructure.SenderChainKey)
                    return object;
                var message = new $root.SessionStructure.SenderKeyStateStructure.SenderChainKey();
                if (object.iteration != null)
                    message.iteration = object.iteration >>> 0;
                if (object.seed != null)
                    if (typeof object.seed === "string")
                        $util.base64.decode(object.seed, message.seed = $util.newBuffer($util.base64.length(object.seed)), 0);
                    else if (object.seed.length)
                        message.seed = object.seed;
                return message;
            };

            /**
             * Creates a plain object from a SenderChainKey message. Also converts values to other types if specified.
             * @function toObject
             * @memberof SessionStructure.SenderKeyStateStructure.SenderChainKey
             * @static
             * @param {SessionStructure.SenderKeyStateStructure.SenderChainKey} message SenderChainKey
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SenderChainKey.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.iteration = 0;
                    if (options.bytes === String)
                        object.seed = "";
                    else {
                        object.seed = [];
                        if (options.bytes !== Array)
                            object.seed = $util.newBuffer(object.seed);
                    }
                }
                if (message.iteration != null && message.hasOwnProperty("iteration"))
                    object.iteration = message.iteration;
                if (message.seed != null && message.hasOwnProperty("seed"))
                    object.seed = options.bytes === String ? $util.base64.encode(message.seed, 0, message.seed.length) : options.bytes === Array ? Array.prototype.slice.call(message.seed) : message.seed;
                return object;
            };

            /**
             * Converts this SenderChainKey to JSON.
             * @function toJSON
             * @memberof SessionStructure.SenderKeyStateStructure.SenderChainKey
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SenderChainKey.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SenderChainKey;
        })();

        SenderKeyStateStructure.SenderMessageKey = (function() {

            /**
             * Properties of a SenderMessageKey.
             * @memberof SessionStructure.SenderKeyStateStructure
             * @interface ISenderMessageKey
             * @property {number|null} [iteration] SenderMessageKey iteration
             * @property {Uint8Array|null} [seed] SenderMessageKey seed
             */

            /**
             * Constructs a new SenderMessageKey.
             * @memberof SessionStructure.SenderKeyStateStructure
             * @classdesc Represents a SenderMessageKey.
             * @implements ISenderMessageKey
             * @constructor
             * @param {SessionStructure.SenderKeyStateStructure.ISenderMessageKey=} [properties] Properties to set
             */
            function SenderMessageKey(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SenderMessageKey iteration.
             * @member {number} iteration
             * @memberof SessionStructure.SenderKeyStateStructure.SenderMessageKey
             * @instance
             */
            SenderMessageKey.prototype.iteration = 0;

            /**
             * SenderMessageKey seed.
             * @member {Uint8Array} seed
             * @memberof SessionStructure.SenderKeyStateStructure.SenderMessageKey
             * @instance
             */
            SenderMessageKey.prototype.seed = $util.newBuffer([]);

            /**
             * Creates a new SenderMessageKey instance using the specified properties.
             * @function create
             * @memberof SessionStructure.SenderKeyStateStructure.SenderMessageKey
             * @static
             * @param {SessionStructure.SenderKeyStateStructure.ISenderMessageKey=} [properties] Properties to set
             * @returns {SessionStructure.SenderKeyStateStructure.SenderMessageKey} SenderMessageKey instance
             */
            SenderMessageKey.create = function create(properties) {
                return new SenderMessageKey(properties);
            };

            /**
             * Encodes the specified SenderMessageKey message. Does not implicitly {@link SessionStructure.SenderKeyStateStructure.SenderMessageKey.verify|verify} messages.
             * @function encode
             * @memberof SessionStructure.SenderKeyStateStructure.SenderMessageKey
             * @static
             * @param {SessionStructure.SenderKeyStateStructure.ISenderMessageKey} message SenderMessageKey message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SenderMessageKey.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.iteration != null && Object.hasOwnProperty.call(message, "iteration"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.iteration);
                if (message.seed != null && Object.hasOwnProperty.call(message, "seed"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.seed);
                return writer;
            };

            /**
             * Encodes the specified SenderMessageKey message, length delimited. Does not implicitly {@link SessionStructure.SenderKeyStateStructure.SenderMessageKey.verify|verify} messages.
             * @function encodeDelimited
             * @memberof SessionStructure.SenderKeyStateStructure.SenderMessageKey
             * @static
             * @param {SessionStructure.SenderKeyStateStructure.ISenderMessageKey} message SenderMessageKey message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SenderMessageKey.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SenderMessageKey message from the specified reader or buffer.
             * @function decode
             * @memberof SessionStructure.SenderKeyStateStructure.SenderMessageKey
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {SessionStructure.SenderKeyStateStructure.SenderMessageKey} SenderMessageKey
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SenderMessageKey.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionStructure.SenderKeyStateStructure.SenderMessageKey();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.iteration = reader.uint32();
                        break;
                    case 2:
                        message.seed = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SenderMessageKey message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof SessionStructure.SenderKeyStateStructure.SenderMessageKey
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {SessionStructure.SenderKeyStateStructure.SenderMessageKey} SenderMessageKey
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SenderMessageKey.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SenderMessageKey message.
             * @function verify
             * @memberof SessionStructure.SenderKeyStateStructure.SenderMessageKey
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SenderMessageKey.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.iteration != null && message.hasOwnProperty("iteration"))
                    if (!$util.isInteger(message.iteration))
                        return "iteration: integer expected";
                if (message.seed != null && message.hasOwnProperty("seed"))
                    if (!(message.seed && typeof message.seed.length === "number" || $util.isString(message.seed)))
                        return "seed: buffer expected";
                return null;
            };

            /**
             * Creates a SenderMessageKey message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof SessionStructure.SenderKeyStateStructure.SenderMessageKey
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {SessionStructure.SenderKeyStateStructure.SenderMessageKey} SenderMessageKey
             */
            SenderMessageKey.fromObject = function fromObject(object) {
                if (object instanceof $root.SessionStructure.SenderKeyStateStructure.SenderMessageKey)
                    return object;
                var message = new $root.SessionStructure.SenderKeyStateStructure.SenderMessageKey();
                if (object.iteration != null)
                    message.iteration = object.iteration >>> 0;
                if (object.seed != null)
                    if (typeof object.seed === "string")
                        $util.base64.decode(object.seed, message.seed = $util.newBuffer($util.base64.length(object.seed)), 0);
                    else if (object.seed.length)
                        message.seed = object.seed;
                return message;
            };

            /**
             * Creates a plain object from a SenderMessageKey message. Also converts values to other types if specified.
             * @function toObject
             * @memberof SessionStructure.SenderKeyStateStructure.SenderMessageKey
             * @static
             * @param {SessionStructure.SenderKeyStateStructure.SenderMessageKey} message SenderMessageKey
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SenderMessageKey.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.iteration = 0;
                    if (options.bytes === String)
                        object.seed = "";
                    else {
                        object.seed = [];
                        if (options.bytes !== Array)
                            object.seed = $util.newBuffer(object.seed);
                    }
                }
                if (message.iteration != null && message.hasOwnProperty("iteration"))
                    object.iteration = message.iteration;
                if (message.seed != null && message.hasOwnProperty("seed"))
                    object.seed = options.bytes === String ? $util.base64.encode(message.seed, 0, message.seed.length) : options.bytes === Array ? Array.prototype.slice.call(message.seed) : message.seed;
                return object;
            };

            /**
             * Converts this SenderMessageKey to JSON.
             * @function toJSON
             * @memberof SessionStructure.SenderKeyStateStructure.SenderMessageKey
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SenderMessageKey.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SenderMessageKey;
        })();

        SenderKeyStateStructure.SenderSigningKey = (function() {

            /**
             * Properties of a SenderSigningKey.
             * @memberof SessionStructure.SenderKeyStateStructure
             * @interface ISenderSigningKey
             * @property {Uint8Array|null} ["public"] SenderSigningKey public
             * @property {Uint8Array|null} ["private"] SenderSigningKey private
             */

            /**
             * Constructs a new SenderSigningKey.
             * @memberof SessionStructure.SenderKeyStateStructure
             * @classdesc Represents a SenderSigningKey.
             * @implements ISenderSigningKey
             * @constructor
             * @param {SessionStructure.SenderKeyStateStructure.ISenderSigningKey=} [properties] Properties to set
             */
            function SenderSigningKey(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SenderSigningKey public.
             * @member {Uint8Array} public
             * @memberof SessionStructure.SenderKeyStateStructure.SenderSigningKey
             * @instance
             */
            SenderSigningKey.prototype["public"] = $util.newBuffer([]);

            /**
             * SenderSigningKey private.
             * @member {Uint8Array} private
             * @memberof SessionStructure.SenderKeyStateStructure.SenderSigningKey
             * @instance
             */
            SenderSigningKey.prototype["private"] = $util.newBuffer([]);

            /**
             * Creates a new SenderSigningKey instance using the specified properties.
             * @function create
             * @memberof SessionStructure.SenderKeyStateStructure.SenderSigningKey
             * @static
             * @param {SessionStructure.SenderKeyStateStructure.ISenderSigningKey=} [properties] Properties to set
             * @returns {SessionStructure.SenderKeyStateStructure.SenderSigningKey} SenderSigningKey instance
             */
            SenderSigningKey.create = function create(properties) {
                return new SenderSigningKey(properties);
            };

            /**
             * Encodes the specified SenderSigningKey message. Does not implicitly {@link SessionStructure.SenderKeyStateStructure.SenderSigningKey.verify|verify} messages.
             * @function encode
             * @memberof SessionStructure.SenderKeyStateStructure.SenderSigningKey
             * @static
             * @param {SessionStructure.SenderKeyStateStructure.ISenderSigningKey} message SenderSigningKey message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SenderSigningKey.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message["public"] != null && Object.hasOwnProperty.call(message, "public"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message["public"]);
                if (message["private"] != null && Object.hasOwnProperty.call(message, "private"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message["private"]);
                return writer;
            };

            /**
             * Encodes the specified SenderSigningKey message, length delimited. Does not implicitly {@link SessionStructure.SenderKeyStateStructure.SenderSigningKey.verify|verify} messages.
             * @function encodeDelimited
             * @memberof SessionStructure.SenderKeyStateStructure.SenderSigningKey
             * @static
             * @param {SessionStructure.SenderKeyStateStructure.ISenderSigningKey} message SenderSigningKey message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SenderSigningKey.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SenderSigningKey message from the specified reader or buffer.
             * @function decode
             * @memberof SessionStructure.SenderKeyStateStructure.SenderSigningKey
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {SessionStructure.SenderKeyStateStructure.SenderSigningKey} SenderSigningKey
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SenderSigningKey.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionStructure.SenderKeyStateStructure.SenderSigningKey();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message["public"] = reader.bytes();
                        break;
                    case 2:
                        message["private"] = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SenderSigningKey message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof SessionStructure.SenderKeyStateStructure.SenderSigningKey
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {SessionStructure.SenderKeyStateStructure.SenderSigningKey} SenderSigningKey
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SenderSigningKey.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SenderSigningKey message.
             * @function verify
             * @memberof SessionStructure.SenderKeyStateStructure.SenderSigningKey
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SenderSigningKey.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message["public"] != null && message.hasOwnProperty("public"))
                    if (!(message["public"] && typeof message["public"].length === "number" || $util.isString(message["public"])))
                        return "public: buffer expected";
                if (message["private"] != null && message.hasOwnProperty("private"))
                    if (!(message["private"] && typeof message["private"].length === "number" || $util.isString(message["private"])))
                        return "private: buffer expected";
                return null;
            };

            /**
             * Creates a SenderSigningKey message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof SessionStructure.SenderKeyStateStructure.SenderSigningKey
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {SessionStructure.SenderKeyStateStructure.SenderSigningKey} SenderSigningKey
             */
            SenderSigningKey.fromObject = function fromObject(object) {
                if (object instanceof $root.SessionStructure.SenderKeyStateStructure.SenderSigningKey)
                    return object;
                var message = new $root.SessionStructure.SenderKeyStateStructure.SenderSigningKey();
                if (object["public"] != null)
                    if (typeof object["public"] === "string")
                        $util.base64.decode(object["public"], message["public"] = $util.newBuffer($util.base64.length(object["public"])), 0);
                    else if (object["public"].length)
                        message["public"] = object["public"];
                if (object["private"] != null)
                    if (typeof object["private"] === "string")
                        $util.base64.decode(object["private"], message["private"] = $util.newBuffer($util.base64.length(object["private"])), 0);
                    else if (object["private"].length)
                        message["private"] = object["private"];
                return message;
            };

            /**
             * Creates a plain object from a SenderSigningKey message. Also converts values to other types if specified.
             * @function toObject
             * @memberof SessionStructure.SenderKeyStateStructure.SenderSigningKey
             * @static
             * @param {SessionStructure.SenderKeyStateStructure.SenderSigningKey} message SenderSigningKey
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SenderSigningKey.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object["public"] = "";
                    else {
                        object["public"] = [];
                        if (options.bytes !== Array)
                            object["public"] = $util.newBuffer(object["public"]);
                    }
                    if (options.bytes === String)
                        object["private"] = "";
                    else {
                        object["private"] = [];
                        if (options.bytes !== Array)
                            object["private"] = $util.newBuffer(object["private"]);
                    }
                }
                if (message["public"] != null && message.hasOwnProperty("public"))
                    object["public"] = options.bytes === String ? $util.base64.encode(message["public"], 0, message["public"].length) : options.bytes === Array ? Array.prototype.slice.call(message["public"]) : message["public"];
                if (message["private"] != null && message.hasOwnProperty("private"))
                    object["private"] = options.bytes === String ? $util.base64.encode(message["private"], 0, message["private"].length) : options.bytes === Array ? Array.prototype.slice.call(message["private"]) : message["private"];
                return object;
            };

            /**
             * Converts this SenderSigningKey to JSON.
             * @function toJSON
             * @memberof SessionStructure.SenderKeyStateStructure.SenderSigningKey
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SenderSigningKey.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SenderSigningKey;
        })();

        return SenderKeyStateStructure;
    })();

    SessionStructure.SenderKeyRecordStructure = (function() {

        /**
         * Properties of a SenderKeyRecordStructure.
         * @memberof SessionStructure
         * @interface ISenderKeyRecordStructure
         * @property {Array.<SessionStructure.ISenderKeyStateStructure>|null} [senderKeyStates] SenderKeyRecordStructure senderKeyStates
         */

        /**
         * Constructs a new SenderKeyRecordStructure.
         * @memberof SessionStructure
         * @classdesc Represents a SenderKeyRecordStructure.
         * @implements ISenderKeyRecordStructure
         * @constructor
         * @param {SessionStructure.ISenderKeyRecordStructure=} [properties] Properties to set
         */
        function SenderKeyRecordStructure(properties) {
            this.senderKeyStates = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SenderKeyRecordStructure senderKeyStates.
         * @member {Array.<SessionStructure.ISenderKeyStateStructure>} senderKeyStates
         * @memberof SessionStructure.SenderKeyRecordStructure
         * @instance
         */
        SenderKeyRecordStructure.prototype.senderKeyStates = $util.emptyArray;

        /**
         * Creates a new SenderKeyRecordStructure instance using the specified properties.
         * @function create
         * @memberof SessionStructure.SenderKeyRecordStructure
         * @static
         * @param {SessionStructure.ISenderKeyRecordStructure=} [properties] Properties to set
         * @returns {SessionStructure.SenderKeyRecordStructure} SenderKeyRecordStructure instance
         */
        SenderKeyRecordStructure.create = function create(properties) {
            return new SenderKeyRecordStructure(properties);
        };

        /**
         * Encodes the specified SenderKeyRecordStructure message. Does not implicitly {@link SessionStructure.SenderKeyRecordStructure.verify|verify} messages.
         * @function encode
         * @memberof SessionStructure.SenderKeyRecordStructure
         * @static
         * @param {SessionStructure.ISenderKeyRecordStructure} message SenderKeyRecordStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderKeyRecordStructure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.senderKeyStates != null && message.senderKeyStates.length)
                for (var i = 0; i < message.senderKeyStates.length; ++i)
                    $root.SessionStructure.SenderKeyStateStructure.encode(message.senderKeyStates[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SenderKeyRecordStructure message, length delimited. Does not implicitly {@link SessionStructure.SenderKeyRecordStructure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SessionStructure.SenderKeyRecordStructure
         * @static
         * @param {SessionStructure.ISenderKeyRecordStructure} message SenderKeyRecordStructure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SenderKeyRecordStructure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SenderKeyRecordStructure message from the specified reader or buffer.
         * @function decode
         * @memberof SessionStructure.SenderKeyRecordStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SessionStructure.SenderKeyRecordStructure} SenderKeyRecordStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderKeyRecordStructure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionStructure.SenderKeyRecordStructure();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.senderKeyStates && message.senderKeyStates.length))
                        message.senderKeyStates = [];
                    message.senderKeyStates.push($root.SessionStructure.SenderKeyStateStructure.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SenderKeyRecordStructure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SessionStructure.SenderKeyRecordStructure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SessionStructure.SenderKeyRecordStructure} SenderKeyRecordStructure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SenderKeyRecordStructure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SenderKeyRecordStructure message.
         * @function verify
         * @memberof SessionStructure.SenderKeyRecordStructure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SenderKeyRecordStructure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.senderKeyStates != null && message.hasOwnProperty("senderKeyStates")) {
                if (!Array.isArray(message.senderKeyStates))
                    return "senderKeyStates: array expected";
                for (var i = 0; i < message.senderKeyStates.length; ++i) {
                    var error = $root.SessionStructure.SenderKeyStateStructure.verify(message.senderKeyStates[i]);
                    if (error)
                        return "senderKeyStates." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SenderKeyRecordStructure message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SessionStructure.SenderKeyRecordStructure
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SessionStructure.SenderKeyRecordStructure} SenderKeyRecordStructure
         */
        SenderKeyRecordStructure.fromObject = function fromObject(object) {
            if (object instanceof $root.SessionStructure.SenderKeyRecordStructure)
                return object;
            var message = new $root.SessionStructure.SenderKeyRecordStructure();
            if (object.senderKeyStates) {
                if (!Array.isArray(object.senderKeyStates))
                    throw TypeError(".SessionStructure.SenderKeyRecordStructure.senderKeyStates: array expected");
                message.senderKeyStates = [];
                for (var i = 0; i < object.senderKeyStates.length; ++i) {
                    if (typeof object.senderKeyStates[i] !== "object")
                        throw TypeError(".SessionStructure.SenderKeyRecordStructure.senderKeyStates: object expected");
                    message.senderKeyStates[i] = $root.SessionStructure.SenderKeyStateStructure.fromObject(object.senderKeyStates[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SenderKeyRecordStructure message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SessionStructure.SenderKeyRecordStructure
         * @static
         * @param {SessionStructure.SenderKeyRecordStructure} message SenderKeyRecordStructure
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SenderKeyRecordStructure.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.senderKeyStates = [];
            if (message.senderKeyStates && message.senderKeyStates.length) {
                object.senderKeyStates = [];
                for (var j = 0; j < message.senderKeyStates.length; ++j)
                    object.senderKeyStates[j] = $root.SessionStructure.SenderKeyStateStructure.toObject(message.senderKeyStates[j], options);
            }
            return object;
        };

        /**
         * Converts this SenderKeyRecordStructure to JSON.
         * @function toJSON
         * @memberof SessionStructure.SenderKeyRecordStructure
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SenderKeyRecordStructure.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SenderKeyRecordStructure;
    })();

    return SessionStructure;
})();

$root.textsecure = (function() {

    /**
     * Namespace textsecure.
     * @exports textsecure
     * @namespace
     */
    var textsecure = {};

    textsecure.WhisperMessage = (function() {

        /**
         * Properties of a WhisperMessage.
         * @memberof textsecure
         * @interface IWhisperMessage
         * @property {Uint8Array|null} [ephemeralKey] WhisperMessage ephemeralKey
         * @property {number|null} [counter] WhisperMessage counter
         * @property {number|null} [previousCounter] WhisperMessage previousCounter
         * @property {Uint8Array|null} [ciphertext] WhisperMessage ciphertext
         */

        /**
         * Constructs a new WhisperMessage.
         * @memberof textsecure
         * @classdesc Represents a WhisperMessage.
         * @implements IWhisperMessage
         * @constructor
         * @param {textsecure.IWhisperMessage=} [properties] Properties to set
         */
        function WhisperMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WhisperMessage ephemeralKey.
         * @member {Uint8Array} ephemeralKey
         * @memberof textsecure.WhisperMessage
         * @instance
         */
        WhisperMessage.prototype.ephemeralKey = $util.newBuffer([]);

        /**
         * WhisperMessage counter.
         * @member {number} counter
         * @memberof textsecure.WhisperMessage
         * @instance
         */
        WhisperMessage.prototype.counter = 0;

        /**
         * WhisperMessage previousCounter.
         * @member {number} previousCounter
         * @memberof textsecure.WhisperMessage
         * @instance
         */
        WhisperMessage.prototype.previousCounter = 0;

        /**
         * WhisperMessage ciphertext.
         * @member {Uint8Array} ciphertext
         * @memberof textsecure.WhisperMessage
         * @instance
         */
        WhisperMessage.prototype.ciphertext = $util.newBuffer([]);

        /**
         * Creates a new WhisperMessage instance using the specified properties.
         * @function create
         * @memberof textsecure.WhisperMessage
         * @static
         * @param {textsecure.IWhisperMessage=} [properties] Properties to set
         * @returns {textsecure.WhisperMessage} WhisperMessage instance
         */
        WhisperMessage.create = function create(properties) {
            return new WhisperMessage(properties);
        };

        /**
         * Encodes the specified WhisperMessage message. Does not implicitly {@link textsecure.WhisperMessage.verify|verify} messages.
         * @function encode
         * @memberof textsecure.WhisperMessage
         * @static
         * @param {textsecure.IWhisperMessage} message WhisperMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WhisperMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ephemeralKey != null && Object.hasOwnProperty.call(message, "ephemeralKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ephemeralKey);
            if (message.counter != null && Object.hasOwnProperty.call(message, "counter"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.counter);
            if (message.previousCounter != null && Object.hasOwnProperty.call(message, "previousCounter"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.previousCounter);
            if (message.ciphertext != null && Object.hasOwnProperty.call(message, "ciphertext"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.ciphertext);
            return writer;
        };

        /**
         * Encodes the specified WhisperMessage message, length delimited. Does not implicitly {@link textsecure.WhisperMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof textsecure.WhisperMessage
         * @static
         * @param {textsecure.IWhisperMessage} message WhisperMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WhisperMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WhisperMessage message from the specified reader or buffer.
         * @function decode
         * @memberof textsecure.WhisperMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {textsecure.WhisperMessage} WhisperMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WhisperMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.textsecure.WhisperMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ephemeralKey = reader.bytes();
                    break;
                case 2:
                    message.counter = reader.uint32();
                    break;
                case 3:
                    message.previousCounter = reader.uint32();
                    break;
                case 4:
                    message.ciphertext = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WhisperMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof textsecure.WhisperMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {textsecure.WhisperMessage} WhisperMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WhisperMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WhisperMessage message.
         * @function verify
         * @memberof textsecure.WhisperMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WhisperMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ephemeralKey != null && message.hasOwnProperty("ephemeralKey"))
                if (!(message.ephemeralKey && typeof message.ephemeralKey.length === "number" || $util.isString(message.ephemeralKey)))
                    return "ephemeralKey: buffer expected";
            if (message.counter != null && message.hasOwnProperty("counter"))
                if (!$util.isInteger(message.counter))
                    return "counter: integer expected";
            if (message.previousCounter != null && message.hasOwnProperty("previousCounter"))
                if (!$util.isInteger(message.previousCounter))
                    return "previousCounter: integer expected";
            if (message.ciphertext != null && message.hasOwnProperty("ciphertext"))
                if (!(message.ciphertext && typeof message.ciphertext.length === "number" || $util.isString(message.ciphertext)))
                    return "ciphertext: buffer expected";
            return null;
        };

        /**
         * Creates a WhisperMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof textsecure.WhisperMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {textsecure.WhisperMessage} WhisperMessage
         */
        WhisperMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.textsecure.WhisperMessage)
                return object;
            var message = new $root.textsecure.WhisperMessage();
            if (object.ephemeralKey != null)
                if (typeof object.ephemeralKey === "string")
                    $util.base64.decode(object.ephemeralKey, message.ephemeralKey = $util.newBuffer($util.base64.length(object.ephemeralKey)), 0);
                else if (object.ephemeralKey.length)
                    message.ephemeralKey = object.ephemeralKey;
            if (object.counter != null)
                message.counter = object.counter >>> 0;
            if (object.previousCounter != null)
                message.previousCounter = object.previousCounter >>> 0;
            if (object.ciphertext != null)
                if (typeof object.ciphertext === "string")
                    $util.base64.decode(object.ciphertext, message.ciphertext = $util.newBuffer($util.base64.length(object.ciphertext)), 0);
                else if (object.ciphertext.length)
                    message.ciphertext = object.ciphertext;
            return message;
        };

        /**
         * Creates a plain object from a WhisperMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof textsecure.WhisperMessage
         * @static
         * @param {textsecure.WhisperMessage} message WhisperMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WhisperMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.ephemeralKey = "";
                else {
                    object.ephemeralKey = [];
                    if (options.bytes !== Array)
                        object.ephemeralKey = $util.newBuffer(object.ephemeralKey);
                }
                object.counter = 0;
                object.previousCounter = 0;
                if (options.bytes === String)
                    object.ciphertext = "";
                else {
                    object.ciphertext = [];
                    if (options.bytes !== Array)
                        object.ciphertext = $util.newBuffer(object.ciphertext);
                }
            }
            if (message.ephemeralKey != null && message.hasOwnProperty("ephemeralKey"))
                object.ephemeralKey = options.bytes === String ? $util.base64.encode(message.ephemeralKey, 0, message.ephemeralKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.ephemeralKey) : message.ephemeralKey;
            if (message.counter != null && message.hasOwnProperty("counter"))
                object.counter = message.counter;
            if (message.previousCounter != null && message.hasOwnProperty("previousCounter"))
                object.previousCounter = message.previousCounter;
            if (message.ciphertext != null && message.hasOwnProperty("ciphertext"))
                object.ciphertext = options.bytes === String ? $util.base64.encode(message.ciphertext, 0, message.ciphertext.length) : options.bytes === Array ? Array.prototype.slice.call(message.ciphertext) : message.ciphertext;
            return object;
        };

        /**
         * Converts this WhisperMessage to JSON.
         * @function toJSON
         * @memberof textsecure.WhisperMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WhisperMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WhisperMessage;
    })();

    textsecure.PreKeyWhisperMessage = (function() {

        /**
         * Properties of a PreKeyWhisperMessage.
         * @memberof textsecure
         * @interface IPreKeyWhisperMessage
         * @property {number|null} [preKeyId] PreKeyWhisperMessage preKeyId
         * @property {Uint8Array|null} [baseKey] PreKeyWhisperMessage baseKey
         * @property {Uint8Array|null} [identityKey] PreKeyWhisperMessage identityKey
         * @property {Uint8Array|null} [message] PreKeyWhisperMessage message
         * @property {number|null} [registrationId] PreKeyWhisperMessage registrationId
         * @property {number|null} [signedPreKeyId] PreKeyWhisperMessage signedPreKeyId
         */

        /**
         * Constructs a new PreKeyWhisperMessage.
         * @memberof textsecure
         * @classdesc Represents a PreKeyWhisperMessage.
         * @implements IPreKeyWhisperMessage
         * @constructor
         * @param {textsecure.IPreKeyWhisperMessage=} [properties] Properties to set
         */
        function PreKeyWhisperMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PreKeyWhisperMessage preKeyId.
         * @member {number} preKeyId
         * @memberof textsecure.PreKeyWhisperMessage
         * @instance
         */
        PreKeyWhisperMessage.prototype.preKeyId = 0;

        /**
         * PreKeyWhisperMessage baseKey.
         * @member {Uint8Array} baseKey
         * @memberof textsecure.PreKeyWhisperMessage
         * @instance
         */
        PreKeyWhisperMessage.prototype.baseKey = $util.newBuffer([]);

        /**
         * PreKeyWhisperMessage identityKey.
         * @member {Uint8Array} identityKey
         * @memberof textsecure.PreKeyWhisperMessage
         * @instance
         */
        PreKeyWhisperMessage.prototype.identityKey = $util.newBuffer([]);

        /**
         * PreKeyWhisperMessage message.
         * @member {Uint8Array} message
         * @memberof textsecure.PreKeyWhisperMessage
         * @instance
         */
        PreKeyWhisperMessage.prototype.message = $util.newBuffer([]);

        /**
         * PreKeyWhisperMessage registrationId.
         * @member {number} registrationId
         * @memberof textsecure.PreKeyWhisperMessage
         * @instance
         */
        PreKeyWhisperMessage.prototype.registrationId = 0;

        /**
         * PreKeyWhisperMessage signedPreKeyId.
         * @member {number} signedPreKeyId
         * @memberof textsecure.PreKeyWhisperMessage
         * @instance
         */
        PreKeyWhisperMessage.prototype.signedPreKeyId = 0;

        /**
         * Creates a new PreKeyWhisperMessage instance using the specified properties.
         * @function create
         * @memberof textsecure.PreKeyWhisperMessage
         * @static
         * @param {textsecure.IPreKeyWhisperMessage=} [properties] Properties to set
         * @returns {textsecure.PreKeyWhisperMessage} PreKeyWhisperMessage instance
         */
        PreKeyWhisperMessage.create = function create(properties) {
            return new PreKeyWhisperMessage(properties);
        };

        /**
         * Encodes the specified PreKeyWhisperMessage message. Does not implicitly {@link textsecure.PreKeyWhisperMessage.verify|verify} messages.
         * @function encode
         * @memberof textsecure.PreKeyWhisperMessage
         * @static
         * @param {textsecure.IPreKeyWhisperMessage} message PreKeyWhisperMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreKeyWhisperMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.preKeyId != null && Object.hasOwnProperty.call(message, "preKeyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.preKeyId);
            if (message.baseKey != null && Object.hasOwnProperty.call(message, "baseKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.baseKey);
            if (message.identityKey != null && Object.hasOwnProperty.call(message, "identityKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.identityKey);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.message);
            if (message.registrationId != null && Object.hasOwnProperty.call(message, "registrationId"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.registrationId);
            if (message.signedPreKeyId != null && Object.hasOwnProperty.call(message, "signedPreKeyId"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.signedPreKeyId);
            return writer;
        };

        /**
         * Encodes the specified PreKeyWhisperMessage message, length delimited. Does not implicitly {@link textsecure.PreKeyWhisperMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof textsecure.PreKeyWhisperMessage
         * @static
         * @param {textsecure.IPreKeyWhisperMessage} message PreKeyWhisperMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreKeyWhisperMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PreKeyWhisperMessage message from the specified reader or buffer.
         * @function decode
         * @memberof textsecure.PreKeyWhisperMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {textsecure.PreKeyWhisperMessage} PreKeyWhisperMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreKeyWhisperMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.textsecure.PreKeyWhisperMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.preKeyId = reader.uint32();
                    break;
                case 2:
                    message.baseKey = reader.bytes();
                    break;
                case 3:
                    message.identityKey = reader.bytes();
                    break;
                case 4:
                    message.message = reader.bytes();
                    break;
                case 5:
                    message.registrationId = reader.uint32();
                    break;
                case 6:
                    message.signedPreKeyId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PreKeyWhisperMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof textsecure.PreKeyWhisperMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {textsecure.PreKeyWhisperMessage} PreKeyWhisperMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreKeyWhisperMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PreKeyWhisperMessage message.
         * @function verify
         * @memberof textsecure.PreKeyWhisperMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PreKeyWhisperMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.preKeyId != null && message.hasOwnProperty("preKeyId"))
                if (!$util.isInteger(message.preKeyId))
                    return "preKeyId: integer expected";
            if (message.baseKey != null && message.hasOwnProperty("baseKey"))
                if (!(message.baseKey && typeof message.baseKey.length === "number" || $util.isString(message.baseKey)))
                    return "baseKey: buffer expected";
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                if (!(message.identityKey && typeof message.identityKey.length === "number" || $util.isString(message.identityKey)))
                    return "identityKey: buffer expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!(message.message && typeof message.message.length === "number" || $util.isString(message.message)))
                    return "message: buffer expected";
            if (message.registrationId != null && message.hasOwnProperty("registrationId"))
                if (!$util.isInteger(message.registrationId))
                    return "registrationId: integer expected";
            if (message.signedPreKeyId != null && message.hasOwnProperty("signedPreKeyId"))
                if (!$util.isInteger(message.signedPreKeyId))
                    return "signedPreKeyId: integer expected";
            return null;
        };

        /**
         * Creates a PreKeyWhisperMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof textsecure.PreKeyWhisperMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {textsecure.PreKeyWhisperMessage} PreKeyWhisperMessage
         */
        PreKeyWhisperMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.textsecure.PreKeyWhisperMessage)
                return object;
            var message = new $root.textsecure.PreKeyWhisperMessage();
            if (object.preKeyId != null)
                message.preKeyId = object.preKeyId >>> 0;
            if (object.baseKey != null)
                if (typeof object.baseKey === "string")
                    $util.base64.decode(object.baseKey, message.baseKey = $util.newBuffer($util.base64.length(object.baseKey)), 0);
                else if (object.baseKey.length)
                    message.baseKey = object.baseKey;
            if (object.identityKey != null)
                if (typeof object.identityKey === "string")
                    $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);
                else if (object.identityKey.length)
                    message.identityKey = object.identityKey;
            if (object.message != null)
                if (typeof object.message === "string")
                    $util.base64.decode(object.message, message.message = $util.newBuffer($util.base64.length(object.message)), 0);
                else if (object.message.length)
                    message.message = object.message;
            if (object.registrationId != null)
                message.registrationId = object.registrationId >>> 0;
            if (object.signedPreKeyId != null)
                message.signedPreKeyId = object.signedPreKeyId >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PreKeyWhisperMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof textsecure.PreKeyWhisperMessage
         * @static
         * @param {textsecure.PreKeyWhisperMessage} message PreKeyWhisperMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PreKeyWhisperMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.preKeyId = 0;
                if (options.bytes === String)
                    object.baseKey = "";
                else {
                    object.baseKey = [];
                    if (options.bytes !== Array)
                        object.baseKey = $util.newBuffer(object.baseKey);
                }
                if (options.bytes === String)
                    object.identityKey = "";
                else {
                    object.identityKey = [];
                    if (options.bytes !== Array)
                        object.identityKey = $util.newBuffer(object.identityKey);
                }
                if (options.bytes === String)
                    object.message = "";
                else {
                    object.message = [];
                    if (options.bytes !== Array)
                        object.message = $util.newBuffer(object.message);
                }
                object.registrationId = 0;
                object.signedPreKeyId = 0;
            }
            if (message.preKeyId != null && message.hasOwnProperty("preKeyId"))
                object.preKeyId = message.preKeyId;
            if (message.baseKey != null && message.hasOwnProperty("baseKey"))
                object.baseKey = options.bytes === String ? $util.base64.encode(message.baseKey, 0, message.baseKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.baseKey) : message.baseKey;
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = options.bytes === String ? $util.base64.encode(message.message, 0, message.message.length) : options.bytes === Array ? Array.prototype.slice.call(message.message) : message.message;
            if (message.registrationId != null && message.hasOwnProperty("registrationId"))
                object.registrationId = message.registrationId;
            if (message.signedPreKeyId != null && message.hasOwnProperty("signedPreKeyId"))
                object.signedPreKeyId = message.signedPreKeyId;
            return object;
        };

        /**
         * Converts this PreKeyWhisperMessage to JSON.
         * @function toJSON
         * @memberof textsecure.PreKeyWhisperMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PreKeyWhisperMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PreKeyWhisperMessage;
    })();

    textsecure.KeyExchangeMessage = (function() {

        /**
         * Properties of a KeyExchangeMessage.
         * @memberof textsecure
         * @interface IKeyExchangeMessage
         * @property {number|null} [id] KeyExchangeMessage id
         * @property {Uint8Array|null} [baseKey] KeyExchangeMessage baseKey
         * @property {Uint8Array|null} [ephemeralKey] KeyExchangeMessage ephemeralKey
         * @property {Uint8Array|null} [identityKey] KeyExchangeMessage identityKey
         * @property {Uint8Array|null} [baseKeySignature] KeyExchangeMessage baseKeySignature
         */

        /**
         * Constructs a new KeyExchangeMessage.
         * @memberof textsecure
         * @classdesc Represents a KeyExchangeMessage.
         * @implements IKeyExchangeMessage
         * @constructor
         * @param {textsecure.IKeyExchangeMessage=} [properties] Properties to set
         */
        function KeyExchangeMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeyExchangeMessage id.
         * @member {number} id
         * @memberof textsecure.KeyExchangeMessage
         * @instance
         */
        KeyExchangeMessage.prototype.id = 0;

        /**
         * KeyExchangeMessage baseKey.
         * @member {Uint8Array} baseKey
         * @memberof textsecure.KeyExchangeMessage
         * @instance
         */
        KeyExchangeMessage.prototype.baseKey = $util.newBuffer([]);

        /**
         * KeyExchangeMessage ephemeralKey.
         * @member {Uint8Array} ephemeralKey
         * @memberof textsecure.KeyExchangeMessage
         * @instance
         */
        KeyExchangeMessage.prototype.ephemeralKey = $util.newBuffer([]);

        /**
         * KeyExchangeMessage identityKey.
         * @member {Uint8Array} identityKey
         * @memberof textsecure.KeyExchangeMessage
         * @instance
         */
        KeyExchangeMessage.prototype.identityKey = $util.newBuffer([]);

        /**
         * KeyExchangeMessage baseKeySignature.
         * @member {Uint8Array} baseKeySignature
         * @memberof textsecure.KeyExchangeMessage
         * @instance
         */
        KeyExchangeMessage.prototype.baseKeySignature = $util.newBuffer([]);

        /**
         * Creates a new KeyExchangeMessage instance using the specified properties.
         * @function create
         * @memberof textsecure.KeyExchangeMessage
         * @static
         * @param {textsecure.IKeyExchangeMessage=} [properties] Properties to set
         * @returns {textsecure.KeyExchangeMessage} KeyExchangeMessage instance
         */
        KeyExchangeMessage.create = function create(properties) {
            return new KeyExchangeMessage(properties);
        };

        /**
         * Encodes the specified KeyExchangeMessage message. Does not implicitly {@link textsecure.KeyExchangeMessage.verify|verify} messages.
         * @function encode
         * @memberof textsecure.KeyExchangeMessage
         * @static
         * @param {textsecure.IKeyExchangeMessage} message KeyExchangeMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyExchangeMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.baseKey != null && Object.hasOwnProperty.call(message, "baseKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.baseKey);
            if (message.ephemeralKey != null && Object.hasOwnProperty.call(message, "ephemeralKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.ephemeralKey);
            if (message.identityKey != null && Object.hasOwnProperty.call(message, "identityKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.identityKey);
            if (message.baseKeySignature != null && Object.hasOwnProperty.call(message, "baseKeySignature"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.baseKeySignature);
            return writer;
        };

        /**
         * Encodes the specified KeyExchangeMessage message, length delimited. Does not implicitly {@link textsecure.KeyExchangeMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof textsecure.KeyExchangeMessage
         * @static
         * @param {textsecure.IKeyExchangeMessage} message KeyExchangeMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyExchangeMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeyExchangeMessage message from the specified reader or buffer.
         * @function decode
         * @memberof textsecure.KeyExchangeMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {textsecure.KeyExchangeMessage} KeyExchangeMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyExchangeMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.textsecure.KeyExchangeMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint32();
                    break;
                case 2:
                    message.baseKey = reader.bytes();
                    break;
                case 3:
                    message.ephemeralKey = reader.bytes();
                    break;
                case 4:
                    message.identityKey = reader.bytes();
                    break;
                case 5:
                    message.baseKeySignature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeyExchangeMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof textsecure.KeyExchangeMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {textsecure.KeyExchangeMessage} KeyExchangeMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyExchangeMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeyExchangeMessage message.
         * @function verify
         * @memberof textsecure.KeyExchangeMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeyExchangeMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.baseKey != null && message.hasOwnProperty("baseKey"))
                if (!(message.baseKey && typeof message.baseKey.length === "number" || $util.isString(message.baseKey)))
                    return "baseKey: buffer expected";
            if (message.ephemeralKey != null && message.hasOwnProperty("ephemeralKey"))
                if (!(message.ephemeralKey && typeof message.ephemeralKey.length === "number" || $util.isString(message.ephemeralKey)))
                    return "ephemeralKey: buffer expected";
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                if (!(message.identityKey && typeof message.identityKey.length === "number" || $util.isString(message.identityKey)))
                    return "identityKey: buffer expected";
            if (message.baseKeySignature != null && message.hasOwnProperty("baseKeySignature"))
                if (!(message.baseKeySignature && typeof message.baseKeySignature.length === "number" || $util.isString(message.baseKeySignature)))
                    return "baseKeySignature: buffer expected";
            return null;
        };

        /**
         * Creates a KeyExchangeMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof textsecure.KeyExchangeMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {textsecure.KeyExchangeMessage} KeyExchangeMessage
         */
        KeyExchangeMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.textsecure.KeyExchangeMessage)
                return object;
            var message = new $root.textsecure.KeyExchangeMessage();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.baseKey != null)
                if (typeof object.baseKey === "string")
                    $util.base64.decode(object.baseKey, message.baseKey = $util.newBuffer($util.base64.length(object.baseKey)), 0);
                else if (object.baseKey.length)
                    message.baseKey = object.baseKey;
            if (object.ephemeralKey != null)
                if (typeof object.ephemeralKey === "string")
                    $util.base64.decode(object.ephemeralKey, message.ephemeralKey = $util.newBuffer($util.base64.length(object.ephemeralKey)), 0);
                else if (object.ephemeralKey.length)
                    message.ephemeralKey = object.ephemeralKey;
            if (object.identityKey != null)
                if (typeof object.identityKey === "string")
                    $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);
                else if (object.identityKey.length)
                    message.identityKey = object.identityKey;
            if (object.baseKeySignature != null)
                if (typeof object.baseKeySignature === "string")
                    $util.base64.decode(object.baseKeySignature, message.baseKeySignature = $util.newBuffer($util.base64.length(object.baseKeySignature)), 0);
                else if (object.baseKeySignature.length)
                    message.baseKeySignature = object.baseKeySignature;
            return message;
        };

        /**
         * Creates a plain object from a KeyExchangeMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof textsecure.KeyExchangeMessage
         * @static
         * @param {textsecure.KeyExchangeMessage} message KeyExchangeMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeyExchangeMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                if (options.bytes === String)
                    object.baseKey = "";
                else {
                    object.baseKey = [];
                    if (options.bytes !== Array)
                        object.baseKey = $util.newBuffer(object.baseKey);
                }
                if (options.bytes === String)
                    object.ephemeralKey = "";
                else {
                    object.ephemeralKey = [];
                    if (options.bytes !== Array)
                        object.ephemeralKey = $util.newBuffer(object.ephemeralKey);
                }
                if (options.bytes === String)
                    object.identityKey = "";
                else {
                    object.identityKey = [];
                    if (options.bytes !== Array)
                        object.identityKey = $util.newBuffer(object.identityKey);
                }
                if (options.bytes === String)
                    object.baseKeySignature = "";
                else {
                    object.baseKeySignature = [];
                    if (options.bytes !== Array)
                        object.baseKeySignature = $util.newBuffer(object.baseKeySignature);
                }
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.baseKey != null && message.hasOwnProperty("baseKey"))
                object.baseKey = options.bytes === String ? $util.base64.encode(message.baseKey, 0, message.baseKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.baseKey) : message.baseKey;
            if (message.ephemeralKey != null && message.hasOwnProperty("ephemeralKey"))
                object.ephemeralKey = options.bytes === String ? $util.base64.encode(message.ephemeralKey, 0, message.ephemeralKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.ephemeralKey) : message.ephemeralKey;
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;
            if (message.baseKeySignature != null && message.hasOwnProperty("baseKeySignature"))
                object.baseKeySignature = options.bytes === String ? $util.base64.encode(message.baseKeySignature, 0, message.baseKeySignature.length) : options.bytes === Array ? Array.prototype.slice.call(message.baseKeySignature) : message.baseKeySignature;
            return object;
        };

        /**
         * Converts this KeyExchangeMessage to JSON.
         * @function toJSON
         * @memberof textsecure.KeyExchangeMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeyExchangeMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KeyExchangeMessage;
    })();

    return textsecure;
})();

module.exports = $root;
